<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Archetypes | whiteKBlog</title>
<meta name=keywords content>
<meta name=description content>
<meta name=author content="whitek">
<link rel=canonical href=https://pythongo.wiki/archetypes/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style>
<link rel=preload href="https://avatars.githubusercontent.com/u/9432907?v=4" as=image>
<link rel=icon href=https://pythongo.wiki/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://pythongo.wiki/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://pythongo.wiki/favicon-32x32.png>
<link rel=apple-touch-icon href=https://pythongo.wiki/apple-touch-icon.png>
<link rel=mask-icon href=https://pythongo.wiki/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.87.0">
<link rel=alternate type=application/rss+xml href=https://pythongo.wiki/archetypes/index.xml>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="Archetypes">
<meta property="og:description" content>
<meta property="og:type" content="website">
<meta property="og:url" content="https://pythongo.wiki/archetypes/"><meta property="og:site_name" content="ExampleSite">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Archetypes">
<meta name=twitter:description content>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Archetypes","item":"https://pythongo.wiki/archetypes/"}]}</script>
</head>
<body class=list id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://pythongo.wiki/ accesskey=h title="Home (Alt + H)">
<img src="https://avatars.githubusercontent.com/u/9432907?v=4" alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://pythongo.wiki/tags/ title=tags>
<span>tags</span>
</a>
</li>
<li>
<a href=https://pythongo.wiki/about/ title=about>
<span>about</span>
</a>
</li>
<li>
<a href=https://pythongo.wiki title=wiki>
<span>wiki</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<header class=page-header><div class=breadcrumbs><a href=https://pythongo.wiki/>Home</a></div>
<h1>Archetypes</h1>
</header>
<article class=post-entry>
<header class=entry-header>
<h2>Shell 如何传参</h2>
</header>
<section class=entry-content>
<p># how to pass arguments to shell script # 利用echo打印你传入的参数 # 上面可以看到$0表示 我们运行sh文件的语句 ./demo.sh，这个不是一个我们提供的真实的参数。 # echo $0 $1 $2 $3 # 换成args 数组方式去存储参数列表 args=("$@") # echo ${args[0]} ${args[1]} ${args[2]} ${args[3]} # 更简单的方法 $@可以表示传入的参数列表，直接打印出来 # echo $@ # 如何计算参数的个数 # $#可以存储参数的个数值 echo $# </p>
</section>
<footer class=entry-footer>August 18, 2019&nbsp;·&nbsp;1 min&nbsp;·&nbsp;whitek</footer>
<a class=entry-link aria-label="post link to Shell 如何传参" href=https://pythongo.wiki/archetypes/shell-%E5%A6%82%E4%BD%95%E4%BC%A0%E5%8F%82/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Shell 获取用户输入</h2>
</header>
<section class=entry-content>
<p>#! /bin/bash # learn about how to read from user input echo "Places input your name" read name echo "your had input name is $name" # -p 是promote ，提示的意思就是可以让用户在提示语相同 # 一行输入内容 read -p "Please input a name" user_var echo "your had input name is: $user_var" # 模拟用户输入密码操作 read -p "place input you name" users_var # -s一般在输入密码的时候启用可以输入过程看不到操作 read -sp "place input you password" pas_var echo "you had input name is $users_var" echo "you had input password is $pas_var" </p>
</section>
<footer class=entry-footer>August 17, 2019&nbsp;·&nbsp;1 min&nbsp;·&nbsp;whitek</footer>
<a class=entry-link aria-label="post link to Shell 获取用户输入" href=https://pythongo.wiki/archetypes/shell-%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Shell 2</h2>
</header>
<section class=entry-content>
<p>#! /bin/bash # input your comments here echo 'Hello world' # you also can input a comment here echo $BASH # 引用系统变量使用“$” echo $PATH echo the system variable path is $PATH name=Anthony echo my name is $name 引用系统变量使用‘$’
定义变量时等号两边不要有空格
#号是备注信息</p>
</section>
<footer class=entry-footer>August 16, 2019&nbsp;·&nbsp;1 min&nbsp;·&nbsp;whitek</footer>
<a class=entry-link aria-label="post link to Shell 2" href=https://pythongo.wiki/archetypes/shell-2/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Shell 1</h2>
</header>
<section class=entry-content>
<p>什么是shell
最早期运行在unix上的shell是Bourne shell（sh），其实shell我们都知道是一个内核，里面集成了很多命令，shell负责和底层硬件打交道。前面我们介绍的这些命令，可以说是shell命令。shell程序的入口一般是在终端输入一些相关命令，然后不需要编译，直接去解释和运行命令的结果，给出相关反馈到终端上面。所以，一句话来理解，shell是一个很多命令的集合，一个内核 什么是bash
bash 是一个为GNU计划编写的Unix shell。它的名字是一系列缩写：Bourne-Again SHell — 这是关于Bourne shell（sh）的一个双关语（Bourne again / born again）.Bash (GNU Bourne-Again Shell) 是许多Linux发行版的默认Shell。事实上，还有许多传统UNIX上用的Shell，例如tcsh、csh、ash、bsh、ksh等等，Shell Script大致都类同，当您学会一种Shell以后，其它的Shell会很快就上手，大多数的时候，一个Shell Script通常可以在很多种Shell上使用。所以，这就是我们为什么要使用bash脚本的原因。我们接下来的shell脚本都是基于bash。 什么是shell脚本
前面我们写过了一个shell脚本，shell脚本就是通过一些相关shell命令的组合来达到完成一个任务的文件，文件一般是以,sh结尾。 写一个shell脚本，在终端打印hello shell
touch hello.sh code hello.sh #! /bin/bash echo 'Hello world' 提高权限 -rwxr-xr-x chmod +x hellp.sh </p>
</section>
<footer class=entry-footer>August 15, 2019&nbsp;·&nbsp;1 min&nbsp;·&nbsp;whitek</footer>
<a class=entry-link aria-label="post link to Shell 1" href=https://pythongo.wiki/archetypes/shell-1/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>框架</h2>
</header>
<section class=entry-content>
<p>CSS常用框架
1、Scooter CSS 2、Leaf CSS 3、Fox CSS 4、Miligram CSS 5、Layers CSS 6、Baseguide CSS 7、Mimic CSS 8、Cascade CSS 9、Emastic CSS 10、Neutron CSS HTML框架
frame iframe JS框架
1.Zepto.js 2.SUI Mobile 3.Node.Js 4.angular.Js 5.JQuery Mobile 6.requirejs 7.Vue.js 8.backbone.js 9.React 10.Ionic 前端UI框架
1.Pure 2.bootstrap 3.EasyUI 4.Ant Design 可视化组件
1.Echarts 2.tableau(收费) </p>
</section>
<footer class=entry-footer>March 1, 2019&nbsp;·&nbsp;1 min&nbsp;·&nbsp;whitek</footer>
<a class=entry-link aria-label="post link to 框架" href=https://pythongo.wiki/archetypes/%E6%A1%86%E6%9E%B6/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>数据库优化</h2>
</header>
<section class=entry-content>
<p>redis 数据库优化 尽量使用短的key 不要忘了见key识意 避免使用keys * 这条命令是阻塞就是操作这条命令的时候就不能操作其他的命令 保存数据之前先压缩一次 设置key的有效期，使其自动销毁 选择回收策略，Redis的实例空间被装满之后，会尝试回收一部分数据。 尽可能的使用哈希存储 一次性添加多条数据的时候可以使用管道进行存储 Redis的系统优化 修改Linux中TCP的最大容纳的数量 修改Linux中内核的分配策略 关闭 THP （连续的物理内存巨大的页面） redis 的性能优化总结 根据业务需要选择合适的数据类型，并为不同的应用场景设置响应的紧凑的存储参数
当业务场景不需要数据持久化时， 关闭所有的持久化方式可以或得最佳的性能以及最大的内存使用量
如果需要使用持久化根据是否可以容忍重启丢失部分数据在快照方式与语句追加方式之间选择其一，不
要使用虚拟内存以及diskstore方式
不要让你的Redis所在机器物理内存使用超过实际内存总量的3/5
mysql 数据库优化 sql 语句优化
索引优化
避免查询时的全盘扫描
增加缓存
读写分离
分区
分布式数据库（垂直分割）
水平切分
MongoDB 数据库优化 mongodb可以通过profile来监控数据，进行优化。
索引优化
数据库设计优化
1、完全分离（范式化设计） 2、完全内嵌（反范式化设计） 3、部分内嵌（折中方案） </p>
</section>
<footer class=entry-footer>February 5, 2019&nbsp;·&nbsp;1 min&nbsp;·&nbsp;whitek</footer>
<a class=entry-link aria-label="post link to 数据库优化" href=https://pythongo.wiki/archetypes/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>数据库如何优化</h2>
</header>
<section class=entry-content>
<p>优化SQL语句
通过添加索引进行优化
优化Order by
有两种方式如下：
（1）索引优化：对by后的列添加索引，从而大达到优化的目的。
（2）where+order by 的组合优化：通过where进行限制后在进行order by
优化limit
优化子查询
2.优化数据库结构
1、优化insert语句
禁用索引，禁用唯一性检查，使用一条insert插入多条语句。 2、优化update语句
使用一个update语句同时做多个更新。 3、优化delete语句
删除一条记录的时间与索引的数量成正比。删除一个表的所有行，使用truncate table Tbname 而不要使用delete from table Django如何优化
1利用标准数据库优化技术：索引, Django建立实体的时候，支持给字段添加索引，具体参考Django.db.models.Field.db_index。
2了解Django的QuerySets：QuerySets是有缓存的，一旦取出来，它就会在内存里呆上一段时间，尽量重用它
3数据库的工作就交给数据库本身计算，别用Python处理：使用 filter and exclude 过滤不需要的记录，这两个是最常用语句，相当是SQL的where。使用annotate对数据库做聚合运算。不要用python语言对以上类型数据过滤筛选，同样的结果，python处理复杂度要高，而且效率不高， 白白浪费内存。使用原生的SQL语句：
4如果需要就一次性取出你所需要的数据：
单一动作（如：同一个页面）需要多次连接数据库时，最好一次性取出所有需要的数据，减少连接数据库次数。此类需求推荐使用QuerySet.select_related() 和 prefetch_related()。使用QuerySet.count()代替len(queryset),虽然这两个处理得出的结果是一样的，但前者性能优秀很多。同理判断记录存在时，QuerySet.exists()比if queryset实在强得太多了。
5 懂减少数据库的连接数：
使用 QuerySet.update() 和 delete()，这两个函数是能批处理多条记录的，适当使用它们事半功倍；如果可以，别一条条数据去update delete处理。
使用 Redis 进行缓存
使用异步 Worker 进行写库操作
高并发问题
：1，悲观锁；2，乐观锁
使用场景：
并发量高的时候使用悲观锁，
缺点：加锁消耗资源
并发量低的时候使用乐观锁，
缺点：乐观锁循环耗费时间。 秒杀问题,一件商品多人抢购如何处理
获取第一位的数据其他人均不满足
说一下事务四大特性和隔离级别
ACID
原子性（Atomicity） 要么全部完成，要么都不成功...</p>
</section>
<footer class=entry-footer>February 4, 2019&nbsp;·&nbsp;2 min&nbsp;·&nbsp;whitek</footer>
<a class=entry-link aria-label="post link to 数据库如何优化" href=https://pythongo.wiki/archetypes/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Session+cookie和使用tocken有什么区别</h2>
</header>
<section class=entry-content>
<p>cookie数据存放在客户的浏览器上，session数据放在服务器上。
cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
考虑到安全应当使用session。
考虑到减轻服务器性能方面，应当使用COOKIE。
将登陆信息等重要信息存放为SESSION
其他信息如果需要保留，可以放在COOKIE中
session 和 token并不矛盾，作为身份认证 token安全性比session好
token就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；cookie就是写在客户端的一个txt文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名；session和cookie差不多，只是session是写在服务器端的文件，也需要在客户端写入cookie文件，但是文件里是你的浏览器编号.Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。</p>
</section>
<footer class=entry-footer>February 3, 2019&nbsp;·&nbsp;1 min&nbsp;·&nbsp;whitek</footer>
<a class=entry-link aria-label="post link to Session+cookie和使用tocken有什么区别" href=https://pythongo.wiki/archetypes/session+cookie%E5%92%8C%E4%BD%BF%E7%94%A8tocken%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>线程进程协程</h2>
</header>
<section class=entry-content>
<p> 进程是系统进行资源分配和调度的一个独立单位，进程是资源分配的单位，线程是cpu调度的单位。
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,
只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
线程包含再进程中
协程，又程微线程，纤程，英文名：coroutine
而协程的操作则是程序员指定的，在python中通过yield，人为的实现并发处理。
协程存在的意义：
协程，则只使用一个线程，分解一个线程成为多个“微线程”，在一个线程中规定某个代码块的执行顺序。
协程的应用场景：当程序中存在大量不需要CPU的操作时（IO）。
首先我们得知道协程是啥？协程其实比线程更小的执行单元。 为啥说他是一个执行单元，因为他自带CPU上下文。
协程和线程差异：
线程切换非常耗性能
但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。
协程的问题-协程程序员自己调度
让需要执行的协程更多的获得CPU时间才是问题的关键。
计算密集型和IO密集型 计算密集型–>例如for循环里嵌套10层for循环–>占大量的cpu资源–>解决方案–>使用多进程不能用多线程（多线程中有个全局锁GIL）
IO密集型->需要网络功能，大量的事件等待网络数据的到来–>多线程、协成
尽量不要再协程里面做IO密集型操作
</p>
</section>
<footer class=entry-footer>February 2, 2019&nbsp;·&nbsp;1 min&nbsp;·&nbsp;whitek</footer>
<a class=entry-link aria-label="post link to 线程进程协程" href=https://pythongo.wiki/archetypes/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>广度优先遍历二叉树</h2>
</header>
<section class=entry-content>
<p>import queue class TreeNode: def init(self,val=None,left=None,right=None): self.val = val self.left = left self.right = right def settag(self,tag=None): self.tag = tag def visit(treenode): print(str(treenode.val),end=' ') def levelOrder(root): deque = queue.Queue() if(root is not None): deque.put(root) while(not deque.empty()): treenode = deque.get() visit(treenode) if(treenode.left is not None): deque.put(treenode.left) if(treenode.right is not None): deque.put(treenode.right) # 说一下他们的时间复杂度和空间复杂度 #　一般来说，时间复杂度高的算法比复杂度低的算法慢 ＃　时间复杂度的最优,最差,和平均值 ｀｀｀</p>
</section>
<footer class=entry-footer>February 1, 2019&nbsp;·&nbsp;1 min&nbsp;·&nbsp;whitek</footer>
<a class=entry-link aria-label="post link to 广度优先遍历二叉树" href=https://pythongo.wiki/archetypes/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/></a>
</article>
<footer class=page-footer>
<nav class=pagination>
<a class=prev href=https://pythongo.wiki/archetypes/page/4/>« Prev Page</a>
<a class=next href=https://pythongo.wiki/archetypes/page/6/>Next Page »</a>
</nav>
</footer>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://pythongo.wiki/>whiteKBlog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>