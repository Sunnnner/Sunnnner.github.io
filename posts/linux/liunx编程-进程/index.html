<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content="学无止境,hugo,python,go,java,linux,mysql,redis,nginx,git,github,linux,mysql,redis,nginx,git,github,微服务,个人博客"
  />
  
    
      <title>Liunx编程-python进程 | 学无止境</title>
    
  
  <link rel="stylesheet" href="/css/reset.css"/>
  <link rel="stylesheet" href="/css/font.css"/>
  <link rel="stylesheet" href="/css/smigle.css"/>
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
</head>

  <body>
    <div id="root">
      <header>
  <div id="brand">
    <a class="icon-link" href="https://sunnnner.github.io/">
      <img
        class="icon"
        src="/images/brandIcon.svg"
      />
    </a>
    <div class="text">
      <a href="https://sunnnner.github.io/"><h1>学无止境</h1></a>
      <h3>少年辛苦终身事,莫向光阴惰寸功。——唐·杜荀鹤《题弟侄书堂》</h3>
    </div>
  </div>
  <nav>
    
      
        
        <a href="/posts/"><b>主页</b></a>
      
         | 
        <a href="/categories/"><b>类别</b></a>
      
         | 
        <a href="/tags/"><b>标签</b></a>
      
         | 
        <a href="https://freegpt.rustcc.com.cn"><b>GPT-1</b></a>
      
         | 
        <a href="https://vip.rustcc.com.cn"><b>GPT-2</b></a>
      
         | 
        <a href="https://ai.rustcc.com.cn"><b>GPT-3</b></a>
      
    
  </nav>
  <hr />
</header>

      <div id="content">
        
  <main>
    <article>
      <h1 class="title">Liunx编程-python进程</h1>
      
      <div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>12.07.2022</time>
    <span>in</span>
    
      <a href="/categories/python">python</a>
  </strong>
  <span> • 181 words</span>
  <span> • 1 minute read</span>
  
  
    <div>
      <span>Tags:</span>
      
        <a href="/tags/%E8%BF%9B%E7%A8%8B">进程</a>
    </div>
  
</div>

      <div class="content"><h1 id="什么是多任务">什么是多任务</h1>
<hr>
<ul>
<li>
<h3 id="程序中的多任务">程序中的多任务</h3>
</li>
<li>如果有多件事情是同时进行，我们把这种情况叫做多任务。Linux 是真正的多任务、多用户操作系统，windows是多任务操作系统，但不是真正意义上的多用户操作系统。</li>
</ul>
<hr>
<ul>
<li>
<h1 id="并发和并行">并发和并行</h1>
</li>
</ul>
<hr>
<ul>
<li>
<h3 id="时间片轮转">时间片轮转</h3>
</li>
<li>时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称RR调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间优先数调度算法常用于批处理系统中。在进程调度中，每次调度时，系统把处理机分配给就绪队列中优先数最高的进程。它又分为两种：==非抢占式优先数算法和抢占式优先数算法。==</li>
<li>==非抢占式优先权算法==：系统一旦把处理机分配给就绪队列中优先权最高的进程后,该进程便一直执行下去,直至完成</li>
<li>==抢占式优先权调度算法==：系统同样把处理机分配给优先权最高的进程,使之执行.但在其执行期间,只要又出现了另一个其优先权更高的进程,进程调度程序就立即停止当前进程(原优先权最高的进程)的执行,重新将处理机分配给新到的优先权最高的进程</li>
<li>==系统的进程会比开发者开发的优先调度==</li>
<li>
<h3 id="并发和并行-1">并发和并行</h3>
</li>
<li><strong>并发</strong>：在多核系统里的,同时执行多个进程，<strong>一般会情况下会有些进程没有机会执行，这种情况是并发。</strong></li>
<li>Concurrent（并发）</li>
<li>Parallel（并行）</li>
<li>
<h3 id="多任务在程序中的实现--进程和线程">多任务在程序中的实现&ndash;进程和线程</h3>
</li>
<li>多任务系统中有3个功能单位：任务、进程和线程</li>
</ul>
<hr>
<ul>
<li>
<h1 id="osfork函数创建进程">os.fork函数创建进程</h1>
</li>
</ul>
<hr>
<ul>
<li>
<h3 id="程序和进程区别">程序和进程区别</h3>
</li>
<li>
<p>程序：编写完毕的代码，在没有运行的时候，称之为程序（代码）</p>
</li>
<li>
<p>进程：正在运行着的代码，就成为进程，进程占用了内存和cpu等资源。</p>
</li>
<li>
<p>进程，除了包含代码以外，还有需要运行的环境等，所以和程序(代码)是有区别的.</p>
</li>
<li>
<h3 id="fork-">fork( )</h3>
</li>
<li>
<h1 id="注意fork函数只在unixlinuxmac上运windows不可以">注意，fork函数，只在Unix/Linux/Mac上运⾏，windows不可以</h1>
</li>
<li></li>
<li>
<h4 id="fork函数的使用">fork函数的使用</h4>
</li>
<li></li>
<li>
<p>PID(进程控制符)</p>
</li>
<li>
<p>PID是各进程的身份标识，程序一运行系统就会自动分配给</p>
</li>
<li>
<p>返回三个值0，大于0的值，-1</p>
</li>
<li>
<p>#如果返回0，当前是子进程</p>
</li>
<li>
<p>#如果返回大于0，当前是父进程</p>
</li>
<li></li>
<li>
<h4 id="fork函数原理">fork函数原理</h4>
</li>
<li>
<p>fork下的函数体父子各一份</p>
</li>
<li>
<p>普通的函数调⽤，调⽤⼀次，返回⼀次，但是fork()调⽤⼀次，返回两次，因 为操作系统⾃动把当前进程（称为⽗进程）复制了⼀份（称为⼦进程），然 后，分别在⽗进程和⼦进程内返回。
⼦进程永远返回0，⽽⽗进程返回⼦进程的ID。</p>
</li>
<li>
<p>这样做的理由是，⼀个⽗进程可以fork出很多⼦进程，所以，⽗进程要记下 每个⼦进程的ID，⽽⼦进程只需要调⽤getppid()就可以拿到⽗进程的ID。</p>
</li>
</ul>
<hr>
<h1 id="getpidgetppid">getpid()、getppid()</h1>
<hr>
<p>-get pid()当前进程的Pid
os.getppid（）当前父进程的pid</p>
<ul>
<li>子进程永远返回0，而父进程返回子进程的ID，这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID，getpid()得到当前进程的ID。</li>
<li></li>
</ul>
<hr>
<h1 id="小结">小结</h1>
<hr>
<hr>
<h1 id="进程与进程之间数据不共享">进程与进程之间数据不共享</h1>
<hr>
<ul>
<li>进程间数据不同享</li>
<li>fork时子进程获得父进程代码和数据段、共享库、堆和栈的复制，所以变量的地址也是一样的</li>
<li>多进程中，每个进程中所有数据（包括全局变量）都各有拥有一份，互不影响。
<strong>fork时子进程获得父进程代码和数据段、共享库、堆和栈的拷贝，所以变量的地址也是一样的，并且在某一个进程中修改相同变量的值，在另外一个进程中的相同变量的值不会修改。</strong></li>
</ul>
<hr>
<ul>
<li>
<h1 id="多次fork问题">多次fork问题</h1>
</li>
<li>
<h3 id="父子和子进程的执行顺序">父子和子进程的执行顺序</h3>
</li>
<li>父进程、子进程执行顺序没有规律，完全取决于操作系统的调度算法</li>
<li>注意在pycharm上要使用sleep休眠一会，等待子进程执行在推出，次退出主进程，否则子进程没有机会执行</li>
<li>
<h3 id="扩展-for炸弹">扩展-for炸弹</h3>
</li>
<li></li>
</ul>
<hr>
<h1 id="创建跨平台的进程--multiprocessing">创建跨平台的进程&ndash;==multiprocessing==</h1>
<hr>
<ul>
<li>
<p>Windows无法使用fork调用创建进程，那在windows中怎么创建进程呢？由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持，multiprocessing模块就是跨平台版本的多进程模块，使用改模块的Process类可以创建进程</p>
</li>
<li>
<h3 id="使用process创建进程">使用Process创建进程</h3>
</li>
<li>
<p>如果时全局变量子进程与主进程互不干扰</p>
</li>
<li>
<h3 id="heading"></h3>
</li>
<li>
<h3 id="heading-1"></h3>
</li>
<li>
<h3 id="join等待子进程结束">join等待子进程结束</h3>
</li>
<li>
<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例对象，用start()方法启动，这样创建进程比fork()还要简单。</p>
</li>
<li>
<p>join  让你的主进程让步</p>
</li>
<li>
<pre><code>  p.join()
</code></pre>
</li>
<li>
<p>join()没加参数是指子进程执行完毕之后，主进程才可以加入
join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>
</li>
<li>
<p>子进程只要是完成了“目标”，就自杀</p>
</li>
<li>
<p>如果进程没有完成任务，可用他杀调用p.terminate()</p>
</li>
<li>
<h3 id="process语法结构">Process语法结构</h3>
</li>
<li>
<p>Process([group [, target [, name [, args [, kwargs]]]]])</p>
</li>
<li>
<p>target：表示这个进程实例所调用对象；</p>
</li>
<li>
<p>args：表示调用对象的位置参数元组；</p>
</li>
<li>
<p>kwargs：表示调用对象的关键字参数字典；</p>
</li>
<li>
<p>name：为当前进程实例的别名；</p>
</li>
<li>
<p>group：大多数情况下用不到；</p>
</li>
<li>
<p>p.terminate()不管任务是否完成，立即终止</p>
</li>
<li>
<p>is_alive()判断进程是否存活</p>
</li>
<li>
<p>join([timeout])：是否等待进程实例执行结束，或等待多少秒；</p>
</li>
<li>
<p>start()：启动进程实例（创建子进程）；</p>
</li>
<li>
<p>run()：如果没有给定target参数，对这个对象调用-</p>
</li>
<li>
<p>start()方法时，就将执行对象中的run()方法；</p>
</li>
<li>
<p>terminate()：不管任务是否完成，立即终止；</p>
</li>
<li>
<p>Process类常用属性：</p>
</li>
<li>
<p>name：当前进程实例别名，默认为Process-N，N为从1开始递增的整数；</p>
</li>
<li>
<p>pid：当前进程实例的PID值；</p>
</li>
<li></li>
</ul>
<hr>
<h1 id="进程的创建--自定义process子类">进程的创建&ndash;自定义Process子类</h1>
<hr>
<ul>
<li>
<h3 id="自定义process子类">自定义Process子类</h3>
</li>
<li>只要启动start自动调用类里的run方法</li>
<li>run不能手动调用</li>
<li>==只要时创建进程子类，必须重写run方法==</li>
<li>如果自己定义了__ init__就必须调用父类的super().__ init__()</li>
</ul>
<hr>
<ul>
<li>
<h1 id="进程池pool">进程池(Pool)</h1>
</li>
</ul>
<hr>
<ul>
<li>ultiprocessing模块提供的Pool方法。</li>
<li>阻塞式：添加一个执行一个，执行完毕，才并且返回，然后接着添加下一个</li>
<li>非阻塞式：全部添加到队列，立刻返回，并没有等他执行完毕，当执行完毕后有回掉，回掉种发携带结果</li>
<li>
<pre><code>from multiprocessing import Pool
</code></pre>
</li>
<li>
<h3 id="apply_async非阻塞式">apply_async非阻塞式</h3>
</li>
<li>apply_async(func[, args[, kwds]])</li>
<li>用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表；</li>
<li>pool.apply_async(func,args=(tuple),callback=)</li>
<li>如果你的回掉函数有参数，是通过当前任务的返回值</li>
<li>callback=回掉函数</li>
<li>pool.close()#不再添加其他的进程</li>
<li>进程池：最大是Tool(n)n</li>
<li>n个只要有一个结束了，进程池立马会将释放的进程分配，依此类推</li>
<li>只要一个进程结束，扔出一个回掉函数，父进程立刻调用callback得到一个返回值</li>
<li>
<h3 id="apply堵塞式">apply堵塞式</h3>
</li>
<li>阻塞式没有回掉函数</li>
<li>apply(func[, args[, kwds]])：使用阻塞方式调用func</li>
<li>
<h3 id="multiprocessingpool常用函数解析">multiprocessing.Pool常用函数解析</h3>
</li>
<li>apply_async(func[, args[, kwds]]) ：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表；</li>
<li>apply(func[, args[, kwds]])：使用阻塞方式调用func</li>
<li>close()：关闭Pool，使其不再接受新的任务；</li>
<li>terminate()：不管任务是否完成，立即终止，针对的是非阻塞式。</li>
<li>join()：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用；</li>
<li>
<h3 id="阻塞和非阻塞的区别">阻塞和非阻塞的区别</h3>
</li>
<li>应用进程请求i/o操作（recv）时，如果数据未准备好请求是否立即返回</li>
<li>不立即返回：阻塞式</li>
<li>立即返回：非阻塞式</li>
<li>阻塞式：任务一起交给pool则pool立刻打印全部</li>
<li>非阻塞式：排队进入每次只能执行一个</li>
</ul>
<hr>
<ul>
<li>
<h1 id="使用queue实现进程间通信">使用Queue实现进程间通信</h1>
</li>
</ul>
<hr>
<ul>
<li>
<p>Python中主要使用Queue（队列）、Manage支持管道通信、套接字( socket )等等实现进程间通信。</p>
</li>
<li>
<h3 id="queue的使用">Queue的使用</h3>
</li>
<li>
<p>Python中在multiprocessing模块的Queue类可以实现进程之间的数据传递，Queue本身是一个消息列队程序</p>
</li>
<li>
<p>from multtiprocessing import Quese</p>
</li>
<li>
<p>Queue.empty()在不同平台有差异</p>
</li>
<li>
<h4 id="queue的参数说明">Queue的参数说明</h4>
</li>
<li>
<p>初始化Queue()对象时（例如：q=Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的耗尽）；</p>
</li>
<li>
<p><strong>Queue.qsize()</strong>：返回当前队列包含的消息数量</p>
</li>
<li>
<p>Queue.empty()：如果队列为空，返回True，反之False</p>
</li>
<li>
<p>Queue.full()：如果队列满了，返回True,反之False；</p>
</li>
<li>
<p>.Queue.get([block[, timeout]])：获取队列中的一条消息，然后将其从列队中移除，block默认值为True；如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出&quot;Queue.Empty&quot;异常；
2）如果block值为False，消息列队如果为空，则会立刻抛出&quot;Queue.Empty&quot;异常</p>
</li>
<li>
<p>Queue.get_nowait()：相当Queue.get(False)；</p>
</li>
<li>
<p>.Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True；(阻塞式)如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出&quot;Queue.Full&quot;异常；
2）如果block值为False，消息列队如果没有空间可写入，则会立刻抛出&quot;Queue.Full&quot;异常；</p>
</li>
<li>
<p>Queue.put_nowait(item)：相当Queue.put(item, False)；</p>
</li>
<li>
<h3 id="进程池中的使用manager中的queue">进程池中的使用Manager()中的Queue</h3>
</li>
<li>
<p>from multiprocessing import Manager</p>
</li>
<li>
<p>没有长度限制</p>
</li>
<li>
<p>如果使用的式进程池，则队列 queue=Menage().Queue()</p>
</li>
<li>
<p>不能使用queue.Queue（）</p>
</li>
<li>
<h3 id="打印进度">打印进度</h3>
</li>
<li>
<p>\r 换行，光标再上一行</p>
</li>
<li>
<p>%&rsquo;%%&lsquo;输出一个单一的%</p>
</li>
</ul></div>
    </article>
  </main>

      </div>
      <footer>
  <hr />
  
  <p class="copyright">
    Copyright © 2024
    <a href="https://sunnnner.github.io/"><strong>Blog Author</strong></a>.
    This work is licensed under the
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> license.
  </p>
  <p class="builtWith">
    Built with
    <a href="http://www.gohugo.io/">Hugo</a>,
    using the theme
    <a href="https://gitlab.com/ian-s-mcb/smigle-hugo-theme">smigle</a>,
    which was influenced by the theme
    <a href="https://github.com/sumnerevans/smol">smol</a>.
  </p>
</footer>

    </div>
  </body>
</html>
