<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on whiteKBlog</title>
    <link>https://sunnnner.github.io/tags/python/</link>
    <description>Recent content in python on whiteKBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 08 Jul 2022 09:32:29 +0800</lastBuildDate><atom:link href="https://sunnnner.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python线程安全</title>
      <link>https://sunnnner.github.io/python%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</link>
      <pubDate>Fri, 08 Jul 2022 09:32:29 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/python%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</guid>
      <description> 线程不安全的主要原因是我们的代码不是原子操作导致的 原子操作(atomic operation),指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会切换，它类似与数据库的事务操作。 为确保线程安全，我们需要人工实现原子操作，因为我们不能保证我们在多线程的情况下代码都具有原子性 因此我们需要使用线程锁来使代码具有原子性 代码实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from threading import Thread, Lock number = 0 lock = Lock() def target(): global number for _ in range(1000000): with lock: number += 1 # 开启两个线程 threads = [Thread(target=target) for _ in range(2)] for t in threads: t.start() for t in threads: t.join() print(number) 现在，不论你执行多少次，输出都是2000000 </description>
    </item>
    
    <item>
      <title>Python虚拟环境pipenv使用</title>
      <link>https://sunnnner.github.io/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83pipenv%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 07 Jul 2022 10:08:33 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83pipenv%E4%BD%BF%E7%94%A8/</guid>
      <description>pipenv 是一个包的版本控制软件，与我之前用过的rust语言中的cargo类似，与go的包管理器也类似，它能够锁定当前包的依赖项
Ubuntu中可以使用sudo apt install pipenv
也可以使用当前python环境中的pip进行安装pip install pipenv
pipenv 命令
指定python版本 pipenv --python 3.8.12
使用当前requements文件生成Pipfile文件pipenv install
锁定当前Pipfile文件pipenv lock
详细信息请参阅https://pipenv.pypa.io/en/latest/</description>
    </item>
    
    <item>
      <title>使用itertools处理python嵌套列表问题</title>
      <link>https://sunnnner.github.io/%E4%BD%BF%E7%94%A8itertools%E5%A4%84%E7%90%86python%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 13 May 2022 13:39:13 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/%E4%BD%BF%E7%94%A8itertools%E5%A4%84%E7%90%86python%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E9%97%AE%E9%A2%98/</guid>
      <description> 使用itertools处理python嵌套列表问题
当我们想要把一串字符分割成列表的时候
1 2 3 4 5 6 7 8 9 import itertools a = &amp;#34;1111&amp;#34; &amp;gt;&amp;gt;&amp;gt;print(list(itertools.chain(a))) output: [&amp;#39;1&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;1&amp;#39;] 嵌套列表组合成一个列表 1 2 3 4 5 6 7 8 import itertools &amp;gt;&amp;gt;&amp;gt; a = [1, [2], [3], 4, 5] &amp;gt;&amp;gt;&amp;gt; print(itertools.chain.from_iterable(a)) output: [1, 2, 3, 4, 5] </description>
    </item>
    
    <item>
      <title>Python日期转换</title>
      <link>https://sunnnner.github.io/python%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Tue, 10 Dec 2019 15:43:08 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/python%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2/</guid>
      <description>秒数是相对于1970.1.1号的秒数 日期的模块有time、datetime 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import datetime t = datetime.datetime(2009, 10, 21, 0, 0, 10, 10) # 分别是年份、月份、日、小时、分钟、秒、微妙(10-6秒) print (t-datetime.datetime(1970,1,1)).total_seconds() # 总共多少秒 import datetime, time t = datetime.datetime(2011, 10, 21, 0, 0) time.mktime(t.timetuple()) 1319148000.0 string转datetime str = &amp;#39;2012-11-19&amp;#39; date_time = datetime.datetime.strptime(str,&amp;#39;%Y-%m-%d&amp;#39;) datetime.datetime(2012,11,19,0,0) datetime转string date_time.strftime(&amp;#39;%Y-%m-%d&amp;#39;) &amp;#39;2012-11-19&amp;#39; datetime转时间戳 time_time = time.mktime(date_time.timetuple())
时间戳转string time.strftime(&#39;%Y-%m-%d&#39;,time.localtime(time_time)) &amp;lsquo;2012-11-19&amp;rsquo; date转datetime 1 2 3 4 5 6 7 8 9 date = datetime.</description>
    </item>
    
    <item>
      <title>Python日期转换</title>
      <link>https://sunnnner.github.io/p/python%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Tue, 10 Dec 2019 15:43:08 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2/</guid>
      <description>秒数是相对于1970.1.1号的秒数 日期的模块有time、datetime 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import datetime t = datetime.datetime(2009, 10, 21, 0, 0, 10, 10) # 分别是年份、月份、日、小时、分钟、秒、微妙(10-6秒) print (t-datetime.datetime(1970,1,1)).total_seconds() # 总共多少秒 import datetime, time t = datetime.datetime(2011, 10, 21, 0, 0) time.mktime(t.timetuple()) 1319148000.0 string转datetime str = &amp;#39;2012-11-19&amp;#39; date_time = datetime.datetime.strptime(str,&amp;#39;%Y-%m-%d&amp;#39;) datetime.datetime(2012,11,19,0,0) datetime转string date_time.strftime(&amp;#39;%Y-%m-%d&amp;#39;) &amp;#39;2012-11-19&amp;#39; datetime转时间戳 time_time = time.mktime(date_time.timetuple())
时间戳转string time.strftime(&#39;%Y-%m-%d&#39;,time.localtime(time_time)) &amp;lsquo;2012-11-19&amp;rsquo; date转datetime 1 2 3 4 5 6 7 8 9 date = datetime.</description>
    </item>
    
    <item>
      <title>Log BasicConfig函数</title>
      <link>https://sunnnner.github.io/log-basicconfig%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 05 Dec 2019 15:40:17 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/log-basicconfig%E5%87%BD%E6%95%B0/</guid>
      <description>logging.basicConfig函数 logging模块是Python内置标准模块，主要用于输出运行日志，可以设置输出日志的等级、日志保存路径，日志文件回滚等 ##相比Print优点：
可以通过设置不同的日志等级，在release版本中只输出重要信息，而不必显示大量的调试信息； print将所有信息都输出到标准输出中，严重影响开发者从标准输出中查看其它数据；logging则可以由开发者决定将信息输出到什么地方，以及怎么输出； 在python中，logging由logger，handler，filter，formater四个部分组成： logger是提供我们记录日志的方法；handler是让我们选择日志的输出地方，如：控制台，文件，邮件发送等，一个logger添加多个handler；filter是给用户提供更加细粒度的控制日志的输出内容；formater用户格式化输出日志的信息。 python中配置logging有三种方式 第一种：基础配置， 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 logging.basicConfig( filename=&amp;#34;config.log&amp;#34;, filemode=&amp;#34;w&amp;#34;, format=&amp;#34;%(asctime)s-%(name)s-%(levelname)s-%(message)s&amp;#34;, level=logging.INFO) 第二种：使用配置文件的方式配置logging,使用`fileConfig函数来读取配置文件 fileConfig( filename, defaults=None, disable_existing_loggers=Ture )` 第三种：使用一个字典方式来写配置信息，然后使用dictConfig dictConfig( dict, defaults=None, disable_existing_loggers=Ture ) 日志Level等级 日志一共分成5个等级，从低到高分别是：DEBUG ,INFO ,WARNING ,ERROR, CRITICAL。 DEBUG：详细的信息,通常只出现在诊断问题上 INFO：确认一切按预期运行 WARNING：一个迹象表明,一些意想不到的事情发生了,或表明一些问题在不久的将来(例如。磁盘空间低”)。这个软件还能按预期工作。 ERROR：更严重的问题,软件没能执行一些功能 CRITICAL：一个严重的错误,这表明程序本身可能无法继续运行 这5个等级，也分别对应5种打日志的方法： debug 、info 、warning 、error、critical。默认的是WARNING，当在WARNING或之上时才被跟踪。 二、日志输出：可以输出在控制台和文件，我选择的是输出在文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 StreamHandler：logging.</description>
    </item>
    
    <item>
      <title>Log BasicConfig函数</title>
      <link>https://sunnnner.github.io/p/log-basicconfig%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 05 Dec 2019 15:40:17 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/log-basicconfig%E5%87%BD%E6%95%B0/</guid>
      <description>logging.basicConfig函数 logging模块是Python内置标准模块，主要用于输出运行日志，可以设置输出日志的等级、日志保存路径，日志文件回滚等 ##相比Print优点：
可以通过设置不同的日志等级，在release版本中只输出重要信息，而不必显示大量的调试信息； print将所有信息都输出到标准输出中，严重影响开发者从标准输出中查看其它数据；logging则可以由开发者决定将信息输出到什么地方，以及怎么输出； 在python中，logging由logger，handler，filter，formater四个部分组成： logger是提供我们记录日志的方法；handler是让我们选择日志的输出地方，如：控制台，文件，邮件发送等，一个logger添加多个handler；filter是给用户提供更加细粒度的控制日志的输出内容；formater用户格式化输出日志的信息。 python中配置logging有三种方式 第一种：基础配置， 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 logging.basicConfig( filename=&amp;#34;config.log&amp;#34;, filemode=&amp;#34;w&amp;#34;, format=&amp;#34;%(asctime)s-%(name)s-%(levelname)s-%(message)s&amp;#34;, level=logging.INFO) 第二种：使用配置文件的方式配置logging,使用`fileConfig函数来读取配置文件 fileConfig( filename, defaults=None, disable_existing_loggers=Ture )` 第三种：使用一个字典方式来写配置信息，然后使用dictConfig dictConfig( dict, defaults=None, disable_existing_loggers=Ture ) 日志Level等级 日志一共分成5个等级，从低到高分别是：DEBUG ,INFO ,WARNING ,ERROR, CRITICAL。 DEBUG：详细的信息,通常只出现在诊断问题上 INFO：确认一切按预期运行 WARNING：一个迹象表明,一些意想不到的事情发生了,或表明一些问题在不久的将来(例如。磁盘空间低”)。这个软件还能按预期工作。 ERROR：更严重的问题,软件没能执行一些功能 CRITICAL：一个严重的错误,这表明程序本身可能无法继续运行 这5个等级，也分别对应5种打日志的方法： debug 、info 、warning 、error、critical。默认的是WARNING，当在WARNING或之上时才被跟踪。 二、日志输出：可以输出在控制台和文件，我选择的是输出在文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 StreamHandler：logging.</description>
    </item>
    
    <item>
      <title>Divmod函数</title>
      <link>https://sunnnner.github.io/divmod%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 01 Dec 2019 15:39:29 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/divmod%E5%87%BD%E6%95%B0/</guid>
      <description> python divmod()把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。 1 2 3 4 &amp;gt;&amp;gt;&amp;gt; divmod(3600, 60) (60, 0) &amp;gt;&amp;gt;&amp;gt; divmod(3500, 60) (58, 20) </description>
    </item>
    
    <item>
      <title>Divmod函数</title>
      <link>https://sunnnner.github.io/p/divmod%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 01 Dec 2019 15:39:29 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/divmod%E5%87%BD%E6%95%B0/</guid>
      <description> python divmod()把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。 1 2 3 4 &amp;gt;&amp;gt;&amp;gt; divmod(3600, 60) (60, 0) &amp;gt;&amp;gt;&amp;gt; divmod(3500, 60) (58, 20) </description>
    </item>
    
    <item>
      <title>Python Collections Duque函数演示</title>
      <link>https://sunnnner.github.io/python-collections-duque%E5%87%BD%E6%95%B0%E6%BC%94%E7%A4%BA/</link>
      <pubDate>Tue, 15 Oct 2019 15:33:37 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/python-collections-duque%E5%87%BD%E6%95%B0%E6%BC%94%E7%A4%BA/</guid>
      <description> duque函数有一个maxlen参数，当append的时候，如果超过，那么最前面的就会被挤出队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from collections import duque def search(lines, pattern, lens=5): previous_lines = deque(maxlen=lens) for li in lines: if pattern in li: yield li, previous_lines previous_lines.append(li) if name == ‘main‘: with open(r’./xx.txt’) as f: for line, prevlines in search(f, ‘python’, 5): for pline in prevlines: print(pline, end=’’) print(line, end=’’) print(‘**’ * 20) </description>
    </item>
    
    <item>
      <title>Python Collections Duque函数演示</title>
      <link>https://sunnnner.github.io/p/python-collections-duque%E5%87%BD%E6%95%B0%E6%BC%94%E7%A4%BA/</link>
      <pubDate>Tue, 15 Oct 2019 15:33:37 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python-collections-duque%E5%87%BD%E6%95%B0%E6%BC%94%E7%A4%BA/</guid>
      <description> duque函数有一个maxlen参数，当append的时候，如果超过，那么最前面的就会被挤出队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from collections import duque def search(lines, pattern, lens=5): previous_lines = deque(maxlen=lens) for li in lines: if pattern in li: yield li, previous_lines previous_lines.append(li) if name == ‘main‘: with open(r’./xx.txt’) as f: for line, prevlines in search(f, ‘python’, 5): for pline in prevlines: print(pline, end=’’) print(line, end=’’) print(‘**’ * 20) </description>
    </item>
    
    <item>
      <title>Getattr函数</title>
      <link>https://sunnnner.github.io/getattr%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 14 Oct 2019 15:31:31 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/getattr%E5%87%BD%E6%95%B0/</guid>
      <description>##描述
getattr() 函数用于返回一个对象属性值。
语法 getattr 语法：
getattr(object, name, [default])
参数 object – 对象。 name – 字符串，对象属性。 default – 默认返回值，如果不提供该参数，在没有对应属性时，将触发 AttributeError。
返回值 返回对象属性值。 </description>
    </item>
    
    <item>
      <title>Getattr函数</title>
      <link>https://sunnnner.github.io/p/getattr%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 14 Oct 2019 15:31:31 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/getattr%E5%87%BD%E6%95%B0/</guid>
      <description>##描述
getattr() 函数用于返回一个对象属性值。
语法 getattr 语法：
getattr(object, name, [default])
参数 object – 对象。 name – 字符串，对象属性。 default – 默认返回值，如果不提供该参数，在没有对应属性时，将触发 AttributeError。
返回值 返回对象属性值。 </description>
    </item>
    
    <item>
      <title>Hasattr函数</title>
      <link>https://sunnnner.github.io/hasattr%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 13 Oct 2019 15:30:12 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/hasattr%E5%87%BD%E6%95%B0/</guid>
      <description>描述 hasattr() 函数用于判断对象是否包含对应的属性。
语法 hasattr 语法：
hasattr(object, name)
参数 object – 对象。
name – 字符串，属性名。
返回值 如果对象有该属性返回 True，否则返回 False。 </description>
    </item>
    
    <item>
      <title>Hasattr函数</title>
      <link>https://sunnnner.github.io/p/hasattr%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 13 Oct 2019 15:30:12 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/hasattr%E5%87%BD%E6%95%B0/</guid>
      <description>描述 hasattr() 函数用于判断对象是否包含对应的属性。
语法 hasattr 语法：
hasattr(object, name)
参数 object – 对象。
name – 字符串，属性名。
返回值 如果对象有该属性返回 True，否则返回 False。 </description>
    </item>
    
    <item>
      <title>Os模块</title>
      <link>https://sunnnner.github.io/os%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Thu, 10 Oct 2019 14:20:46 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/os%E6%A8%A1%E5%9D%97/</guid>
      <description>os .path.dirname(path) 获取路径名
os.path.basename(path) 获取文件名
os.path.join(path1[,path2[,….]]) 将路径与文件名拼接成一个完整的路径
os.path.split(path) 分割路径与文件名，返回元组(f_path, f_name), 如果完全使用目录，它也会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在
os.path.splitext(path) 分割文件名与扩展名
os.path.getsize(file) 或得文件大小，单位是字节
os.path.gettatime(file) 或得文件最近的访问时间，返回的是浮点型秒数
os.path.getctime(file) 或得文件的创建时间，返回的是浮点型秒数
os.path.getmtime(file) 或得文件的修费时间，返回的是浮点型秒数
os.path.exists(path) 判断路径是否存在
os.path.isabs(path) 判断是否为绝对路径
os.path.isdir(path) 判断是否存在且是一个目录
os.path.isfile(path)
os.path.islink(path) 判断是否存在且是一个符号链接
os.path.ismount(path) 判断是否存在且是一个挂载点
os.path.samefile(path1, path2) 判断两个路径是否指向同一个文件</description>
    </item>
    
    <item>
      <title>Os模块</title>
      <link>https://sunnnner.github.io/p/os%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Thu, 10 Oct 2019 14:20:46 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/os%E6%A8%A1%E5%9D%97/</guid>
      <description>os .path.dirname(path) 获取路径名
os.path.basename(path) 获取文件名
os.path.join(path1[,path2[,….]]) 将路径与文件名拼接成一个完整的路径
os.path.split(path) 分割路径与文件名，返回元组(f_path, f_name), 如果完全使用目录，它也会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在
os.path.splitext(path) 分割文件名与扩展名
os.path.getsize(file) 或得文件大小，单位是字节
os.path.gettatime(file) 或得文件最近的访问时间，返回的是浮点型秒数
os.path.getctime(file) 或得文件的创建时间，返回的是浮点型秒数
os.path.getmtime(file) 或得文件的修费时间，返回的是浮点型秒数
os.path.exists(path) 判断路径是否存在
os.path.isabs(path) 判断是否为绝对路径
os.path.isdir(path) 判断是否存在且是一个目录
os.path.isfile(path)
os.path.islink(path) 判断是否存在且是一个符号链接
os.path.ismount(path) 判断是否存在且是一个挂载点
os.path.samefile(path1, path2) 判断两个路径是否指向同一个文件</description>
    </item>
    
    <item>
      <title>Python实现AES加密</title>
      <link>https://sunnnner.github.io/python%E5%AE%9E%E7%8E%B0aes%E5%8A%A0%E5%AF%86/</link>
      <pubDate>Sat, 05 Oct 2019 14:14:41 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/python%E5%AE%9E%E7%8E%B0aes%E5%8A%A0%E5%AF%86/</guid>
      <description>环境 python3.6 三方库—pyCryptodome 介绍 之前的AES加密中，Py2或者3.4都是采用的pyCrypto这个模块但是它已经停止维护，现在多了一个分支pyCryptodome这个模块 如果有别的模块不能安装可以去这个网站下载安装点我
进去之后都会有安装教程
编写代码支付宝接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 # -*- coding: utf-8 -*- # pip install pycryptodome(这个一定要有) #pip install winrandom from datetime import datetime from Crypto.</description>
    </item>
    
    <item>
      <title>Python实现AES加密</title>
      <link>https://sunnnner.github.io/p/python%E5%AE%9E%E7%8E%B0aes%E5%8A%A0%E5%AF%86/</link>
      <pubDate>Sat, 05 Oct 2019 14:14:41 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E5%AE%9E%E7%8E%B0aes%E5%8A%A0%E5%AF%86/</guid>
      <description>环境 python3.6 三方库—pyCryptodome 介绍 之前的AES加密中，Py2或者3.4都是采用的pyCrypto这个模块但是它已经停止维护，现在多了一个分支pyCryptodome这个模块 如果有别的模块不能安装可以去这个网站下载安装点我
进去之后都会有安装教程
编写代码支付宝接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 # -*- coding: utf-8 -*- # pip install pycryptodome(这个一定要有) #pip install winrandom from datetime import datetime from Crypto.</description>
    </item>
    
    <item>
      <title>动态网页爬取</title>
      <link>https://sunnnner.github.io/%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%88%AC%E5%8F%96/</link>
      <pubDate>Wed, 11 Sep 2019 11:42:10 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%88%AC%E5%8F%96/</guid>
      <description>我们使用自动化测试工具selenium pip install selenium
PhantomJS 基于webkit的无界面浏览器
ubuntu使用apt-get install phantomjs MAC使用bew cask install phantomjs
Chromedriver
与selenium配合因为phantomjs已经不支持selenium 如果使用Chrome进行测试，需要使用xvfb， Xvirtual framebuffer (xvfb)虚拟帧缓冲器， 简单来说它可以直接处理window的图形化功能，并且不会输出到屏幕上，这就摆脱了对可视窗口的依赖 MAC安装brew cask install chromedriver mac安装xvfb(可选) pip install xvfbwrapper</description>
    </item>
    
    <item>
      <title>动态网页爬取</title>
      <link>https://sunnnner.github.io/p/%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%88%AC%E5%8F%96/</link>
      <pubDate>Wed, 11 Sep 2019 11:42:10 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%88%AC%E5%8F%96/</guid>
      <description>我们使用自动化测试工具selenium pip install selenium
PhantomJS 基于webkit的无界面浏览器
ubuntu使用apt-get install phantomjs MAC使用bew cask install phantomjs
Chromedriver
与selenium配合因为phantomjs已经不支持selenium 如果使用Chrome进行测试，需要使用xvfb， Xvirtual framebuffer (xvfb)虚拟帧缓冲器， 简单来说它可以直接处理window的图形化功能，并且不会输出到屏幕上，这就摆脱了对可视窗口的依赖 MAC安装brew cask install chromedriver mac安装xvfb(可选) pip install xvfbwrapper</description>
    </item>
    
    <item>
      <title>Python字符串操作</title>
      <link>https://sunnnner.github.io/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 03 Sep 2019 11:25:09 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</guid>
      <description>语法 描述 s.capitalize() 返回字符串s的副本，并将首字符变为大写 s.center(width, char) 返回s中间部分的一个子字符串，长度为width，并使用空格或可选的char(长度为1的字符串)进行填充 s.count(t, star, end) 返回字符串s中（或在s的start:end分片中）子字符串t出现的次数 s.encode(encoding,err) 返回一个bytes对象，该对象使用默认的编码格式或指定编码格式来表示该字符串，并根据可选的err参数处理错误 s.expandtabs(size) 返回s的一个副本，其中的制表符使用8个或指定数量的空格替换 s.find(t, start, end) 返回t在s中（或在s的start:end分片中）的最左位置，如果没有找到，就返回-1，使用str:find()则可以发现相应的最右位置 s.format() 返回按指定参数进行格式化后的字符串副本， s.index(t, start, end) 返回s最左边t的位置(位置或在start:end的切片中) s.isalnum() 是否都为字母数字是返回true s.isalpha() 是否都为字母 s.isdecimal() 是为都为unicode的基数为10的数字 s.isdigit() 是否全为数字 s.isidentifier()  是否为有效的标识符 s.islower() 是否全为小写 s.isnumeric() 是否为数字或小数 s.isprintable() 是否为可打印的包括字符，不包括换行 s.isspace() 是否为空白字符 s.istitle() 是否首字母大写 s.isupper() 是否全为大写 s.join(seq) 返回seq中每个项链接起来后的结果 s.ljust(width, char) 返回长度为width的字符串使用空格或可选的char进行填充 s.lower() 将s中的字符变为小写 s.maketrans() 与str.translatr()类似 s.partition() 返回包含3个字符串的远足 s.replace(t, u, n) 替换 s.split(t, n) 以t进行切割 s.splitlines(f) 返回在行终结符处进行分割产生的行列表，并剥离行终结符 s.satrtwith() 以…开头 s.</description>
    </item>
    
    <item>
      <title>Python字符串操作</title>
      <link>https://sunnnner.github.io/p/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 03 Sep 2019 11:25:09 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</guid>
      <description>语法 描述 s.capitalize() 返回字符串s的副本，并将首字符变为大写 s.center(width, char) 返回s中间部分的一个子字符串，长度为width，并使用空格或可选的char(长度为1的字符串)进行填充 s.count(t, star, end) 返回字符串s中（或在s的start:end分片中）子字符串t出现的次数 s.encode(encoding,err) 返回一个bytes对象，该对象使用默认的编码格式或指定编码格式来表示该字符串，并根据可选的err参数处理错误 s.expandtabs(size) 返回s的一个副本，其中的制表符使用8个或指定数量的空格替换 s.find(t, start, end) 返回t在s中（或在s的start:end分片中）的最左位置，如果没有找到，就返回-1，使用str:find()则可以发现相应的最右位置 s.format() 返回按指定参数进行格式化后的字符串副本， s.index(t, start, end) 返回s最左边t的位置(位置或在start:end的切片中) s.isalnum() 是否都为字母数字是返回true s.isalpha() 是否都为字母 s.isdecimal() 是为都为unicode的基数为10的数字 s.isdigit() 是否全为数字 s.isidentifier()  是否为有效的标识符 s.islower() 是否全为小写 s.isnumeric() 是否为数字或小数 s.isprintable() 是否为可打印的包括字符，不包括换行 s.isspace() 是否为空白字符 s.istitle() 是否首字母大写 s.isupper() 是否全为大写 s.join(seq) 返回seq中每个项链接起来后的结果 s.ljust(width, char) 返回长度为width的字符串使用空格或可选的char进行填充 s.lower() 将s中的字符变为小写 s.maketrans() 与str.translatr()类似 s.partition() 返回包含3个字符串的远足 s.replace(t, u, n) 替换 s.split(t, n) 以t进行切割 s.splitlines(f) 返回在行终结符处进行分割产生的行列表，并剥离行终结符 s.satrtwith() 以…开头 s.</description>
    </item>
    
    <item>
      <title>修改macos自带Python版本（尽量不要修改）</title>
      <link>https://sunnnner.github.io/%E4%BF%AE%E6%94%B9macos%E8%87%AA%E5%B8%A6python%E7%89%88%E6%9C%AC%E5%B0%BD%E9%87%8F%E4%B8%8D%E8%A6%81%E4%BF%AE%E6%94%B9/</link>
      <pubDate>Mon, 02 Sep 2019 11:24:14 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/%E4%BF%AE%E6%94%B9macos%E8%87%AA%E5%B8%A6python%E7%89%88%E6%9C%AC%E5%B0%BD%E9%87%8F%E4%B8%8D%E8%A6%81%E4%BF%AE%E6%94%B9/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 1.在下载最新python（3.6）：wget https://www.python.org/ftp/python/3.6.1/python-3.6.1-macosx10.6.pkg 2.安装python-3.6.1-macosx10.6.pkg 3.删除mac自带的python2.7： sudo rm -R /System/Library/Frameworks/Python.framework/Versions/2.7 4.把刚安装好的python移到原本系统python位置： sudo mv /Library/Frameworks/Python.framework/Versions/3.6 /System/Library/Frameworks/Python.framework/Versions 5.修改文件所属的Group，设置Group为wheel： sudo chown -R root:wheel /System/Library/Frameworks/Python.framework/Versions/3.6``` 6.更新Current的Link sudo rm /System/Library/Frameworks/Python.framework/Versions/Current sudo ln -s /System/Library/Frameworks/Python.</description>
    </item>
    
    <item>
      <title>修改macos自带Python版本（尽量不要修改）</title>
      <link>https://sunnnner.github.io/p/%E4%BF%AE%E6%94%B9macos%E8%87%AA%E5%B8%A6python%E7%89%88%E6%9C%AC%E5%B0%BD%E9%87%8F%E4%B8%8D%E8%A6%81%E4%BF%AE%E6%94%B9/</link>
      <pubDate>Mon, 02 Sep 2019 11:24:14 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E4%BF%AE%E6%94%B9macos%E8%87%AA%E5%B8%A6python%E7%89%88%E6%9C%AC%E5%B0%BD%E9%87%8F%E4%B8%8D%E8%A6%81%E4%BF%AE%E6%94%B9/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 1.在下载最新python（3.6）：wget https://www.python.org/ftp/python/3.6.1/python-3.6.1-macosx10.6.pkg 2.安装python-3.6.1-macosx10.6.pkg 3.删除mac自带的python2.7： sudo rm -R /System/Library/Frameworks/Python.framework/Versions/2.7 4.把刚安装好的python移到原本系统python位置： sudo mv /Library/Frameworks/Python.framework/Versions/3.6 /System/Library/Frameworks/Python.framework/Versions 5.修改文件所属的Group，设置Group为wheel： sudo chown -R root:wheel /System/Library/Frameworks/Python.framework/Versions/3.6``` 6.更新Current的Link sudo rm /System/Library/Frameworks/Python.framework/Versions/Current sudo ln -s /System/Library/Frameworks/Python.</description>
    </item>
    
    <item>
      <title>Python版本控制以及虚拟环境的安装</title>
      <link>https://sunnnner.github.io/python%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%BB%A5%E5%8F%8A%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sun, 01 Sep 2019 11:22:47 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/python%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%BB%A5%E5%8F%8A%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/</guid>
      <description>虚拟环境安装 当然首先你先去官网下载Python3.6 注意不是3.7 它现在还不兼容 下载好了之后安装这是Mac的路径包 随后配置下面的语句 pip3 install virtualenv 当然这里你要建立一个文件夹来存放你的虚拟环境 我这里是workspace mkdir workspace 虚拟环境管理包
pip3 install virtualenvwrapper 虚拟环境文件夹 export WORKON_HOME=&amp;rsquo;~/workspace&#39;
虚拟环境Python需要Python版本进行安装 VIRTUALENVWRAPPER_PYTHON=&amp;quot;/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6&amp;quot;
使用哪个Python环境的虚拟环境安装包 source /Library/Frameworks/Python.framework/Versions/3.6/bin/virtualenvwrapper.sh
Python环境配置
因为TensorFlow库的学习我安装虚拟环境可是我并不怎么会安装虚拟环境 就擅自删除了Mac自带的Python版本使用网上的安装默认的版本Python3.6 可是这是错误的决定安装了默认版本的3。6之后pip各种报错 到最后我总结了一句话 在.zshrc（如果你安装了oh_my_zsh）就加入这一条shell语句 这条语句代表了你的默认Python变量的地址 Python环境变量 export PATH=&amp;quot;/Library/Frameworks/Python.framework/Versions/3.6/bin:${PATH}&amp;quot;</description>
    </item>
    
    <item>
      <title>Python版本控制以及虚拟环境的安装</title>
      <link>https://sunnnner.github.io/p/python%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%BB%A5%E5%8F%8A%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sun, 01 Sep 2019 11:22:47 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%BB%A5%E5%8F%8A%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/</guid>
      <description>虚拟环境安装 当然首先你先去官网下载Python3.6 注意不是3.7 它现在还不兼容 下载好了之后安装这是Mac的路径包 随后配置下面的语句 pip3 install virtualenv 当然这里你要建立一个文件夹来存放你的虚拟环境 我这里是workspace mkdir workspace 虚拟环境管理包
pip3 install virtualenvwrapper 虚拟环境文件夹 export WORKON_HOME=&amp;rsquo;~/workspace&#39;
虚拟环境Python需要Python版本进行安装 VIRTUALENVWRAPPER_PYTHON=&amp;quot;/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6&amp;quot;
使用哪个Python环境的虚拟环境安装包 source /Library/Frameworks/Python.framework/Versions/3.6/bin/virtualenvwrapper.sh
Python环境配置
因为TensorFlow库的学习我安装虚拟环境可是我并不怎么会安装虚拟环境 就擅自删除了Mac自带的Python版本使用网上的安装默认的版本Python3.6 可是这是错误的决定安装了默认版本的3。6之后pip各种报错 到最后我总结了一句话 在.zshrc（如果你安装了oh_my_zsh）就加入这一条shell语句 这条语句代表了你的默认Python变量的地址 Python环境变量 export PATH=&amp;quot;/Library/Frameworks/Python.framework/Versions/3.6/bin:${PATH}&amp;quot;</description>
    </item>
    
    <item>
      <title>数据库优化</title>
      <link>https://sunnnner.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</link>
      <pubDate>Tue, 05 Feb 2019 11:15:10 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</guid>
      <description>redis 数据库优化 1 2 3 4 5 6 7 8 9 10 11 尽量使用短的key 不要忘了见key识意 避免使用keys * 这条命令是阻塞就是操作这条命令的时候就不能操作其他的命令 保存数据之前先压缩一次 设置key的有效期，使其自动销毁 选择回收策略，Redis的实例空间被装满之后，会尝试回收一部分数据。 尽可能的使用哈希存储 一次性添加多条数据的时候可以使用管道进行存储 Redis的系统优化 修改Linux中TCP的最大容纳的数量 修改Linux中内核的分配策略 关闭 THP （连续的物理内存巨大的页面） redis 的性能优化总结 根据业务需要选择合适的数据类型，并为不同的应用场景设置响应的紧凑的存储参数
当业务场景不需要数据持久化时， 关闭所有的持久化方式可以或得最佳的性能以及最大的内存使用量
如果需要使用持久化根据是否可以容忍重启丢失部分数据在快照方式与语句追加方式之间选择其一，不
要使用虚拟内存以及diskstore方式
不要让你的Redis所在机器物理内存使用超过实际内存总量的3/5
mysql 数据库优化 sql 语句优化
索引优化
避免查询时的全盘扫描
增加缓存
读写分离
分区
分布式数据库（垂直分割）
水平切分
MongoDB 数据库优化 mongodb可以通过profile来监控数据，进行优化。
索引优化
数据库设计优化
1、完全分离（范式化设计） 2、完全内嵌（反范式化设计） 3、部分内嵌（折中方案） </description>
    </item>
    
    <item>
      <title>数据库优化</title>
      <link>https://sunnnner.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</link>
      <pubDate>Tue, 05 Feb 2019 11:15:10 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</guid>
      <description>redis 数据库优化 1 2 3 4 5 6 7 8 9 10 11 尽量使用短的key 不要忘了见key识意 避免使用keys * 这条命令是阻塞就是操作这条命令的时候就不能操作其他的命令 保存数据之前先压缩一次 设置key的有效期，使其自动销毁 选择回收策略，Redis的实例空间被装满之后，会尝试回收一部分数据。 尽可能的使用哈希存储 一次性添加多条数据的时候可以使用管道进行存储 Redis的系统优化 修改Linux中TCP的最大容纳的数量 修改Linux中内核的分配策略 关闭 THP （连续的物理内存巨大的页面） redis 的性能优化总结 根据业务需要选择合适的数据类型，并为不同的应用场景设置响应的紧凑的存储参数
当业务场景不需要数据持久化时， 关闭所有的持久化方式可以或得最佳的性能以及最大的内存使用量
如果需要使用持久化根据是否可以容忍重启丢失部分数据在快照方式与语句追加方式之间选择其一，不
要使用虚拟内存以及diskstore方式
不要让你的Redis所在机器物理内存使用超过实际内存总量的3/5
mysql 数据库优化 sql 语句优化
索引优化
避免查询时的全盘扫描
增加缓存
读写分离
分区
分布式数据库（垂直分割）
水平切分
MongoDB 数据库优化 mongodb可以通过profile来监控数据，进行优化。
索引优化
数据库设计优化
1、完全分离（范式化设计） 2、完全内嵌（反范式化设计） 3、部分内嵌（折中方案） </description>
    </item>
    
    <item>
      <title>数据库如何优化</title>
      <link>https://sunnnner.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 04 Feb 2019 10:52:21 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96/</guid>
      <description>优化SQL语句
通过添加索引进行优化
优化Order by
有两种方式如下：
（1）索引优化：对by后的列添加索引，从而大达到优化的目的。
（2）where+order by 的组合优化：通过where进行限制后在进行order by
优化limit
优化子查询
2.优化数据库结构
1、优化insert语句
禁用索引，禁用唯一性检查，使用一条insert插入多条语句。 2、优化update语句
使用一个update语句同时做多个更新。 3、优化delete语句
删除一条记录的时间与索引的数量成正比。删除一个表的所有行，使用truncate table Tbname 而不要使用delete from table Django如何优化
1利用标准数据库优化技术：索引, Django建立实体的时候，支持给字段添加索引，具体参考Django.db.models.Field.db_index。
2了解Django的QuerySets：QuerySets是有缓存的，一旦取出来，它就会在内存里呆上一段时间，尽量重用它
3数据库的工作就交给数据库本身计算，别用Python处理：使用 filter and exclude 过滤不需要的记录，这两个是最常用语句，相当是SQL的where。使用annotate对数据库做聚合运算。不要用python语言对以上类型数据过滤筛选，同样的结果，python处理复杂度要高，而且效率不高， 白白浪费内存。使用原生的SQL语句：
4如果需要就一次性取出你所需要的数据：
单一动作（如：同一个页面）需要多次连接数据库时，最好一次性取出所有需要的数据，减少连接数据库次数。此类需求推荐使用QuerySet.select_related() 和 prefetch_related()。使用QuerySet.count()代替len(queryset),虽然这两个处理得出的结果是一样的，但前者性能优秀很多。同理判断记录存在时，QuerySet.exists()比if queryset实在强得太多了。
5 懂减少数据库的连接数：
使用 QuerySet.update() 和 delete()，这两个函数是能批处理多条记录的，适当使用它们事半功倍；如果可以，别一条条数据去update delete处理。
使用 Redis 进行缓存
使用异步 Worker 进行写库操作
高并发问题
：1，悲观锁；2，乐观锁
使用场景：
并发量高的时候使用悲观锁，
缺点：加锁消耗资源
并发量低的时候使用乐观锁，
缺点：乐观锁循环耗费时间。 秒杀问题,一件商品多人抢购如何处理
获取第一位的数据其他人均不满足
说一下事务四大特性和隔离级别
ACID
原子性（Atomicity） 要么全部完成，要么都不成功
一致性(Consistency) 几个并行执行的事务，其执行结果必须与按照某一舒徐串执行的结果相一致
隔离性(Isolation) 事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须市透明的
持久性(Durability) 对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障；</description>
    </item>
    
    <item>
      <title>数据库如何优化</title>
      <link>https://sunnnner.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 04 Feb 2019 10:52:21 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96/</guid>
      <description>优化SQL语句
通过添加索引进行优化
优化Order by
有两种方式如下：
（1）索引优化：对by后的列添加索引，从而大达到优化的目的。
（2）where+order by 的组合优化：通过where进行限制后在进行order by
优化limit
优化子查询
2.优化数据库结构
1、优化insert语句
禁用索引，禁用唯一性检查，使用一条insert插入多条语句。 2、优化update语句
使用一个update语句同时做多个更新。 3、优化delete语句
删除一条记录的时间与索引的数量成正比。删除一个表的所有行，使用truncate table Tbname 而不要使用delete from table Django如何优化
1利用标准数据库优化技术：索引, Django建立实体的时候，支持给字段添加索引，具体参考Django.db.models.Field.db_index。
2了解Django的QuerySets：QuerySets是有缓存的，一旦取出来，它就会在内存里呆上一段时间，尽量重用它
3数据库的工作就交给数据库本身计算，别用Python处理：使用 filter and exclude 过滤不需要的记录，这两个是最常用语句，相当是SQL的where。使用annotate对数据库做聚合运算。不要用python语言对以上类型数据过滤筛选，同样的结果，python处理复杂度要高，而且效率不高， 白白浪费内存。使用原生的SQL语句：
4如果需要就一次性取出你所需要的数据：
单一动作（如：同一个页面）需要多次连接数据库时，最好一次性取出所有需要的数据，减少连接数据库次数。此类需求推荐使用QuerySet.select_related() 和 prefetch_related()。使用QuerySet.count()代替len(queryset),虽然这两个处理得出的结果是一样的，但前者性能优秀很多。同理判断记录存在时，QuerySet.exists()比if queryset实在强得太多了。
5 懂减少数据库的连接数：
使用 QuerySet.update() 和 delete()，这两个函数是能批处理多条记录的，适当使用它们事半功倍；如果可以，别一条条数据去update delete处理。
使用 Redis 进行缓存
使用异步 Worker 进行写库操作
高并发问题
：1，悲观锁；2，乐观锁
使用场景：
并发量高的时候使用悲观锁，
缺点：加锁消耗资源
并发量低的时候使用乐观锁，
缺点：乐观锁循环耗费时间。 秒杀问题,一件商品多人抢购如何处理
获取第一位的数据其他人均不满足
说一下事务四大特性和隔离级别
ACID
原子性（Atomicity） 要么全部完成，要么都不成功
一致性(Consistency) 几个并行执行的事务，其执行结果必须与按照某一舒徐串执行的结果相一致
隔离性(Isolation) 事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须市透明的
持久性(Durability) 对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障；</description>
    </item>
    
    <item>
      <title>Session&#43;cookie和使用tocken有什么区别</title>
      <link>https://sunnnner.github.io/session-cookie%E5%92%8C%E4%BD%BF%E7%94%A8tocken%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 03 Feb 2019 10:51:26 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/session-cookie%E5%92%8C%E4%BD%BF%E7%94%A8tocken%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid>
      <description>cookie数据存放在客户的浏览器上，session数据放在服务器上。
cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
考虑到安全应当使用session。
考虑到减轻服务器性能方面，应当使用COOKIE。
将登陆信息等重要信息存放为SESSION
其他信息如果需要保留，可以放在COOKIE中
session 和 token并不矛盾，作为身份认证 token安全性比session好
token就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；cookie就是写在客户端的一个txt文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名；session和cookie差不多，只是session是写在服务器端的文件，也需要在客户端写入cookie文件，但是文件里是你的浏览器编号.Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。</description>
    </item>
    
    <item>
      <title>Session&#43;cookie和使用tocken有什么区别</title>
      <link>https://sunnnner.github.io/p/session-cookie%E5%92%8C%E4%BD%BF%E7%94%A8tocken%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 03 Feb 2019 10:51:26 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/session-cookie%E5%92%8C%E4%BD%BF%E7%94%A8tocken%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid>
      <description>cookie数据存放在客户的浏览器上，session数据放在服务器上。
cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
考虑到安全应当使用session。
考虑到减轻服务器性能方面，应当使用COOKIE。
将登陆信息等重要信息存放为SESSION
其他信息如果需要保留，可以放在COOKIE中
session 和 token并不矛盾，作为身份认证 token安全性比session好
token就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；cookie就是写在客户端的一个txt文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名；session和cookie差不多，只是session是写在服务器端的文件，也需要在客户端写入cookie文件，但是文件里是你的浏览器编号.Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。</description>
    </item>
    
    <item>
      <title>线程进程协程</title>
      <link>https://sunnnner.github.io/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Sat, 02 Feb 2019 10:46:49 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B/</guid>
      <description>进程是系统进行资源分配和调度的一个独立单位，进程是资源分配的单位，线程是cpu调度的单位。
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,
只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
线程包含再进程中
协程，又程微线程，纤程，英文名：coroutine
而协程的操作则是程序员指定的，在python中通过yield，人为的实现并发处理。
协程存在的意义：
协程，则只使用一个线程，分解一个线程成为多个“微线程”，在一个线程中规定某个代码块的执行顺序。
协程的应用场景：当程序中存在大量不需要CPU的操作时（IO）。
首先我们得知道协程是啥？协程其实比线程更小的执行单元。 为啥说他是一个执行单元，因为他自带CPU上下文。
协程和线程差异：
线程切换非常耗性能
但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。
协程的问题-协程程序员自己调度
让需要执行的协程更多的获得CPU时间才是问题的关键。
计算密集型和IO密集型 计算密集型–&amp;gt;例如for循环里嵌套10层for循环–&amp;gt;占大量的cpu资源–&amp;gt;解决方案–&amp;gt;使用多进程不能用多线程（多线程中有个全局锁GIL）
IO密集型-&amp;gt;需要网络功能，大量的事件等待网络数据的到来–&amp;gt;多线程、协成
尽量不要再协程里面做IO密集型操作</description>
    </item>
    
    <item>
      <title>线程进程协程</title>
      <link>https://sunnnner.github.io/p/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Sat, 02 Feb 2019 10:46:49 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B/</guid>
      <description>进程是系统进行资源分配和调度的一个独立单位，进程是资源分配的单位，线程是cpu调度的单位。
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,
只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
线程包含再进程中
协程，又程微线程，纤程，英文名：coroutine
而协程的操作则是程序员指定的，在python中通过yield，人为的实现并发处理。
协程存在的意义：
协程，则只使用一个线程，分解一个线程成为多个“微线程”，在一个线程中规定某个代码块的执行顺序。
协程的应用场景：当程序中存在大量不需要CPU的操作时（IO）。
首先我们得知道协程是啥？协程其实比线程更小的执行单元。 为啥说他是一个执行单元，因为他自带CPU上下文。
协程和线程差异：
线程切换非常耗性能
但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。
协程的问题-协程程序员自己调度
让需要执行的协程更多的获得CPU时间才是问题的关键。
计算密集型和IO密集型 计算密集型–&amp;gt;例如for循环里嵌套10层for循环–&amp;gt;占大量的cpu资源–&amp;gt;解决方案–&amp;gt;使用多进程不能用多线程（多线程中有个全局锁GIL）
IO密集型-&amp;gt;需要网络功能，大量的事件等待网络数据的到来–&amp;gt;多线程、协成
尽量不要再协程里面做IO密集型操作</description>
    </item>
    
    <item>
      <title>广度优先遍历二叉树</title>
      <link>https://sunnnner.github.io/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 01 Feb 2019 10:44:14 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import queue class TreeNode: def init(self,val=None,left=None,right=None): self.val = val self.left = left self.right = right def settag(self,tag=None): self.tag = tag def visit(treenode): print(str(treenode.val),end=&amp;#39; &amp;#39;) def levelOrder(root): deque = queue.Queue() if(root is not None): deque.put(root) while(not deque.empty()): treenode = deque.</description>
    </item>
    
    <item>
      <title>广度优先遍历二叉树</title>
      <link>https://sunnnner.github.io/p/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 01 Feb 2019 10:44:14 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import queue class TreeNode: def init(self,val=None,left=None,right=None): self.val = val self.left = left self.right = right def settag(self,tag=None): self.tag = tag def visit(treenode): print(str(treenode.val),end=&amp;#39; &amp;#39;) def levelOrder(root): deque = queue.Queue() if(root is not None): deque.put(root) while(not deque.empty()): treenode = deque.</description>
    </item>
    
    <item>
      <title>深度优先遍历二叉树</title>
      <link>https://sunnnner.github.io/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 01 Jan 2019 10:41:11 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class TreeNode(object): #定义二叉树类 def init(self,val,left=None,right=None): self.val = val self.left = left self.right = right class BinaryTree(object): def __init__(self,root=None): self.root = root def preScan(self,retList, node): #先序遍历：先跟、再左、后右 if node !</description>
    </item>
    
    <item>
      <title>深度优先遍历二叉树</title>
      <link>https://sunnnner.github.io/p/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 01 Jan 2019 10:41:11 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class TreeNode(object): #定义二叉树类 def init(self,val,left=None,right=None): self.val = val self.left = left self.right = right class BinaryTree(object): def __init__(self,root=None): self.root = root def preScan(self,retList, node): #先序遍历：先跟、再左、后右 if node !</description>
    </item>
    
    <item>
      <title>Python字典按值排序</title>
      <link>https://sunnnner.github.io/python%E5%AD%97%E5%85%B8%E6%8C%89%E5%80%BC%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 02 Dec 2018 10:39:55 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/python%E5%AD%97%E5%85%B8%E6%8C%89%E5%80%BC%E6%8E%92%E5%BA%8F/</guid>
      <description> 1 2 3 4 5 6 7 8 9 10 # 方法1 f = zip(x.values(),x.keys()) sorted(f) # 方法2 sorted(x.items(), key = lambda x:x[1], reverse = True) # 字典key value互换 # 使用zip压缩器 # 使用字典推导式 {v: k for k ,v in x.items()} </description>
    </item>
    
    <item>
      <title>Python字典按值排序</title>
      <link>https://sunnnner.github.io/p/python%E5%AD%97%E5%85%B8%E6%8C%89%E5%80%BC%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 02 Dec 2018 10:39:55 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E5%AD%97%E5%85%B8%E6%8C%89%E5%80%BC%E6%8E%92%E5%BA%8F/</guid>
      <description> 1 2 3 4 5 6 7 8 9 10 # 方法1 f = zip(x.values(),x.keys()) sorted(f) # 方法2 sorted(x.items(), key = lambda x:x[1], reverse = True) # 字典key value互换 # 使用zip压缩器 # 使用字典推导式 {v: k for k ,v in x.items()} </description>
    </item>
    
    <item>
      <title>Python上楼梯问题</title>
      <link>https://sunnnner.github.io/python%E4%B8%8A%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 01 Dec 2018 10:39:04 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/python%E4%B8%8A%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98/</guid>
      <description> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def demo(n): a = 1排序 b = 2 c = 3 for i in range(n-3): c,b,a = a+b+c, c, b return c 其实就是斐波那契数列 def demo(n): if n == 1: return 1 if n == 2: return 2 a,b = 1, 2 result = 0 for i in range(3, n+1): result = a + b a = b b = result return result print(demo(10)) </description>
    </item>
    
    <item>
      <title>Python上楼梯问题</title>
      <link>https://sunnnner.github.io/p/python%E4%B8%8A%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 01 Dec 2018 10:39:04 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E4%B8%8A%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98/</guid>
      <description> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def demo(n): a = 1排序 b = 2 c = 3 for i in range(n-3): c,b,a = a+b+c, c, b return c 其实就是斐波那契数列 def demo(n): if n == 1: return 1 if n == 2: return 2 a,b = 1, 2 result = 0 for i in range(3, n+1): result = a + b a = b b = result return result print(demo(10)) </description>
    </item>
    
    <item>
      <title>Python快速排序</title>
      <link>https://sunnnner.github.io/python%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Thu, 01 Nov 2018 10:38:06 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/python%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def demo(A,p,r): x = A[r] i = p-1 for j in range(p,r): if A[j] &amp;lt;= x: i = i+1 A[i],A[j] = A[j],A[i] A[i+1], A[r] = A[r],A[i+1] return i + 1 def demo2(A,p,r): if p&amp;lt; r: q = demo(A,p,r) demo(A,p,q-1) demo(A,q+1,r) A = [23,54,6,5,7,8] # 0,4代表列表的下标 demo2(A,0,4) print(A) </description>
    </item>
    
    <item>
      <title>Python快速排序</title>
      <link>https://sunnnner.github.io/p/python%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Thu, 01 Nov 2018 10:38:06 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def demo(A,p,r): x = A[r] i = p-1 for j in range(p,r): if A[j] &amp;lt;= x: i = i+1 A[i],A[j] = A[j],A[i] A[i+1], A[r] = A[r],A[i+1] return i + 1 def demo2(A,p,r): if p&amp;lt; r: q = demo(A,p,r) demo(A,p,q-1) demo(A,q+1,r) A = [23,54,6,5,7,8] # 0,4代表列表的下标 demo2(A,0,4) print(A) </description>
    </item>
    
    <item>
      <title>Python链表</title>
      <link>https://sunnnner.github.io/python%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 02 Oct 2018 10:37:28 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/python%E9%93%BE%E8%A1%A8/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 1--&amp;gt;2--&amp;gt;3--&amp;gt;4--&amp;gt;5--&amp;gt;null 5--&amp;gt;4-&amp;gt;3--&amp;gt;2--&amp;gt;1--&amp;gt;null class Demo(object): def __init__(self,x): self.val = x self.next = None class Demo1(object): def reverseList(self,head): dummy = head tmp = dummy while head and head.next != None: dummy = head.next head.next = dummy.next dummy.next = tmp tmp = dummy return dummy head = Demo(1) head.</description>
    </item>
    
    <item>
      <title>Python链表</title>
      <link>https://sunnnner.github.io/p/python%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 02 Oct 2018 10:37:28 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E9%93%BE%E8%A1%A8/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 1--&amp;gt;2--&amp;gt;3--&amp;gt;4--&amp;gt;5--&amp;gt;null 5--&amp;gt;4-&amp;gt;3--&amp;gt;2--&amp;gt;1--&amp;gt;null class Demo(object): def __init__(self,x): self.val = x self.next = None class Demo1(object): def reverseList(self,head): dummy = head tmp = dummy while head and head.next != None: dummy = head.next head.next = dummy.next dummy.next = tmp tmp = dummy return dummy head = Demo(1) head.</description>
    </item>
    
    <item>
      <title>Python二分查找</title>
      <link>https://sunnnner.github.io/python%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Mon, 01 Oct 2018 10:36:53 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/python%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 时间复杂度为o（logN） def demo(array, t): for i in range(len(array): if array[i] == t: return True return False def demo1(array, t): left = 0 right = len(array) - 1 while left &amp;lt;= right: mid = int((left+right)/2) if array[mid] &amp;lt; t: left = mid+1 elif array[mid] &amp;gt; t: right = mid -1 else: return True return False array = list(range(100000)) import time t1 = time.</description>
    </item>
    
    <item>
      <title>Python二分查找</title>
      <link>https://sunnnner.github.io/p/python%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Mon, 01 Oct 2018 10:36:53 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 时间复杂度为o（logN） def demo(array, t): for i in range(len(array): if array[i] == t: return True return False def demo1(array, t): left = 0 right = len(array) - 1 while left &amp;lt;= right: mid = int((left+right)/2) if array[mid] &amp;lt; t: left = mid+1 elif array[mid] &amp;gt; t: right = mid -1 else: return True return False array = list(range(100000)) import time t1 = time.</description>
    </item>
    
    <item>
      <title>Python冒泡算法</title>
      <link>https://sunnnner.github.io/python%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 08 Sep 2018 10:36:08 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/python%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95/</guid>
      <description> 1 2 3 4 5 6 7 冒泡 def damo(sun): for i in range(len(sun)-1): for j in range(len(sun)-i-1): if sun[j]&amp;gt; sun[j+1]: sun[j], sun[j+1] = sun[j+1], sun[j] return sun </description>
    </item>
    
    <item>
      <title>Python冒泡算法</title>
      <link>https://sunnnner.github.io/p/python%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 08 Sep 2018 10:36:08 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95/</guid>
      <description> 1 2 3 4 5 6 7 冒泡 def damo(sun): for i in range(len(sun)-1): for j in range(len(sun)-i-1): if sun[j]&amp;gt; sun[j+1]: sun[j], sun[j+1] = sun[j+1], sun[j] return sun </description>
    </item>
    
    <item>
      <title>Python装饰器</title>
      <link>https://sunnnner.github.io/python%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
      <pubDate>Fri, 07 Sep 2018 10:35:21 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/python%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
      <description> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 装饰器 def demo(name): print(&amp;#39;demo--name&amp;#39;, name) def demo1(demo_name): print(&amp;#39;demo1--demoname&amp;#39;, demo_name.__name__) def demo2(): print(&amp;#39;demo--name&amp;#39;, name) demo_name() return demo2 return demo1 @demo(&amp;#39;zhuangshiqi&amp;#39;) def test(): print(&amp;#39;test&amp;#39;) test() </description>
    </item>
    
    <item>
      <title>Python装饰器</title>
      <link>https://sunnnner.github.io/p/python%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
      <pubDate>Fri, 07 Sep 2018 10:35:21 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
      <description> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 装饰器 def demo(name): print(&amp;#39;demo--name&amp;#39;, name) def demo1(demo_name): print(&amp;#39;demo1--demoname&amp;#39;, demo_name.__name__) def demo2(): print(&amp;#39;demo--name&amp;#39;, name) demo_name() return demo2 return demo1 @demo(&amp;#39;zhuangshiqi&amp;#39;) def test(): print(&amp;#39;test&amp;#39;) test() </description>
    </item>
    
    <item>
      <title>Python单例</title>
      <link>https://sunnnner.github.io/python%E5%8D%95%E4%BE%8B/</link>
      <pubDate>Wed, 05 Sep 2018 10:32:39 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/python%E5%8D%95%E4%BE%8B/</guid>
      <description>举个常见的单例模式例子，我们日常使用的电脑上都有一个回收站，在整个操作系统中，回收站只能有一个实例，整个系统都使用这个唯一的实例，而且回收站自行提供自己的实例。因此回收站是单例模式的应用。
单例模式，是一种常用的软件设计模式。在它的核心结构中，只包含一个被称为单例的特殊类。
通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。
1 2 3 4 5 6 7 8 9 10 11 12 13 class A(object): # 定义类属性记录实例化对象 __instance = None # 创建实例对象的方法 def __new__(cls): # 如果没有创建实例对象就创建 if cls.__instance == None: cls.__instance = object.__new__(cls) return cls.__instance else: #如果存在就直接返回 return cls.__instance 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # 创建单例时，只执行1次__init__方法 class Singleton(object): # 定义雷属性记录实例化对象 __instance = None #创建市里的方法 def __new__(cls): if cls.</description>
    </item>
    
    <item>
      <title>Python单例</title>
      <link>https://sunnnner.github.io/p/python%E5%8D%95%E4%BE%8B/</link>
      <pubDate>Wed, 05 Sep 2018 10:32:39 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E5%8D%95%E4%BE%8B/</guid>
      <description>举个常见的单例模式例子，我们日常使用的电脑上都有一个回收站，在整个操作系统中，回收站只能有一个实例，整个系统都使用这个唯一的实例，而且回收站自行提供自己的实例。因此回收站是单例模式的应用。
单例模式，是一种常用的软件设计模式。在它的核心结构中，只包含一个被称为单例的特殊类。
通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。
1 2 3 4 5 6 7 8 9 10 11 12 13 class A(object): # 定义类属性记录实例化对象 __instance = None # 创建实例对象的方法 def __new__(cls): # 如果没有创建实例对象就创建 if cls.__instance == None: cls.__instance = object.__new__(cls) return cls.__instance else: #如果存在就直接返回 return cls.__instance 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # 创建单例时，只执行1次__init__方法 class Singleton(object): # 定义雷属性记录实例化对象 __instance = None #创建市里的方法 def __new__(cls): if cls.</description>
    </item>
    
    <item>
      <title>Python多态</title>
      <link>https://sunnnner.github.io/python%E5%A4%9A%E6%80%81/</link>
      <pubDate>Tue, 04 Sep 2018 10:32:01 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/python%E5%A4%9A%E6%80%81/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 对象的多种形态 比如说动物，动物分为很多种但是动物都会吃东西，但是动物吃的东西又不一样 # 有三种动物：狗、猫、猪， #	父类：动物、 #	子类：狗、猫、猪 可以添加子类自己的方法，自己扩展 #	动物的属性：动物的名字 #	动物的方法是eat（就是打印自己的名字） # 有一个饲养员：饲养员 #	饲养员的方法：feed_animal(需要饲养的动物) #	函数的实现是（其实就是调用动物的eat方法） class Animal(object): name=&amp;#34;动物&amp;#34; def eat(self): print(&amp;#34;%s会吃东西&amp;#34;%(self.name)) class Dog(Animal): def eat(self): print(&amp;#34;小狗吃骨头&amp;#34;) class Cat(Animal): def eat(self): print(&amp;#34;小猫爱吃鱼&amp;#34;) class Pig(Animal): def eat(self): print(&amp;#34;小猪不知道吃什么&amp;#34;) class Breeder(object): def feed_animal(self,animal): animal.</description>
    </item>
    
    <item>
      <title>Python多态</title>
      <link>https://sunnnner.github.io/p/python%E5%A4%9A%E6%80%81/</link>
      <pubDate>Tue, 04 Sep 2018 10:32:01 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E5%A4%9A%E6%80%81/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 对象的多种形态 比如说动物，动物分为很多种但是动物都会吃东西，但是动物吃的东西又不一样 # 有三种动物：狗、猫、猪， #	父类：动物、 #	子类：狗、猫、猪 可以添加子类自己的方法，自己扩展 #	动物的属性：动物的名字 #	动物的方法是eat（就是打印自己的名字） # 有一个饲养员：饲养员 #	饲养员的方法：feed_animal(需要饲养的动物) #	函数的实现是（其实就是调用动物的eat方法） class Animal(object): name=&amp;#34;动物&amp;#34; def eat(self): print(&amp;#34;%s会吃东西&amp;#34;%(self.name)) class Dog(Animal): def eat(self): print(&amp;#34;小狗吃骨头&amp;#34;) class Cat(Animal): def eat(self): print(&amp;#34;小猫爱吃鱼&amp;#34;) class Pig(Animal): def eat(self): print(&amp;#34;小猪不知道吃什么&amp;#34;) class Breeder(object): def feed_animal(self,animal): animal.</description>
    </item>
    
    <item>
      <title>Celery任务队列</title>
      <link>https://sunnnner.github.io/celery%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/</link>
      <pubDate>Sun, 02 Sep 2018 10:29:21 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/celery%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/</guid>
      <description>celery 简介 任务队列 1 2 3 4 1.任务队列是一种在线程或机器间分发的任务的机制 2.消息队列的输入是工作的一个单元，称为任务，独立的职程（Worker）进程持续监视队列中是否有需要处理的新任务。 3.Celery 用消息通信，通常使用中间人（Broker）在客户端和职程间斡旋。这个过程从客户端向队列添加消息开始，之后中间人把消息派送给职程 4.Celery 系统可包含多个职程和中间人，以此获得高可用性和横向扩展能力。 </description>
    </item>
    
    <item>
      <title>Celery任务队列</title>
      <link>https://sunnnner.github.io/p/celery%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/</link>
      <pubDate>Sun, 02 Sep 2018 10:29:21 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/celery%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/</guid>
      <description>celery 简介 任务队列 1 2 3 4 1.任务队列是一种在线程或机器间分发的任务的机制 2.消息队列的输入是工作的一个单元，称为任务，独立的职程（Worker）进程持续监视队列中是否有需要处理的新任务。 3.Celery 用消息通信，通常使用中间人（Broker）在客户端和职程间斡旋。这个过程从客户端向队列添加消息开始，之后中间人把消息派送给职程 4.Celery 系统可包含多个职程和中间人，以此获得高可用性和横向扩展能力。 </description>
    </item>
    
    <item>
      <title>支付宝生成密匙步骤</title>
      <link>https://sunnnner.github.io/%E6%94%AF%E4%BB%98%E5%AE%9D%E7%94%9F%E6%88%90%E5%AF%86%E5%8C%99%E6%AD%A5%E9%AA%A4/</link>
      <pubDate>Tue, 05 Jun 2018 10:26:17 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/%E6%94%AF%E4%BB%98%E5%AE%9D%E7%94%9F%E6%88%90%E5%AF%86%E5%8C%99%E6%AD%A5%E9%AA%A4/</guid>
      <description>生成秘钥文件 1 2 3 4 openssl OpenSSL&amp;gt; genrsa -out app_private_key.pem 2048 # 私钥 OpenSSL&amp;gt; rsa -in app_private_key.pem -pubout -out app_public_key.pem # 导出公钥 OpenSSL&amp;gt; exit 设置支付宝沙箱公匙， 支付宝逐渐转换为RSA2密匙， 可以使用官方的工具生成
支付宝沙箱地址
生成RSA2教程
测试用秘钥 密码: rcip
设置本地公匙&amp;amp;私匙格式
1 2 3 4 5 6 7 8 9 10 11 12 app_private_key_string.pem -----BEGIN RSA PRIVATE KEY----- 私钥内容 -----END RSA PRIVATE KEY----- alipay_public_key_string.pem -----BEGIN PUBLIC KEY----- 公钥内容 -----END PUBLIC KEY----- </description>
    </item>
    
    <item>
      <title>支付宝生成密匙步骤</title>
      <link>https://sunnnner.github.io/p/%E6%94%AF%E4%BB%98%E5%AE%9D%E7%94%9F%E6%88%90%E5%AF%86%E5%8C%99%E6%AD%A5%E9%AA%A4/</link>
      <pubDate>Tue, 05 Jun 2018 10:26:17 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E6%94%AF%E4%BB%98%E5%AE%9D%E7%94%9F%E6%88%90%E5%AF%86%E5%8C%99%E6%AD%A5%E9%AA%A4/</guid>
      <description>生成秘钥文件 1 2 3 4 openssl OpenSSL&amp;gt; genrsa -out app_private_key.pem 2048 # 私钥 OpenSSL&amp;gt; rsa -in app_private_key.pem -pubout -out app_public_key.pem # 导出公钥 OpenSSL&amp;gt; exit 设置支付宝沙箱公匙， 支付宝逐渐转换为RSA2密匙， 可以使用官方的工具生成
支付宝沙箱地址
生成RSA2教程
测试用秘钥 密码: rcip
设置本地公匙&amp;amp;私匙格式
1 2 3 4 5 6 7 8 9 10 11 12 app_private_key_string.pem -----BEGIN RSA PRIVATE KEY----- 私钥内容 -----END RSA PRIVATE KEY----- alipay_public_key_string.pem -----BEGIN PUBLIC KEY----- 公钥内容 -----END PUBLIC KEY----- </description>
    </item>
    
    <item>
      <title>怎么加快页面的访问速度</title>
      <link>https://sunnnner.github.io/%E6%80%8E%E4%B9%88%E5%8A%A0%E5%BF%AB%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/</link>
      <pubDate>Thu, 31 May 2018 18:47:29 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/%E6%80%8E%E4%B9%88%E5%8A%A0%E5%BF%AB%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/</guid>
      <description>··· 我理解是压缩代码然后减少请求，多使用ajax 图片存第三方资源库
全静态，读写分离，加带宽 再开cdn</description>
    </item>
    
    <item>
      <title>怎么加快页面的访问速度</title>
      <link>https://sunnnner.github.io/p/%E6%80%8E%E4%B9%88%E5%8A%A0%E5%BF%AB%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/</link>
      <pubDate>Thu, 31 May 2018 18:47:29 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E6%80%8E%E4%B9%88%E5%8A%A0%E5%BF%AB%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/</guid>
      <description>··· 我理解是压缩代码然后减少请求，多使用ajax 图片存第三方资源库
全静态，读写分离，加带宽 再开cdn</description>
    </item>
    
  </channel>
</rss>
