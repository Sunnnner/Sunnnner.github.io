<!DOCTYPE html>
<html lang="en">
  <head>
	<meta name="generator" content="Hugo 0.113.0">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content=""
  />
  
    
      <title> | whiteKBlog</title>
    
  
  <link rel="stylesheet" href="/css/reset.css"/>
  <link rel="stylesheet" href="/css/font.css"/>
  <link rel="stylesheet" href="/css/smigle.css"/>
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
</head>

  <body>
    <div id="root">
      <header>
  <div id="brand">
    <a class="icon-link" href="https://sunnnner.github.io/">
      <img
        class="icon"
        src="/images/brandIcon.svg"
      />
    </a>
    <div class="text">
      <a href="https://sunnnner.github.io/"><h1>whiteKBlog</h1></a>
      <h3>Description about Blog Author</h3>
    </div>
  </div>
  <nav>
    
      
        
        <a href="/"><b>Home</b></a>
      
         | 
        <a href="/search/"><b>Search</b></a>
      
         | 
        <a href="/links/"><b>Links</b></a>
      
    
  </nav>
  <hr />
</header>

      <div id="content">
        
	<main>
		
		
			<article class="summary">
  <a href="https://sunnnner.github.io/p/jwt/">
    <h1 class="title">JWT</h1>
    
  </a>
  









  


<div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>2019-10-02 14:08:17</time>
    
    
  </strong>
 <span> • 223 words</span>
 <span> • 2 minute read</span>
  
    <div>
      <span>Tags:</span>
      
        <a href="/tags/django">django</a>
    </div>
  
</div>

  <div class="content">
    <p>JWT——Json web token 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准，可实现无状态、分布式的Web应用授权。 1.1 传统方式 XSS的原理分析与解剖
前后端分离通过Restful API进行数据交互时，如何验证用户的登录信息及权限。在原来的项目中，使用的是最传统也是最简单的方式，前端登录，后端根据用户信息生成一个token，并保存这个 token 和对应的用户id到数据库或Session中，接着把 token 传给用户，存入浏览器 cookie，之后浏览器请求带上这个cookie，后端根据这个cookie值来查询用户，验证是否过期。 但这样做问题就很多，如果我们的页面出现了 XSS 漏洞，由于 cookie 可以被 JavaScript 读取，XSS 漏洞会导致用户 token 泄露，而作为后端识别用户的标识，cookie 的泄露意味着用户信息不再安全。尽管我们通过转义输出内容，使用 CDN 等可以尽量避免 XSS 注入，但谁也不能保证在大型的项目中不会出现这个问题。 在设置 cookie 的时候，其实你还可以设置 httpOnly 以及 secure(保护)项。设置 httpOnly 后 cookie 将不能被 JS 读取，浏览器会自动的把它加在请求的 header 当中，设置 secure 的话，cookie 就只允许通过 HTTPS 传输。secure 选项可以过滤掉一些使用 HTTP 协议的 XSS 注入，但并不能完全阻止。 httpOnly 选项使得 JS 不能读取到 cookie，那么 XSS 注入的问题也基本不用担心了。但设置 httpOnly 就带来了另一个问题，就是很容易的被 XSRF，即跨站请求伪造。当你浏览器开着这个页面的时候，另一个页面可以很容易的跨站请求这个页面的内容。因为 cookie 默认被发了出去。 另外，如果将验证信息保存在数据库中，后端每次都需要根据token查出用户id，这就增加了数据库的查询和存储开销。若把验证信息保存在session中，有加大了服务器端的存储压力。那我们可不可以不要服务器去查询呢？如果我们生成token遵循一定的规律，比如我们使用对称加密算法来加密用户id形成token，那么服务端以后其实只要解密该token就可以知道用户的id是什么了。不过呢，我只是举个例子而已，要是真这么做，只要你的对称加密算法泄露了，其他人可以通过这种加密方式进行伪造token，那么所有用户信息都不再安全了。恩，那用非对称加密算法来做呢，其实现在有个规范就是这样做的，就是我们接下来要介绍的 JWT。 Json Web Token（JWT） JWT 是一个开放标准(RFC 7519)，它定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。JWT 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名。它具备两个特点： 简洁(Compact) 可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快 自包含(Self-contained) 负载中包含了所有用户所需要的信息，避免了多次查询数据库 JWT 组成 Header 头部 头部包含了两部分，token 类型和采用的加密算法 1 2 3 4 { &#34;alg&#34;: &#34;HS256&#34;, &#34;typ&#34;: &#34;JWT&#34; } 它会使用 Base64 编码组成 JWT 结构的第一部分,如果你使用Node.</p>
    
      <a href="https://sunnnner.github.io/p/jwt/">Read more...</a>
    
  </div>
</article>

		
			<article class="summary">
  <a href="https://sunnnner.github.io/p/token%E9%AA%8C%E8%AF%81%E8%AF%A6%E8%A7%A3/">
    <h1 class="title">TOKEN验证详解</h1>
    
  </a>
  









  


<div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>2019-10-01 14:03:37</time>
    
    
  </strong>
 <span> • 203 words</span>
 <span> • 1 minute read</span>
  
    <div>
      <span>Tags:</span>
      
        <a href="/tags/django">django</a>
    </div>
  
</div>

  <div class="content">
    <p>为什么使用token验证 在web领域基于token的身份验证随处可变，在大多说使用web API的互联网公司中，tokens是多用户下处理认证的最佳方式 一下几点特性会让你在程序中使用基于Token 的身份验证 无状态、可扩展 支持移动设备 跨程序调用 安全 那些使用基于Token的身份验证的大佬们 大部分你见到过的API和WEB应用都是用tokens，列如facebook, twitter, google+, github等 Token的起源 在介绍基于token的身份验证的原理与优势之前，不妨先看看之前的认证都是怎么做的
基于服务器的验证 我们都是知道HTTP协议是无状态的，这种无状态意味着程序需要验证每一次请求，从而辨别客户端的身份。 在这之前，程序都是通过在服务端存储的登录信息来辨别请求的。这种方式一般都是通过存储Session来完成。 随着Web，应用程序，已经移动端的兴起，这种验证的方式逐渐暴露出了问题。尤其是在可扩展性方面。 基于服务器的验证方式暴露的一些问题 1、session：每次认证用户发起请求时， 服务器需要去创建一个记录来存储信息， 当越来越多的用户发请求时， 内存的开销也会不断增加 2、可获振兴：在服务端的内存中使用session存储的登录信息，办所而来的是可扩展性问题 3、CORS（跨域资源共享）： 当我们需要让数据跨多台移动设备上使用时， 跨域资源共享回事一个让人头疼的问题， 在使用ajax抓取另一个域的资源，就可以会出现禁止请求的情况 4、CSRF（跨站请求伪造）： 用户在访问银行网站时， 他们很容易受到跨站请求伪造的攻击， 并且能够被利用其访问其他网站 在这些问题中，可扩展性是最突出，因此我们有必要去寻求一种更有行之有效的方法 基于TOKEN的验证原理 基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。 这种概念解决了在服务端存储信息时的许多问题 NoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。 基于Token的身份验证的过程如下: 1.用户通过用户名和密码发送请求。 2.程序验证。 3.程序返回一个签名的token 给客户端。 4.客户端储存token,并且每次用于每次发送请求。 5.服务端验证token并返回数据。 每一次请求都需要token。token应该在HTTP的头部发送从而保证了Http请求无状态。我们同样通过设置服务器属性Access-Control-Allow-Origin:* ，让服务器能接受到来自所有域的请求。需要主要的是，在ACAO头部标明(designating)*时，不得带有像HTTP认证，客户端SSL证书和cookies的证书。 代码实例流程： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //用户第一次登录 username pwd client_type //接口判断 if(token&amp;uid){ 查询token表 $token=where uid =uid if($token==token){ 登录成功！！ 返回token 和 uid }else{ 登录失败！！ } } if(usename powd client_type){ 检验用户名和密码 if（正确）{ 得到uid 并 生成token（md5( uid.</p>
    
      <a href="https://sunnnner.github.io/p/token%E9%AA%8C%E8%AF%81%E8%AF%A6%E8%A7%A3/">Read more...</a>
    
  </div>
</article>

		
			<article class="summary">
  <a href="https://sunnnner.github.io/p/restful_api%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/">
    <h1 class="title">RESTful_API设计指南</h1>
    
  </a>
  









  


<div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>2019-09-12 11:43:08</time>
    
    
  </strong>
 <span> • 232 words</span>
 <span> • 2 minute read</span>
  
    <div>
      <span>Tags:</span>
      
        <a href="/tags/drf">drf</a>
    </div>
  
</div>

  <div class="content">
    <p>网络应用程序，分为前端和后端两个部分， 当前的发展趋势， 就是前段设备层出不穷 因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信， 这导致API架构的流行， &gt; 甚至出现APIfirst的设计思想。
协议 API与用户的通信协议， 总是使用HTTPs协议 域名 应尽量将API部署在专用域名之下
https:// api.example.com 如果确定API很简单，不会有进一步扩展， 可以考虑放在主域名下
https: // example.com 版本(Versioning) 应将API的版本号放入URL
https://api.example.com/v1/ 另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。
路径(Endpoint) 路径又称”终点”（endpoint），表示API的具体网址。 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。 · https://api.example.com/v1/zoos · https://api.example.com/v1/animals · https://api.example.com/v1/employees HTTP动词 对于资源的具体操作类型，由HTTP动词表示。 常用的HTTP动词有下面五个（括号里是对应的SQL命令）。 GET(SELECT) : 从服务器取出资源(一项或者多项) POST(CREATE) : 在服务器新建一个资源 PUT(UPDATE) : 在服务器更新资源（客户端提供改变后的完整资源） PATCH(update): 在服务器更新资源（客户端提供改变的属性） DELETE(DELETE): 从服务器删除资源 还有两个不常用的HTTP动词 HEAD: 获取资源的元数据 OPTIONS: 获 取信息， 关于资源的哪些属性是客户端可以改变的 下面是一些例子 GET/ courses ：列出所有课程 POST/ courses : 添加一门课程 GET/ courses/ID: 获取某个课程的信息 PUT/ courses/ID: 更新某个指定课程信息（提供该课程的全部信息） PATCH/ courses/ID: 更新某个指定课程信息（提供该课程的部分信息） DELETE/courses/ID: 删除一门课程 GET/ courses/ ID/ class: 列出某个指定课程的所有班级 DELETE/courses/ class/ID: 删除某个指定课程的指定班级 过滤信息（Fitering） 如果记录数量很多，服务器不可能都将他们返回给用户，API应该提供参数， 过滤返回结果，下面是一些常见的参数 ?</p>
    
      <a href="https://sunnnner.github.io/p/restful_api%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/">Read more...</a>
    
  </div>
</article>

		
			<article class="summary">
  <a href="https://sunnnner.github.io/p/%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%88%AC%E5%8F%96/">
    <h1 class="title">动态网页爬取</h1>
    
  </a>
  









  


<div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>2019-09-11 11:42:10</time>
    
    
  </strong>
 <span> • 28 words</span>
 <span> • 1 minute read</span>
  
    <div>
      <span>Tags:</span>
      
        <a href="/tags/python">python</a>
    </div>
  
</div>

  <div class="content">
    <p>我们使用自动化测试工具selenium pip install selenium
PhantomJS 基于webkit的无界面浏览器
ubuntu使用apt-get install phantomjs MAC使用bew cask install phantomjs
Chromedriver
与selenium配合因为phantomjs已经不支持selenium 如果使用Chrome进行测试，需要使用xvfb， Xvirtual framebuffer (xvfb)虚拟帧缓冲器， 简单来说它可以直接处理window的图形化功能，并且不会输出到屏幕上，这就摆脱了对可视窗口的依赖 MAC安装brew cask install chromedriver mac安装xvfb(可选) pip install xvfbwrapper</p>
    
  </div>
</article>

		
			<article class="summary">
  <a href="https://sunnnner.github.io/p/sql%E4%BF%AE%E6%94%B9%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6/">
    <h1 class="title">Sql修改字段长度</h1>
    
  </a>
  









  


<div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>2019-09-10 11:41:14</time>
    
    
  </strong>
 <span> • 30 words</span>
 <span> • 1 minute read</span>
  
    <div>
      <span>Tags:</span>
      
        <a href="/tags/sql">sql</a>
    </div>
  
</div>

  <div class="content">
    <p>sql修改字段长度的语法 alter table 表名 modify 字段名 字段类型;
标准sql所有都适用 alter table 数据库.表名 modify 字段名 字段类型;
修改字段名名称 alter table 数据库名 表名 column col1 to col2;
添加字段 alter table 数据库名.表名 add 字段名 类型;</p>
    
  </div>
</article>

		
		<div>
  
    <a href="/page/6/">Previous Page</a>
  
  7 of 16
  
    <a href="/page/8/">Next Page</a>
  
</div>

	</main>

      </div>
      <footer>
  <hr />
  
  <p class="copyright">
    Copyright © 2024
    <a href="https://sunnnner.github.io/"><strong>Blog Author</strong></a>.
    This work is licensed under the
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> license.
  </p>
  <p class="builtWith">
    Built with
    <a href="http://www.gohugo.io/">Hugo</a>,
    using the theme
    <a href="https://gitlab.com/ian-s-mcb/smigle-hugo-theme">smigle</a>,
    which was influenced by the theme
    <a href="https://github.com/sumnerevans/smol">smol</a>.
  </p>
</footer>

    </div>
  </body>
</html>
