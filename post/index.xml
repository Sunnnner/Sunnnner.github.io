<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on whiteKBlog</title>
    <link>https://sunnnner.github.io/post/</link>
    <description>Recent content in Posts on whiteKBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 10 Mar 2022 15:46:40 +0800</lastBuildDate><atom:link href="https://sunnnner.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Pysocket</title>
      <link>https://sunnnner.github.io/p/pysocket/</link>
      <pubDate>Thu, 10 Mar 2022 15:46:40 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/pysocket/</guid>
      <description>2-1 套接字。面向连接的套接字和无连接套接字之间的区别是什么？
面向连接的套接字 无连接的套接字 在通信之前必须建立连接 在通信之前不需要建立连接 序列化的，可靠的不重复的数据交付 无法保证顺序性，可靠性或重复性，减少以一定的开销 没有记录边界 保存了记录边界 每条信息可以拆分成多个片段，并且每一个消息片段都能确保到达目的地，然后将他么按顺序组合在一起。 消息是以整体发送的。 传输控制协议(TCP) 用户数据协议(UDP) 2-2 客户端/服务器架构。用自己的话描述这个术语的意思，并给出几个例子。 1、服务器就是一系列硬件或软件，为一个或多个客户端（服务的用户）提供所需的“服务”。其存在的目的就是等待客户端的请求，并响应他们（提供服务），然后等待更多的请求。
2-3 套接字。 TCP 和 UDP 之中，哪种类型的服务器接受连接，并将它们转换到独立的 套接字进行客户端通信？ tcp
2-4 客户端。更新 TCP（tsTclnt.py）和 UDP（tsUclnt.py）客户端，以使得服务器名称 无须硬编码到应用程序中。此外，应该允许用户指定主机名和端口号，且如果二者 中任何一个或者全部参数丢失，那么应该使用默认值。
1 2 3 4 5 6 7 8 9 import sys, argparse if __name__ == &amp;#34;__main__&amp;#34;: parser = argparse.ArgumentParser(description=&amp;#34;pls write host port&amp;#34;) parser.add_argument(&amp;#34;--host&amp;#34;, type=str, default=&amp;#39;localhost&amp;#39;) parser.add_argument(&amp;#34;--port&amp;#34;, type=int, default=8000) args = parser.parse_args() host = args.host port = args.port print(args.host, args.port) 2-6 Daytime 服务。使用 socket.</description>
    </item>
    
    <item>
      <title>Djangoupgrade</title>
      <link>https://sunnnner.github.io/p/djangoupgrade/</link>
      <pubDate>Tue, 08 Mar 2022 11:06:40 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/djangoupgrade/</guid>
      <description> python3 中迭代器方法next()已经改变为__next__() </description>
    </item>
    
    <item>
      <title>Go导入外部包失效问题</title>
      <link>https://sunnnner.github.io/p/go%E5%AF%BC%E5%85%A5%E5%A4%96%E9%83%A8%E5%8C%85%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 26 Aug 2021 10:48:36 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/go%E5%AF%BC%E5%85%A5%E5%A4%96%E9%83%A8%E5%8C%85%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</guid>
      <description> 小记在mac上使用vscode导入redis包失效问题
解决办法
1 2 3 4 5 6 7 8 9 10 11 12 13 vim .bash_profile # 环境变量导入当前工作目录 export GOPATH=/Users/xxx/Desktop/go-project cd /Users/xxx/Desktop/go-project go mod init example.com/m/v2 # 自动下载所需的包 go mod tidy # 项目源代码放置处 mkdir src cd src # 可以开始编写了 </description>
    </item>
    
    <item>
      <title>Django Admin Permissions控制</title>
      <link>https://sunnnner.github.io/p/django-admin-permissions%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Tue, 24 Aug 2021 09:26:52 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/django-admin-permissions%E6%8E%A7%E5%88%B6/</guid>
      <description>is_staff bool 指定此用户是否可以访问管理站点 控制用户操作admin的权限由 django.contrib.auth.backends.ModelBackend 进行控制，它也进行控制用户的登录认证行为 ModelBackend源码解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class ModelBackend: &amp;#34;&amp;#34;&amp;#34; Authenticates against settings.</description>
    </item>
    
    <item>
      <title>Go词法单元</title>
      <link>https://sunnnner.github.io/p/go%E8%AF%8D%E6%B3%95%E5%8D%95%E5%85%83/</link>
      <pubDate>Tue, 17 Aug 2021 10:10:49 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/go%E8%AF%8D%E6%B3%95%E5%8D%95%E5%85%83/</guid>
      <description>高级语言源程序内部的几个概念 token、关键字、标识符、操作符、分隔符和字面量 token token 是构成源程序的基本不可再分割的单元，编译器编译程序的第一步就是将源程序分割为一个个独立的token，这个过程就是词法分析
go语言的token可以分为关键字、标识符、操作符、分隔符和字面常量等</description>
    </item>
    
    <item>
      <title>Django Orm聚合分组知识</title>
      <link>https://sunnnner.github.io/p/django-orm%E8%81%9A%E5%90%88%E5%88%86%E7%BB%84%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Thu, 12 Aug 2021 16:19:36 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/django-orm%E8%81%9A%E5%90%88%E5%88%86%E7%BB%84%E7%9F%A5%E8%AF%86/</guid>
      <description> annotate 聚合操作 有 Max Sum Count一些参数使用 =相当于sql中的as 如果想要查询的时候更换变量名称使用extra(select={&amp;quot;change_file&amp;quot;: &amp;quot;model_file&amp;quot;}) 相当于 sql 中的as sql中order by分组在orm使用values进行表达 示例 1 2 3 # 按照各个省事进行聚合数量 DemoModel.objects.filter(test=xxx).extra(select={&amp;#39;position&amp;#39;: city}).\ values(&amp;#34;position&amp;#34;, &amp;#34;location&amp;#34;).annotate(count=Count(city)) </description>
    </item>
    
    <item>
      <title>Ubuntu20.04 LTS编译python3.7</title>
      <link>https://sunnnner.github.io/p/ubuntu20.04-lts%E7%BC%96%E8%AF%91python3.7/</link>
      <pubDate>Fri, 06 Aug 2021 19:29:05 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/ubuntu20.04-lts%E7%BC%96%E8%AF%91python3.7/</guid>
      <description>ubuntu20.04 LTS编译 python3.7.1 安装编译前依赖包 sudo apt-get install -y build-essential libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev zlib1g-dev gcc make 编译前配置 sudo ./configure --enable-optimizations --prefix=/usr/local/bin/python3.7
&amp;ndash;prefix指定安装位置
编译安装 make
sudo make install
安装virtualenv虚拟环境来管理python版本 sudo apt install python3-pip pip install virtualenv pip install virtualenvwrapper mkdir .virtualenvs vim .zhsrc 1 2 3 4 export WORKON_HOME=$HOME/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3 export VIRTUALENVWRAPPER_VIRTUALENV=~/.local/bin/virtualenv source ~/.local/bin/virtualenvwrapper.sh source .zshrc 创建python3.7虚拟环境 mkvirtualenv -p mkvirtualenv -p /usr/local/bin/python3.7/bin/python3.7 py3.7 </description>
    </item>
    
    <item>
      <title>Go语言数据类型</title>
      <link>https://sunnnner.github.io/p/go%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sun, 02 Feb 2020 15:52:00 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/go%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>派生 包括： 指针类型(Pointer) 数组类型 结构化类型(struct) Channel类型 函数类型 切片类型 接口类型(interface) Map类型 浮点型 float32与float64 complex64与complex128 64位的实数与虚数 其他数字类型 byte 类似uint8 rune 类似int32 uint 32或者64位 int 与uint一样大 uintptr 无符号整型，用于存放一个指针 </description>
    </item>
    
    <item>
      <title>Go学习</title>
      <link>https://sunnnner.github.io/p/go%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sat, 01 Feb 2020 15:45:32 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/go%E5%AD%A6%E4%B9%A0/</guid>
      <description>Go关键字 关键字 意义 break 退出 default 默认函数 func 定义函数和方法 interface 用于定义接口 select 用于选择不同类型的通讯 case 用户条件选择 defer 延迟执行内容（收尾工作）有点类似C++的析构，但是它是再函数结尾的时候去执行（也就是栈即将被释放的时候） go 用于并发 map 用于声明map类型数据 struct 用于定义抽象数据类型 range 用于读取slice、map、channel数据 chan 用于channel通讯 if 选择结构-如果 else 选择结构-否则 type 用于声明自定义类型 return 用于从函数返回 var Go语言基础里面的变量和常量申明 (var age int) const 变量和常量的声明 package 包管理 import 导入 switch 选择结构 fallthrough 流程控制1.加了fallthrough后，会直接运行【紧跟的后一个】case或default语句，不论条件是否满足都会执行)2.加了fallthrough语句后，【紧跟的后一个】case条件不能定义常量和变量3.执行完fallthrough后直接跳到下一个条件语句，本条件执行语句后面的语句不执行 continue 跳过本次循环 for 循环 goto 跳转语句 36个预定义标识符 内建常量 内建类型 内建函数 true int make false int8 len iota int16 cap nil int32 new - int64 append - uint copy - uint8 close - uint16 delete - uint32 complex - uint64 real - uintprt imag - float32 panic - float64 recover - complex64 - - complex128 - - bool - - byte - - rune - - string - - error - </description>
    </item>
    
    <item>
      <title>Shell 判断文件中是否存在字符串</title>
      <link>https://sunnnner.github.io/p/shell-%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Wed, 01 Jan 2020 15:45:01 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/shell-%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description> 1 2 3 4 5 6 7 8 9 10 11 12 if cat xxx.yml | grep &amp;#34;content&amp;#34;&amp;gt;/dev/null then return 1 else return 0 fi </description>
    </item>
    
    <item>
      <title>Python日期转换</title>
      <link>https://sunnnner.github.io/p/python%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Tue, 10 Dec 2019 15:43:08 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2/</guid>
      <description>秒数是相对于1970.1.1号的秒数 日期的模块有time、datetime 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import datetime t = datetime.datetime(2009, 10, 21, 0, 0, 10, 10) # 分别是年份、月份、日、小时、分钟、秒、微妙(10-6秒) print (t-datetime.datetime(1970,1,1)).total_seconds() # 总共多少秒 import datetime, time t = datetime.datetime(2011, 10, 21, 0, 0) time.mktime(t.timetuple()) 1319148000.0 string转datetime str = &amp;#39;2012-11-19&amp;#39; date_time = datetime.datetime.strptime(str,&amp;#39;%Y-%m-%d&amp;#39;) datetime.datetime(2012,11,19,0,0) datetime转string date_time.strftime(&amp;#39;%Y-%m-%d&amp;#39;) &amp;#39;2012-11-19&amp;#39; datetime转时间戳 time_time = time.mktime(date_time.timetuple())
时间戳转string time.strftime(&#39;%Y-%m-%d&#39;,time.localtime(time_time)) &amp;lsquo;2012-11-19&amp;rsquo; date转datetime 1 2 3 4 5 6 7 8 9 date = datetime.</description>
    </item>
    
    <item>
      <title>Log BasicConfig函数</title>
      <link>https://sunnnner.github.io/p/log-basicconfig%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 05 Dec 2019 15:40:17 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/log-basicconfig%E5%87%BD%E6%95%B0/</guid>
      <description>logging.basicConfig函数 logging模块是Python内置标准模块，主要用于输出运行日志，可以设置输出日志的等级、日志保存路径，日志文件回滚等 ##相比Print优点：
可以通过设置不同的日志等级，在release版本中只输出重要信息，而不必显示大量的调试信息； print将所有信息都输出到标准输出中，严重影响开发者从标准输出中查看其它数据；logging则可以由开发者决定将信息输出到什么地方，以及怎么输出； 在python中，logging由logger，handler，filter，formater四个部分组成： logger是提供我们记录日志的方法；handler是让我们选择日志的输出地方，如：控制台，文件，邮件发送等，一个logger添加多个handler；filter是给用户提供更加细粒度的控制日志的输出内容；formater用户格式化输出日志的信息。 python中配置logging有三种方式 第一种：基础配置， 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 logging.basicConfig( filename=&amp;#34;config.log&amp;#34;, filemode=&amp;#34;w&amp;#34;, format=&amp;#34;%(asctime)s-%(name)s-%(levelname)s-%(message)s&amp;#34;, level=logging.INFO) 第二种：使用配置文件的方式配置logging,使用`fileConfig函数来读取配置文件 fileConfig( filename, defaults=None, disable_existing_loggers=Ture )` 第三种：使用一个字典方式来写配置信息，然后使用dictConfig dictConfig( dict, defaults=None, disable_existing_loggers=Ture ) 日志Level等级 日志一共分成5个等级，从低到高分别是：DEBUG ,INFO ,WARNING ,ERROR, CRITICAL。 DEBUG：详细的信息,通常只出现在诊断问题上 INFO：确认一切按预期运行 WARNING：一个迹象表明,一些意想不到的事情发生了,或表明一些问题在不久的将来(例如。磁盘空间低”)。这个软件还能按预期工作。 ERROR：更严重的问题,软件没能执行一些功能 CRITICAL：一个严重的错误,这表明程序本身可能无法继续运行 这5个等级，也分别对应5种打日志的方法： debug 、info 、warning 、error、critical。默认的是WARNING，当在WARNING或之上时才被跟踪。 二、日志输出：可以输出在控制台和文件，我选择的是输出在文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 StreamHandler：logging.</description>
    </item>
    
    <item>
      <title>Divmod函数</title>
      <link>https://sunnnner.github.io/p/divmod%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 01 Dec 2019 15:39:29 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/divmod%E5%87%BD%E6%95%B0/</guid>
      <description> python divmod()把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。 1 2 3 4 &amp;gt;&amp;gt;&amp;gt; divmod(3600, 60) (60, 0) &amp;gt;&amp;gt;&amp;gt; divmod(3500, 60) (58, 20) </description>
    </item>
    
    <item>
      <title>使用minikube创建集群</title>
      <link>https://sunnnner.github.io/p/%E4%BD%BF%E7%94%A8minikube%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Mon, 11 Nov 2019 15:38:29 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E4%BD%BF%E7%94%A8minikube%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4/</guid>
      <description>curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube_1.5.2.deb \ &amp;amp;&amp;amp; sudo dpkg -i minikube_1.5.2.deb
系统管理程序设置验证系统是否启用虚拟化 egrep -q &amp;lsquo;vmx|svm&amp;rsquo; /proc/cpuinfo &amp;amp;&amp;amp; echo yes || echo no 如果启用则需要关闭虚拟化
minikube servion查看版本信息
minikube start启动
查看集群信息kubectl cluster-info</description>
    </item>
    
    <item>
      <title>Install Postgresql</title>
      <link>https://sunnnner.github.io/p/install-postgresql/</link>
      <pubDate>Mon, 04 Nov 2019 15:37:26 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/install-postgresql/</guid>
      <description>安装postgres sudo apt install postgresql postgresql-contrib
安装完成后，PostgreSQL服务将自动启动。 要验证安装，我们将使用psql实用程序连接到PostgreSQL数据库服务器并打印服务器版本：sudo -u postgres psql -c &amp;ldquo;SELECT version();&amp;rdquo;
安装完毕后，系统会创建一个数据库超级用户 postgres，密码为空。
切换到postgres用户sudo -i -u postgres
执行psql进入postgres shell 执行\password postgres修改默认密码
修改/etc/postgresql/9.6/main下 postgresql.conf里面listen address为*
修改pg_hba.conf all 地址为0.0.0.0/0
重启sudo /etc/init.d/postgresql restart</description>
    </item>
    
    <item>
      <title>Github Page自定义域名开启https</title>
      <link>https://sunnnner.github.io/p/github-page%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFhttps/</link>
      <pubDate>Sun, 03 Nov 2019 15:36:46 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/github-page%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFhttps/</guid>
      <description>博主使用的cloudflare的cdn之前查了很久不清楚怎么使用github-page的https， 因github与Let’s Encrypt 合作提供自带cdn所以我们来配置一下， 首先关闭自定义域名的cdn服务其实就是关了他的域名解析
首先我们看域名还是active状态
其次我们关闭cloudflare站点cdn
查看站点状态
添加对github-Page的解析记录
如果github-Page你的Custom domain上已经填写了自定义域名，删除掉域名保存一下，随后再次输入一次保存你会看到你的https已经开启了</description>
    </item>
    
    <item>
      <title>K8s基础操作</title>
      <link>https://sunnnner.github.io/p/k8s%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sat, 02 Nov 2019 15:36:16 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/k8s%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</guid>
      <description>k8s获取所有运行的podskubectl get pods &amp;ndash;all-namespaces -o wide
获取当前集群名称kubectl get pods -o wide
当前etcd中的注册的宿主机的pod地址网段信息etcdctl ls /kube-centos/network/subnets
而每个node上的Pod子网是根据我们在安装flannel时配置来划分的，在etcd中查看该配置etcdctl get /kube-centos/network/config</description>
    </item>
    
    <item>
      <title>Docker添加root权限省去sudo</title>
      <link>https://sunnnner.github.io/p/docker%E6%B7%BB%E5%8A%A0root%E6%9D%83%E9%99%90%E7%9C%81%E5%8E%BBsudo/</link>
      <pubDate>Fri, 01 Nov 2019 15:35:30 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/docker%E6%B7%BB%E5%8A%A0root%E6%9D%83%E9%99%90%E7%9C%81%E5%8E%BBsudo/</guid>
      <description>首先使用root权限账户登录系统 首先查看用户组中有没有docker组sudo cat /etc/group | grep docker 创建docker分组，并将相应的用户添加到这个分组里面
sudo groupadd -g 999 docker
-g 999为组ID 也可以不指定
sudo usermod -aG dockerroot username
sudo usermod -aG docker username
检查一下是否有效 cat /etc/group
用户退出登录或者重启docker-daemon使权限生效
sudo systemctl restart docker
运行docker info查看是否生效
如果提示get权限不足，修改/var/run/docker.sock权限即可
sudo chmod a+rw /var/run/docker.sock</description>
    </item>
    
    <item>
      <title>Python Collections Duque函数演示</title>
      <link>https://sunnnner.github.io/p/python-collections-duque%E5%87%BD%E6%95%B0%E6%BC%94%E7%A4%BA/</link>
      <pubDate>Tue, 15 Oct 2019 15:33:37 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python-collections-duque%E5%87%BD%E6%95%B0%E6%BC%94%E7%A4%BA/</guid>
      <description> duque函数有一个maxlen参数，当append的时候，如果超过，那么最前面的就会被挤出队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from collections import duque def search(lines, pattern, lens=5): previous_lines = deque(maxlen=lens) for li in lines: if pattern in li: yield li, previous_lines previous_lines.append(li) if name == ‘main‘: with open(r’./xx.txt’) as f: for line, prevlines in search(f, ‘python’, 5): for pline in prevlines: print(pline, end=’’) print(line, end=’’) print(‘**’ * 20) </description>
    </item>
    
    <item>
      <title>Getattr函数</title>
      <link>https://sunnnner.github.io/p/getattr%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 14 Oct 2019 15:31:31 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/getattr%E5%87%BD%E6%95%B0/</guid>
      <description>##描述
getattr() 函数用于返回一个对象属性值。
语法 getattr 语法：
getattr(object, name, [default])
参数 object – 对象。 name – 字符串，对象属性。 default – 默认返回值，如果不提供该参数，在没有对应属性时，将触发 AttributeError。
返回值 返回对象属性值。 </description>
    </item>
    
    <item>
      <title>Hasattr函数</title>
      <link>https://sunnnner.github.io/p/hasattr%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 13 Oct 2019 15:30:12 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/hasattr%E5%87%BD%E6%95%B0/</guid>
      <description>描述 hasattr() 函数用于判断对象是否包含对应的属性。
语法 hasattr 语法：
hasattr(object, name)
参数 object – 对象。
name – 字符串，属性名。
返回值 如果对象有该属性返回 True，否则返回 False。 </description>
    </item>
    
    <item>
      <title>Git加速</title>
      <link>https://sunnnner.github.io/p/git%E5%8A%A0%E9%80%9F/</link>
      <pubDate>Sat, 12 Oct 2019 15:29:07 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/git%E5%8A%A0%E9%80%9F/</guid>
      <description>全局代理，写入配置 git config --global http.proxy &#39;socks5://127.0.0.1:1080&#39; git config --global https.proxy &#39;socks5://127.0.0.1:1080&#39; 清除配置 git config --global --unset http.proxy git config --global --unset https.proxy 临时代理 ALL_PROXY=socks5://127.0.0.1:1080 git clone xxx </description>
    </item>
    
    <item>
      <title>Django文件压缩</title>
      <link>https://sunnnner.github.io/p/django%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/</link>
      <pubDate>Fri, 11 Oct 2019 15:28:02 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/django%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/</guid>
      <description>类型和方法数据压缩分为两种类型。
有损：在这种类型的压缩中，压缩时会降低数据质量（在这种情况下为图像和视频）。这被广泛用于压缩多媒体。
无损：在这种类型的压缩中，数据质量（在这种情况下为图像）不会丢失。它广泛用于压缩无法承受数据丢失的敏感数据。
安装与配置
安装python图像处理库 Pillow
`pip install Pillow``
我们将建立一个简单的项目来演示图像上传以及上传之前和之后的文件大小。您也可以参考Django-docs或在此处下载完整的源代码。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 models.py from pil import Image from io import BytesIO from django.core.files.uploadedfile import InMemoryUploadedFile class File(models.Model): user = models.ForeignKey(KwsUser, verbose_name=&amp;#39;所属用户&amp;#39;, help_text=&amp;#39;所属用户&amp;#39;) file = models.FileField(upload_to=get_file_path, help_text=&amp;#39;上传的文件&amp;#39;) big_file = models.FileField(upload_to=get_pro_file_path, help_text=&amp;#39;上传的原图&amp;#39;, null=True, blank=True) upload_time = models.</description>
    </item>
    
    <item>
      <title>静态文件的含义以及配置</title>
      <link>https://sunnnner.github.io/p/%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Thu, 10 Oct 2019 15:27:14 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE/</guid>
      <description>Django staticfile 的配置 起初以为是我dockerfile写错了的问题，的确不是dockerfile的问题是我没有理解static_url与static_root的含义
👍 如果不是前后端分离项目在每个APP下都应该有static与templates文件夹存在不然django收集静态文件收集不到
STATIC_URL为Django返回给前端的路径即项目内部的static文件夹
STATIC_ROOT为静态文件收集的路径即 python3 manage.py collectstatic 的文件夹
STATIC_ROOT = os.path.join(BASE_DIR, &amp;lsquo;static&amp;rsquo;) 意思是把文件收集到项目下static文件夹下的static文件夹中
所以方便起见我把 STATIC_ROOT = os.path.join(BASE_DIR, &amp;lsquo;&amp;rsquo;)设置为了收集在项目下static文件夹下
大坑不少小坑不断，学无止境啊</description>
    </item>
    
    <item>
      <title>Os模块</title>
      <link>https://sunnnner.github.io/p/os%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Thu, 10 Oct 2019 14:20:46 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/os%E6%A8%A1%E5%9D%97/</guid>
      <description>os .path.dirname(path) 获取路径名
os.path.basename(path) 获取文件名
os.path.join(path1[,path2[,….]]) 将路径与文件名拼接成一个完整的路径
os.path.split(path) 分割路径与文件名，返回元组(f_path, f_name), 如果完全使用目录，它也会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在
os.path.splitext(path) 分割文件名与扩展名
os.path.getsize(file) 或得文件大小，单位是字节
os.path.gettatime(file) 或得文件最近的访问时间，返回的是浮点型秒数
os.path.getctime(file) 或得文件的创建时间，返回的是浮点型秒数
os.path.getmtime(file) 或得文件的修费时间，返回的是浮点型秒数
os.path.exists(path) 判断路径是否存在
os.path.isabs(path) 判断是否为绝对路径
os.path.isdir(path) 判断是否存在且是一个目录
os.path.isfile(path)
os.path.islink(path) 判断是否存在且是一个符号链接
os.path.ismount(path) 判断是否存在且是一个挂载点
os.path.samefile(path1, path2) 判断两个路径是否指向同一个文件</description>
    </item>
    
    <item>
      <title>K8s Install</title>
      <link>https://sunnnner.github.io/p/k8s-install/</link>
      <pubDate>Tue, 08 Oct 2019 14:57:24 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/k8s-install/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Docker操作</title>
      <link>https://sunnnner.github.io/p/docker%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 08 Oct 2019 14:19:00 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/docker%E6%93%8D%E4%BD%9C/</guid>
      <description>docker build 打包docker 项目
docker-compose up 启动整体项目(docker-compose.yml文件)
docker-compose down 强制停止docker运行的所有项目
1、删除所有容器 docker rm docker ps -a -q
2、删除所有镜像d ocker rmi docker images -q
3、按条件删除镜像 没有打标签docker rmi docker images -q | awk &#39;/^&amp;lt;none&amp;gt;/ { print $3 }&#39;
镜像名包含关键字docker rmi &amp;ndash;force docker images | grep doss-api | awk &#39;{print $3}&#39; //其中doss-api为关键字
docker-compose.yml
service 项目
image docker镜像名字，若本地没有会尝试在docker服务器拉取
restart 是否stop后重启
command 启动路径
volumes 将docker容器文件夹与本地文件夹映射挂载 [本地:docker文件夹]
environment 运行携带的参数
ports运行端口
links 关联项目，关联之后内部访问</description>
    </item>
    
    <item>
      <title>Django Minio开发过程</title>
      <link>https://sunnnner.github.io/p/django-minio%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Sun, 06 Oct 2019 14:17:12 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/django-minio%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B/</guid>
      <description> 使用Django-minio-storage进行开发minio的静态文件存储功能，本来寻思用minio直接进行开发，既然django有这个包我们就拿来用一下
项目说明django-minio-storage 开发期间遇到的问题 千万不要忘了把minio-storage添加到app
Add minio_storage to INSTALLED_APPS in your project settings. The last step is setting DEFAULT_FILE_STORAGE to &amp;quot;minio_storage.storage.MinioMediaStorage&amp;quot;, and STATICFILES_STORAGE to &amp;quot;minio_storage.storage.MinioStaticStorage&amp;quot;. 接下来的配置看官网配置就行了
因为我用docker写的所以minio_storage_endpoint可以使用docker项目名称:端口号或者外网域名（static.media.com）或者外网IP:端口号
浏览器复用minio静态服务器的media携带端口号怎么办？
解决办法 nginx 负载均衡：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 upstream docker { server docker:9000; } server { listen 80; server_name static.media.com location / { proxy_set_header Host $host; proxy_pass http://docker; client_max_body_size 10m; } } </description>
    </item>
    
    <item>
      <title>Python实现AES加密</title>
      <link>https://sunnnner.github.io/p/python%E5%AE%9E%E7%8E%B0aes%E5%8A%A0%E5%AF%86/</link>
      <pubDate>Sat, 05 Oct 2019 14:14:41 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E5%AE%9E%E7%8E%B0aes%E5%8A%A0%E5%AF%86/</guid>
      <description>环境 python3.6 三方库—pyCryptodome 介绍 之前的AES加密中，Py2或者3.4都是采用的pyCrypto这个模块但是它已经停止维护，现在多了一个分支pyCryptodome这个模块 如果有别的模块不能安装可以去这个网站下载安装点我
进去之后都会有安装教程
编写代码支付宝接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 # -*- coding: utf-8 -*- # pip install pycryptodome(这个一定要有) #pip install winrandom from datetime import datetime from Crypto.</description>
    </item>
    
    <item>
      <title>Mysql查询结果输出到文件</title>
      <link>https://sunnnner.github.io/p/mysql%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 03 Oct 2019 14:13:04 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/mysql%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6/</guid>
      <description>方法一： 直接执行命令： `mysql&amp;gt; select count(1) from table into outfile &#39;/tmp/test.xls&#39;;` Query OK, 31 rows affected (0.00 sec) 在目录/tmp/下会产生文件test.xls 遇到的问题： mysql&amp;gt; select count(1) from table into outfile &#39;/data/test.xls&#39;; 报错： ERROR 1 (HY000): Can’t create/write to file ‘/data/test.xls’ (Errcode: 13) 可能原因：mysql没有向/data/下写的权限 方法二： 查询都自动写入文件： mysql&amp;gt; pager cat &amp;gt; /tmp/test.txt ; PAGER set to &#39;cat &amp;gt; /tmp/test.txt&#39; 之后的所有查询结果都自动写入/tmp/test.txt’，并前后覆盖 mysql&amp;gt; select * from table ; 30 rows in set (0.59 sec) 在框口不再显示查询结果 方法三： 跳出mysql命令行 `# mysql -h 127.</description>
    </item>
    
    <item>
      <title>JWT</title>
      <link>https://sunnnner.github.io/p/jwt/</link>
      <pubDate>Wed, 02 Oct 2019 14:08:17 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/jwt/</guid>
      <description>JWT——Json web token 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准，可实现无状态、分布式的Web应用授权。 1.1 传统方式 XSS的原理分析与解剖
前后端分离通过Restful API进行数据交互时，如何验证用户的登录信息及权限。在原来的项目中，使用的是最传统也是最简单的方式，前端登录，后端根据用户信息生成一个token，并保存这个 token 和对应的用户id到数据库或Session中，接着把 token 传给用户，存入浏览器 cookie，之后浏览器请求带上这个cookie，后端根据这个cookie值来查询用户，验证是否过期。 但这样做问题就很多，如果我们的页面出现了 XSS 漏洞，由于 cookie 可以被 JavaScript 读取，XSS 漏洞会导致用户 token 泄露，而作为后端识别用户的标识，cookie 的泄露意味着用户信息不再安全。尽管我们通过转义输出内容，使用 CDN 等可以尽量避免 XSS 注入，但谁也不能保证在大型的项目中不会出现这个问题。 在设置 cookie 的时候，其实你还可以设置 httpOnly 以及 secure(保护)项。设置 httpOnly 后 cookie 将不能被 JS 读取，浏览器会自动的把它加在请求的 header 当中，设置 secure 的话，cookie 就只允许通过 HTTPS 传输。secure 选项可以过滤掉一些使用 HTTP 协议的 XSS 注入，但并不能完全阻止。 httpOnly 选项使得 JS 不能读取到 cookie，那么 XSS 注入的问题也基本不用担心了。但设置 httpOnly 就带来了另一个问题，就是很容易的被 XSRF，即跨站请求伪造。当你浏览器开着这个页面的时候，另一个页面可以很容易的跨站请求这个页面的内容。因为 cookie 默认被发了出去。 另外，如果将验证信息保存在数据库中，后端每次都需要根据token查出用户id，这就增加了数据库的查询和存储开销。若把验证信息保存在session中，有加大了服务器端的存储压力。那我们可不可以不要服务器去查询呢？如果我们生成token遵循一定的规律，比如我们使用对称加密算法来加密用户id形成token，那么服务端以后其实只要解密该token就可以知道用户的id是什么了。不过呢，我只是举个例子而已，要是真这么做，只要你的对称加密算法泄露了，其他人可以通过这种加密方式进行伪造token，那么所有用户信息都不再安全了。恩，那用非对称加密算法来做呢，其实现在有个规范就是这样做的，就是我们接下来要介绍的 JWT。 Json Web Token（JWT） JWT 是一个开放标准(RFC 7519)，它定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。JWT 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名。它具备两个特点： 简洁(Compact) 可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快 自包含(Self-contained) 负载中包含了所有用户所需要的信息，避免了多次查询数据库 JWT 组成 Header 头部 头部包含了两部分，token 类型和采用的加密算法 1 2 3 4 { &amp;#34;alg&amp;#34;: &amp;#34;HS256&amp;#34;, &amp;#34;typ&amp;#34;: &amp;#34;JWT&amp;#34; } 它会使用 Base64 编码组成 JWT 结构的第一部分,如果你使用Node.</description>
    </item>
    
    <item>
      <title>TOKEN验证详解</title>
      <link>https://sunnnner.github.io/p/token%E9%AA%8C%E8%AF%81%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 01 Oct 2019 14:03:37 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/token%E9%AA%8C%E8%AF%81%E8%AF%A6%E8%A7%A3/</guid>
      <description>为什么使用token验证 在web领域基于token的身份验证随处可变，在大多说使用web API的互联网公司中，tokens是多用户下处理认证的最佳方式 一下几点特性会让你在程序中使用基于Token 的身份验证 无状态、可扩展 支持移动设备 跨程序调用 安全 那些使用基于Token的身份验证的大佬们 大部分你见到过的API和WEB应用都是用tokens，列如facebook, twitter, google+, github等 Token的起源 在介绍基于token的身份验证的原理与优势之前，不妨先看看之前的认证都是怎么做的
基于服务器的验证 我们都是知道HTTP协议是无状态的，这种无状态意味着程序需要验证每一次请求，从而辨别客户端的身份。 在这之前，程序都是通过在服务端存储的登录信息来辨别请求的。这种方式一般都是通过存储Session来完成。 随着Web，应用程序，已经移动端的兴起，这种验证的方式逐渐暴露出了问题。尤其是在可扩展性方面。 基于服务器的验证方式暴露的一些问题 1、session：每次认证用户发起请求时， 服务器需要去创建一个记录来存储信息， 当越来越多的用户发请求时， 内存的开销也会不断增加 2、可获振兴：在服务端的内存中使用session存储的登录信息，办所而来的是可扩展性问题 3、CORS（跨域资源共享）： 当我们需要让数据跨多台移动设备上使用时， 跨域资源共享回事一个让人头疼的问题， 在使用ajax抓取另一个域的资源，就可以会出现禁止请求的情况 4、CSRF（跨站请求伪造）： 用户在访问银行网站时， 他们很容易受到跨站请求伪造的攻击， 并且能够被利用其访问其他网站 在这些问题中，可扩展性是最突出，因此我们有必要去寻求一种更有行之有效的方法 基于TOKEN的验证原理 基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。 这种概念解决了在服务端存储信息时的许多问题 NoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。 基于Token的身份验证的过程如下: 1.用户通过用户名和密码发送请求。 2.程序验证。 3.程序返回一个签名的token 给客户端。 4.客户端储存token,并且每次用于每次发送请求。 5.服务端验证token并返回数据。 每一次请求都需要token。token应该在HTTP的头部发送从而保证了Http请求无状态。我们同样通过设置服务器属性Access-Control-Allow-Origin:* ，让服务器能接受到来自所有域的请求。需要主要的是，在ACAO头部标明(designating)*时，不得带有像HTTP认证，客户端SSL证书和cookies的证书。 代码实例流程： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //用户第一次登录 username pwd client_type //接口判断 if(token&amp;amp;uid){ 查询token表 $token=where uid =uid if($token==token){ 登录成功！！ 返回token 和 uid }else{ 登录失败！！ } } if(usename powd client_type){ 检验用户名和密码 if（正确）{ 得到uid 并 生成token（md5( uid.</description>
    </item>
    
    <item>
      <title>RESTful_API设计指南</title>
      <link>https://sunnnner.github.io/p/restful_api%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/</link>
      <pubDate>Thu, 12 Sep 2019 11:43:08 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/restful_api%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/</guid>
      <description>网络应用程序，分为前端和后端两个部分， 当前的发展趋势， 就是前段设备层出不穷 因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信， 这导致API架构的流行， &amp;gt; 甚至出现APIfirst的设计思想。
协议 API与用户的通信协议， 总是使用HTTPs协议 域名 应尽量将API部署在专用域名之下
https:// api.example.com 如果确定API很简单，不会有进一步扩展， 可以考虑放在主域名下
https: // example.com 版本(Versioning) 应将API的版本号放入URL
https://api.example.com/v1/ 另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。
路径(Endpoint) 路径又称”终点”（endpoint），表示API的具体网址。 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。 · https://api.example.com/v1/zoos · https://api.example.com/v1/animals · https://api.example.com/v1/employees HTTP动词 对于资源的具体操作类型，由HTTP动词表示。 常用的HTTP动词有下面五个（括号里是对应的SQL命令）。 GET(SELECT) : 从服务器取出资源(一项或者多项) POST(CREATE) : 在服务器新建一个资源 PUT(UPDATE) : 在服务器更新资源（客户端提供改变后的完整资源） PATCH(update): 在服务器更新资源（客户端提供改变的属性） DELETE(DELETE): 从服务器删除资源 还有两个不常用的HTTP动词 HEAD: 获取资源的元数据 OPTIONS: 获 取信息， 关于资源的哪些属性是客户端可以改变的 下面是一些例子 GET/ courses ：列出所有课程 POST/ courses : 添加一门课程 GET/ courses/ID: 获取某个课程的信息 PUT/ courses/ID: 更新某个指定课程信息（提供该课程的全部信息） PATCH/ courses/ID: 更新某个指定课程信息（提供该课程的部分信息） DELETE/courses/ID: 删除一门课程 GET/ courses/ ID/ class: 列出某个指定课程的所有班级 DELETE/courses/ class/ID: 删除某个指定课程的指定班级 过滤信息（Fitering） 如果记录数量很多，服务器不可能都将他们返回给用户，API应该提供参数， 过滤返回结果，下面是一些常见的参数 ?</description>
    </item>
    
    <item>
      <title>动态网页爬取</title>
      <link>https://sunnnner.github.io/p/%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%88%AC%E5%8F%96/</link>
      <pubDate>Wed, 11 Sep 2019 11:42:10 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%88%AC%E5%8F%96/</guid>
      <description>我们使用自动化测试工具selenium pip install selenium
PhantomJS 基于webkit的无界面浏览器
ubuntu使用apt-get install phantomjs MAC使用bew cask install phantomjs
Chromedriver
与selenium配合因为phantomjs已经不支持selenium 如果使用Chrome进行测试，需要使用xvfb， Xvirtual framebuffer (xvfb)虚拟帧缓冲器， 简单来说它可以直接处理window的图形化功能，并且不会输出到屏幕上，这就摆脱了对可视窗口的依赖 MAC安装brew cask install chromedriver mac安装xvfb(可选) pip install xvfbwrapper</description>
    </item>
    
    <item>
      <title>Sql修改字段长度</title>
      <link>https://sunnnner.github.io/p/sql%E4%BF%AE%E6%94%B9%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Tue, 10 Sep 2019 11:41:14 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/sql%E4%BF%AE%E6%94%B9%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6/</guid>
      <description>sql修改字段长度的语法 alter table 表名 modify 字段名 字段类型;
标准sql所有都适用 alter table 数据库.表名 modify 字段名 字段类型;
修改字段名名称 alter table 数据库名 表名 column col1 to col2;
添加字段 alter table 数据库名.表名 add 字段名 类型;</description>
    </item>
    
    <item>
      <title>什么是跨域及解决办法</title>
      <link>https://sunnnner.github.io/p/%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Mon, 09 Sep 2019 11:39:55 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      <description>跨域 浏览器从一个域名的网页去请求另一个域名的资源时,浏览器处于安全的考虑,不允许不同源的请求 同源策略：协议相同， 域名相同， 端口相同 处理办法： 通过JSONP跨域 JSON是一种数据交换格式 JSONP是一种非官方的跨域数据交互协议 JSONP是包含在函数调用中的json sjonp是包含在函数调用中的json script标签不收同源策略的影响，手动创建一个script标签，传递URL， 同时传入一个回调函数的名字 服务器得到名字后， 返回数据时会用这个函数名来包裹数据， 客户端获取到数据之后， 立即吧script标签删掉 cors：跨域资源共享 使用自定义的HTTP头部允许浏览器和服务器相互通信 如果是简单请求,直接设置允许访问的域名： 允许你的域名来获取我的数据 response[‘Access-Control-Allow-Origin‘] = “*” 如果是复杂请求,首先会发送options请求做预检,然后再发送真正的PUT/POST….请求 因此如果复杂请求是PUT等请求,则服务端需要设置允许某请求 如果复杂请求设置了请求头，则服务端需要设置允许某请求头 简单请求： 一次请求 非简单请求： 两次请求，在发送数据之前会先发一次请求用于做“预检”， 只有“预检”通过后才再发送一次请求用于数据传输。 只要同时满足以下两大条件，就属于简单请求。 (1) 请求方法是以下三种方法之一：HEAD GET POST (2)HTTP的头信息不超出以下几种字段： 1 2 3 4 5 Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、 text/plain JSONP和CORS：
1.JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求 2.jsonp需要client和server端的相互配合 3.cors在client端无需设置，server端需要针对不同的请求，来做head头的处理 </description>
    </item>
    
    <item>
      <title>Django_rest_framework</title>
      <link>https://sunnnner.github.io/p/django_rest_framework/</link>
      <pubDate>Sun, 08 Sep 2019 11:37:47 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/django_rest_framework/</guid>
      <description>为什么要使用Django_rest_framework 能自动生成restful规范的API
代码简介 并且开发速度快 Django_rest_framework框架有什么组件 序列化组件：serializers 对queryset序列化及对请求数据格式校验
路由组件：routers 进行路由开发 视图组件： ModelViewSet 帮助开发者提供了一些类。 并在类中提供了多个方法 认证组件： 写一个类并注册到选线类（authentication_classes）， 再类的authticate方法中编写认证逻辑 权限组件：写一个类并注册到权限类（permission_classes）, 在类中的has_permission方法中编写认证逻辑 频率限制： 写一个类并注册到频率类（throttle_classes）, 在类中的allow_request/wait方法中编写认证逻辑 解析器 选择对数据解析的类， 在解析类中注册(parser_classes) 渲染器 定义数据如何渲染到页面上， 在渲染器类中注册(render_classes) 分页 对获取到的数据进行分页处理 pagination_class 版本 版本控制用来在不同的客户端使用不同的行为 在URL中设置version参数， 用户请求时候传入参数， 在request.version中获取版本, 根据版本不同，做不同处理 django rest framework框架的认证流程 用户请求走进来进入APIView， 初始化了默认的认证方式
进入APIView.dispatch()方法， initial方法调用了request.user 如果我们配置了认证类， 走我们自己认证类中的authentication方法 django rest framework如何实现的用户访问频率控制 使用ip/用户账户作为建， 每次访问时间作为值， 构造一个字典数据， 存起来， 每次访问对时间列表进行判断
把没有访问的超时的删掉。 在计算列表剩余的元素就能做到频率限制了 匿名账户， 使用IP控制， 但是无法完全控制， 因为用户可以更换代理IP 登陆用户使用账号控制，但是如果有很多账号，也无法限制 如何实现用户登陆认证 cookice session
token 登陆成功后生成的加密字符串 JWT： json wed token 缩写， 他讲用户信息加密到token中 服务器不保存任何用户信息， 服务器通过使用保存的密匙来验证token的正确性 rest_framework序列化组件的作用,以及一些外键关系的钩子方法</description>
    </item>
    
    <item>
      <title>什么是RPC</title>
      <link>https://sunnnner.github.io/p/%E4%BB%80%E4%B9%88%E6%98%AFrpc/</link>
      <pubDate>Sat, 07 Sep 2019 11:36:55 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E4%BB%80%E4%B9%88%E6%98%AFrpc/</guid>
      <description>RPC
远程过程中调用(RPC) 是一种协议， 程序可使用这种协议向网络中的另一台计算机上的程序请求服务 RPC采用客户机/ 服务器模式， 请求程序就是一个客户机， 而服务提供程序就是一个服务器 first 客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息 second 在服务端， 进程保持睡眠状态知道调用信息到达为止， 当一个调用到达， 服务器或得晋城参数， 结果， 发送答复信息， 然后等待下一个调用信息 next 客户端调用进程接受答复信息， 或得进程结果， 然后调用执行继续进行 为什么要使用API
系统之间为了调用数据 数据的传输格式：json, xml </description>
    </item>
    
    <item>
      <title>Restful规范</title>
      <link>https://sunnnner.github.io/p/restful%E8%A7%84%E8%8C%83/</link>
      <pubDate>Fri, 06 Sep 2019 11:36:12 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/restful%E8%A7%84%E8%8C%83/</guid>
      <description>restful 只是一种软件架构风格或者说是一种设计风格，它只是给我们提供了一个设计的原则和约束的条件，主要用于客户端与服务端的交互
我们可以根据自己的需求做的更加简洁， 更有层次
它里面提供了一些规范，比如restful提倡面向资源编程， 在URL接口中尽量使用名词， 不要使用动词
在restful推荐使用HTTPS协议，更加安全
尽量在URL中体现版本号
restful的method &amp;lt;GET/ POST/ PUT/ DELETE/ PATCH&amp;gt;
响应应该设置状态码
有返回值，并且为json格式
返回结果中要提供帮助链接， 即API最好做好Hypermedia</description>
    </item>
    
    <item>
      <title>Django中的FBV和CBV</title>
      <link>https://sunnnner.github.io/p/django%E4%B8%AD%E7%9A%84fbv%E5%92%8Ccbv/</link>
      <pubDate>Thu, 05 Sep 2019 11:34:25 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/django%E4%B8%AD%E7%9A%84fbv%E5%92%8Ccbv/</guid>
      <description>FBV fbv就是在url中一个路径对应一个函数
1 2 3 4 urlpatterns = [ url(r&amp;#39;^admin/&amp;#39;, admin.site.urls), url(r&amp;#39;^index/&amp;#39;, views.index) ] 视图函数中 1 2 def index(request): return render(request, &amp;#39;index.html&amp;#39;) CBV cbv就是在url中一个路径对应一个类
1 2 3 4 urlpatterns = [ url(r&amp;#39;^admin/&amp;#39;, admin.site.urls), url(r&amp;#39;^index/&amp;#39;, views.IndexView.as_views()) # 执行类后面的as_view()方法 ] 视图函数中 1 2 3 4 5 6 7 8 9 from django.views import View class IndexView(View): # 以get形式访问会执行get函数，一般情况下获取数据 def get(self, *args, **keargs): return HttpResponse(&amp;#39;6666&amp;#39;) # 以post形式访问的话会执行post函数，一般情况下发送数据 def post(self, *args, **kwargs): return HttpResponse(&amp;#39;post ok&amp;#39;) 注意: cbv定义类的时候必须要继承view 在写URL的时候必须要加as_view 类里面使用form表单提交的话只有get和post方法 restful规范：’get’获取数据, ‘post’创建新数据, ‘put’更新, ‘patch’局部更新, ‘delete’删除, ‘head’, ‘options’, ‘trace’ CBV重新定义dispatch函数 所有的方法本质上都是通过dispatch这个函数反射执行，如果想要在执行get或post方法前执行其他步骤，可以重写dispatch </description>
    </item>
    
    <item>
      <title>Rclone挂载googleDrive</title>
      <link>https://sunnnner.github.io/p/rclone%E6%8C%82%E8%BD%BDgoogledrive/</link>
      <pubDate>Wed, 04 Sep 2019 11:30:51 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/rclone%E6%8C%82%E8%BD%BDgoogledrive/</guid>
      <description>最近查找大容量存储工具，想到了免费版的Google云盘，询问了一下有一个无限空间的云盘，话不多说开始搞，在淘宝买了个账号开始配在自己的服务器上，但是发现并不是这么好配，查找了很多资料，到最后朋友给我说rclone可以挂在Google云盘，查了一下果然可以，把教程贴出来为以后查看方便 首先安装rclone wget https://www.moerats.com/usr/shell/rclone_debian.sh &amp;amp;&amp;amp; bash rclone_debian.sh 初始化配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 rclone config n) New remote s) Set configuration password q) Quit config n/s/q&amp;gt; n name&amp;gt; Rats #随便填，后面要用到 Type of storage to configure.</description>
    </item>
    
    <item>
      <title>Python字符串操作</title>
      <link>https://sunnnner.github.io/p/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 03 Sep 2019 11:25:09 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</guid>
      <description>语法 描述 s.capitalize() 返回字符串s的副本，并将首字符变为大写 s.center(width, char) 返回s中间部分的一个子字符串，长度为width，并使用空格或可选的char(长度为1的字符串)进行填充 s.count(t, star, end) 返回字符串s中（或在s的start:end分片中）子字符串t出现的次数 s.encode(encoding,err) 返回一个bytes对象，该对象使用默认的编码格式或指定编码格式来表示该字符串，并根据可选的err参数处理错误 s.expandtabs(size) 返回s的一个副本，其中的制表符使用8个或指定数量的空格替换 s.find(t, start, end) 返回t在s中（或在s的start:end分片中）的最左位置，如果没有找到，就返回-1，使用str:find()则可以发现相应的最右位置 s.format() 返回按指定参数进行格式化后的字符串副本， s.index(t, start, end) 返回s最左边t的位置(位置或在start:end的切片中) s.isalnum() 是否都为字母数字是返回true s.isalpha() 是否都为字母 s.isdecimal() 是为都为unicode的基数为10的数字 s.isdigit() 是否全为数字 s.isidentifier()  是否为有效的标识符 s.islower() 是否全为小写 s.isnumeric() 是否为数字或小数 s.isprintable() 是否为可打印的包括字符，不包括换行 s.isspace() 是否为空白字符 s.istitle() 是否首字母大写 s.isupper() 是否全为大写 s.join(seq) 返回seq中每个项链接起来后的结果 s.ljust(width, char) 返回长度为width的字符串使用空格或可选的char进行填充 s.lower() 将s中的字符变为小写 s.maketrans() 与str.translatr()类似 s.partition() 返回包含3个字符串的远足 s.replace(t, u, n) 替换 s.split(t, n) 以t进行切割 s.splitlines(f) 返回在行终结符处进行分割产生的行列表，并剥离行终结符 s.satrtwith() 以…开头 s.</description>
    </item>
    
    <item>
      <title>修改macos自带Python版本（尽量不要修改）</title>
      <link>https://sunnnner.github.io/p/%E4%BF%AE%E6%94%B9macos%E8%87%AA%E5%B8%A6python%E7%89%88%E6%9C%AC%E5%B0%BD%E9%87%8F%E4%B8%8D%E8%A6%81%E4%BF%AE%E6%94%B9/</link>
      <pubDate>Mon, 02 Sep 2019 11:24:14 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E4%BF%AE%E6%94%B9macos%E8%87%AA%E5%B8%A6python%E7%89%88%E6%9C%AC%E5%B0%BD%E9%87%8F%E4%B8%8D%E8%A6%81%E4%BF%AE%E6%94%B9/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 1.在下载最新python（3.6）：wget https://www.python.org/ftp/python/3.6.1/python-3.6.1-macosx10.6.pkg 2.安装python-3.6.1-macosx10.6.pkg 3.删除mac自带的python2.7： sudo rm -R /System/Library/Frameworks/Python.framework/Versions/2.7 4.把刚安装好的python移到原本系统python位置： sudo mv /Library/Frameworks/Python.framework/Versions/3.6 /System/Library/Frameworks/Python.framework/Versions 5.修改文件所属的Group，设置Group为wheel： sudo chown -R root:wheel /System/Library/Frameworks/Python.framework/Versions/3.6``` 6.更新Current的Link sudo rm /System/Library/Frameworks/Python.framework/Versions/Current sudo ln -s /System/Library/Frameworks/Python.</description>
    </item>
    
    <item>
      <title>Python版本控制以及虚拟环境的安装</title>
      <link>https://sunnnner.github.io/p/python%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%BB%A5%E5%8F%8A%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sun, 01 Sep 2019 11:22:47 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%BB%A5%E5%8F%8A%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/</guid>
      <description>虚拟环境安装 当然首先你先去官网下载Python3.6 注意不是3.7 它现在还不兼容 下载好了之后安装这是Mac的路径包 随后配置下面的语句 pip3 install virtualenv 当然这里你要建立一个文件夹来存放你的虚拟环境 我这里是workspace mkdir workspace 虚拟环境管理包
pip3 install virtualenvwrapper 虚拟环境文件夹 export WORKON_HOME=&amp;rsquo;~/workspace&#39;
虚拟环境Python需要Python版本进行安装 VIRTUALENVWRAPPER_PYTHON=&amp;quot;/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6&amp;quot;
使用哪个Python环境的虚拟环境安装包 source /Library/Frameworks/Python.framework/Versions/3.6/bin/virtualenvwrapper.sh
Python环境配置
因为TensorFlow库的学习我安装虚拟环境可是我并不怎么会安装虚拟环境 就擅自删除了Mac自带的Python版本使用网上的安装默认的版本Python3.6 可是这是错误的决定安装了默认版本的3。6之后pip各种报错 到最后我总结了一句话 在.zshrc（如果你安装了oh_my_zsh）就加入这一条shell语句 这条语句代表了你的默认Python变量的地址 Python环境变量 export PATH=&amp;quot;/Library/Frameworks/Python.framework/Versions/3.6/bin:${PATH}&amp;quot;</description>
    </item>
    
    <item>
      <title>Shell 文件测试操作</title>
      <link>https://sunnnner.github.io/p/shell-%E6%96%87%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 20 Aug 2019 11:22:13 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/shell-%E6%96%87%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%93%8D%E4%BD%9C/</guid>
      <description> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #! /bin/bash # file test operators # 检查文件是否存在 -e 表示empty 默认文件是不为空 echo -e &amp;#34;Enter the name of file: ~&amp;#34; read filename # 注意括号内空格 -e 就是exist的意思,表示文件是否存在 if [ -e $filename ] then echo &amp;#39;File found&amp;#39; else echo &amp;#39;file is not exist or not found&amp;#39; fi # 检查是否是常规文件或者目录 -f表示file 判断是否是常规的文件 if [ -f $filename ] then echo &amp;#34;$filename found&amp;#34; else echo &amp;#34;$filename is not exist or not fount&amp;#34; fi # 检查文件是否是空 if [ -s $filename ] then echo &amp;#34;$filename is not empty&amp;#34; else echo &amp;#34;$filename is empty&amp;#34; fi </description>
    </item>
    
    <item>
      <title>Shell if Then语句</title>
      <link>https://sunnnner.github.io/p/shell-if-then%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Mon, 19 Aug 2019 11:21:38 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/shell-if-then%E8%AF%AD%E5%8F%A5/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 !</description>
    </item>
    
    <item>
      <title>Shell 如何传参</title>
      <link>https://sunnnner.github.io/p/shell-%E5%A6%82%E4%BD%95%E4%BC%A0%E5%8F%82/</link>
      <pubDate>Sun, 18 Aug 2019 11:21:09 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/shell-%E5%A6%82%E4%BD%95%E4%BC%A0%E5%8F%82/</guid>
      <description> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # how to pass arguments to shell script # 利用echo打印你传入的参数 # 上面可以看到$0表示 我们运行sh文件的语句 ./demo.sh，这个不是一个我们提供的真实的参数。 # echo $0 $1 $2 $3 # 换成args 数组方式去存储参数列表 args=(&amp;#34;$@&amp;#34;) # echo ${args[0]} ${args[1]} ${args[2]} ${args[3]} # 更简单的方法 $@可以表示传入的参数列表，直接打印出来 # echo $@ # 如何计算参数的个数 # $#可以存储参数的个数值 echo $# </description>
    </item>
    
    <item>
      <title>Shell 获取用户输入</title>
      <link>https://sunnnner.github.io/p/shell-%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/</link>
      <pubDate>Sat, 17 Aug 2019 11:20:41 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/shell-%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/</guid>
      <description> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #! /bin/bash # learn about how to read from user input echo &amp;#34;Places input your name&amp;#34; read name echo &amp;#34;your had input name is $name&amp;#34; # -p 是promote ，提示的意思就是可以让用户在提示语相同 # 一行输入内容 read -p &amp;#34;Please input a name&amp;#34; user_var echo &amp;#34;your had input name is: $user_var&amp;#34; # 模拟用户输入密码操作 read -p &amp;#34;place input you name&amp;#34; users_var # -s一般在输入密码的时候启用可以输入过程看不到操作 read -sp &amp;#34;place input you password&amp;#34; pas_var echo &amp;#34;you had input name is $users_var&amp;#34; echo &amp;#34;you had input password is $pas_var&amp;#34; </description>
    </item>
    
    <item>
      <title>Shell 2</title>
      <link>https://sunnnner.github.io/p/shell-2/</link>
      <pubDate>Fri, 16 Aug 2019 11:19:55 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/shell-2/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 #! /bin/bash # input your comments here echo &amp;#39;Hello world&amp;#39; # you also can input a comment here echo $BASH # 引用系统变量使用“$” echo $PATH echo the system variable path is $PATH name=Anthony echo my name is $name 引用系统变量使用‘$’
定义变量时等号两边不要有空格
#号是备注信息</description>
    </item>
    
    <item>
      <title>Shell 1</title>
      <link>https://sunnnner.github.io/p/shell-1/</link>
      <pubDate>Thu, 15 Aug 2019 11:18:47 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/shell-1/</guid>
      <description>什么是shell
最早期运行在unix上的shell是Bourne shell（sh），其实shell我们都知道是一个内核，里面集成了很多命令，shell负责和底层硬件打交道。前面我们介绍的这些命令，可以说是shell命令。shell程序的入口一般是在终端输入一些相关命令，然后不需要编译，直接去解释和运行命令的结果，给出相关反馈到终端上面。所以，一句话来理解，shell是一个很多命令的集合，一个内核 什么是bash
bash 是一个为GNU计划编写的Unix shell。它的名字是一系列缩写：Bourne-Again SHell — 这是关于Bourne shell（sh）的一个双关语（Bourne again / born again）.Bash (GNU Bourne-Again Shell) 是许多Linux发行版的默认Shell。事实上，还有许多传统UNIX上用的Shell，例如tcsh、csh、ash、bsh、ksh等等，Shell Script大致都类同，当您学会一种Shell以后，其它的Shell会很快就上手，大多数的时候，一个Shell Script通常可以在很多种Shell上使用。所以，这就是我们为什么要使用bash脚本的原因。我们接下来的shell脚本都是基于bash。 什么是shell脚本
前面我们写过了一个shell脚本，shell脚本就是通过一些相关shell命令的组合来达到完成一个任务的文件，文件一般是以,sh结尾。 写一个shell脚本，在终端打印hello shell
1 2 3 4 5 6 7 8 touch hello.sh code hello.sh #! /bin/bash echo &amp;#39;Hello world&amp;#39; 提高权限 -rwxr-xr-x chmod +x hellp.sh </description>
    </item>
    
    <item>
      <title>框架</title>
      <link>https://sunnnner.github.io/p/%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Fri, 01 Mar 2019 11:16:46 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E6%A1%86%E6%9E%B6/</guid>
      <description>CSS常用框架
1、Scooter CSS 2、Leaf CSS 3、Fox CSS 4、Miligram CSS 5、Layers CSS 6、Baseguide CSS 7、Mimic CSS 8、Cascade CSS 9、Emastic CSS 10、Neutron CSS HTML框架
frame iframe JS框架
1.Zepto.js 2.SUI Mobile 3.Node.Js 4.angular.Js 5.JQuery Mobile 6.requirejs 7.Vue.js 8.backbone.js 9.React 10.Ionic 前端UI框架
1.Pure 2.bootstrap 3.EasyUI 4.Ant Design 可视化组件
1.Echarts 2.tableau(收费) </description>
    </item>
    
    <item>
      <title>数据库优化</title>
      <link>https://sunnnner.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</link>
      <pubDate>Tue, 05 Feb 2019 11:15:10 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</guid>
      <description>redis 数据库优化 1 2 3 4 5 6 7 8 9 10 11 尽量使用短的key 不要忘了见key识意 避免使用keys * 这条命令是阻塞就是操作这条命令的时候就不能操作其他的命令 保存数据之前先压缩一次 设置key的有效期，使其自动销毁 选择回收策略，Redis的实例空间被装满之后，会尝试回收一部分数据。 尽可能的使用哈希存储 一次性添加多条数据的时候可以使用管道进行存储 Redis的系统优化 修改Linux中TCP的最大容纳的数量 修改Linux中内核的分配策略 关闭 THP （连续的物理内存巨大的页面） redis 的性能优化总结 根据业务需要选择合适的数据类型，并为不同的应用场景设置响应的紧凑的存储参数
当业务场景不需要数据持久化时， 关闭所有的持久化方式可以或得最佳的性能以及最大的内存使用量
如果需要使用持久化根据是否可以容忍重启丢失部分数据在快照方式与语句追加方式之间选择其一，不
要使用虚拟内存以及diskstore方式
不要让你的Redis所在机器物理内存使用超过实际内存总量的3/5
mysql 数据库优化 sql 语句优化
索引优化
避免查询时的全盘扫描
增加缓存
读写分离
分区
分布式数据库（垂直分割）
水平切分
MongoDB 数据库优化 mongodb可以通过profile来监控数据，进行优化。
索引优化
数据库设计优化
1、完全分离（范式化设计） 2、完全内嵌（反范式化设计） 3、部分内嵌（折中方案） </description>
    </item>
    
    <item>
      <title>数据库如何优化</title>
      <link>https://sunnnner.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 04 Feb 2019 10:52:21 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96/</guid>
      <description>优化SQL语句
通过添加索引进行优化
优化Order by
有两种方式如下：
（1）索引优化：对by后的列添加索引，从而大达到优化的目的。
（2）where+order by 的组合优化：通过where进行限制后在进行order by
优化limit
优化子查询
2.优化数据库结构
1、优化insert语句
禁用索引，禁用唯一性检查，使用一条insert插入多条语句。 2、优化update语句
使用一个update语句同时做多个更新。 3、优化delete语句
删除一条记录的时间与索引的数量成正比。删除一个表的所有行，使用truncate table Tbname 而不要使用delete from table Django如何优化
1利用标准数据库优化技术：索引, Django建立实体的时候，支持给字段添加索引，具体参考Django.db.models.Field.db_index。
2了解Django的QuerySets：QuerySets是有缓存的，一旦取出来，它就会在内存里呆上一段时间，尽量重用它
3数据库的工作就交给数据库本身计算，别用Python处理：使用 filter and exclude 过滤不需要的记录，这两个是最常用语句，相当是SQL的where。使用annotate对数据库做聚合运算。不要用python语言对以上类型数据过滤筛选，同样的结果，python处理复杂度要高，而且效率不高， 白白浪费内存。使用原生的SQL语句：
4如果需要就一次性取出你所需要的数据：
单一动作（如：同一个页面）需要多次连接数据库时，最好一次性取出所有需要的数据，减少连接数据库次数。此类需求推荐使用QuerySet.select_related() 和 prefetch_related()。使用QuerySet.count()代替len(queryset),虽然这两个处理得出的结果是一样的，但前者性能优秀很多。同理判断记录存在时，QuerySet.exists()比if queryset实在强得太多了。
5 懂减少数据库的连接数：
使用 QuerySet.update() 和 delete()，这两个函数是能批处理多条记录的，适当使用它们事半功倍；如果可以，别一条条数据去update delete处理。
使用 Redis 进行缓存
使用异步 Worker 进行写库操作
高并发问题
：1，悲观锁；2，乐观锁
使用场景：
并发量高的时候使用悲观锁，
缺点：加锁消耗资源
并发量低的时候使用乐观锁，
缺点：乐观锁循环耗费时间。 秒杀问题,一件商品多人抢购如何处理
获取第一位的数据其他人均不满足
说一下事务四大特性和隔离级别
ACID
原子性（Atomicity） 要么全部完成，要么都不成功
一致性(Consistency) 几个并行执行的事务，其执行结果必须与按照某一舒徐串执行的结果相一致
隔离性(Isolation) 事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须市透明的
持久性(Durability) 对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障；</description>
    </item>
    
    <item>
      <title>Session&#43;cookie和使用tocken有什么区别</title>
      <link>https://sunnnner.github.io/p/session-cookie%E5%92%8C%E4%BD%BF%E7%94%A8tocken%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 03 Feb 2019 10:51:26 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/session-cookie%E5%92%8C%E4%BD%BF%E7%94%A8tocken%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid>
      <description>cookie数据存放在客户的浏览器上，session数据放在服务器上。
cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
考虑到安全应当使用session。
考虑到减轻服务器性能方面，应当使用COOKIE。
将登陆信息等重要信息存放为SESSION
其他信息如果需要保留，可以放在COOKIE中
session 和 token并不矛盾，作为身份认证 token安全性比session好
token就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；cookie就是写在客户端的一个txt文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名；session和cookie差不多，只是session是写在服务器端的文件，也需要在客户端写入cookie文件，但是文件里是你的浏览器编号.Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。</description>
    </item>
    
    <item>
      <title>线程进程协程</title>
      <link>https://sunnnner.github.io/p/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Sat, 02 Feb 2019 10:46:49 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B/</guid>
      <description>进程是系统进行资源分配和调度的一个独立单位，进程是资源分配的单位，线程是cpu调度的单位。
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,
只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
线程包含再进程中
协程，又程微线程，纤程，英文名：coroutine
而协程的操作则是程序员指定的，在python中通过yield，人为的实现并发处理。
协程存在的意义：
协程，则只使用一个线程，分解一个线程成为多个“微线程”，在一个线程中规定某个代码块的执行顺序。
协程的应用场景：当程序中存在大量不需要CPU的操作时（IO）。
首先我们得知道协程是啥？协程其实比线程更小的执行单元。 为啥说他是一个执行单元，因为他自带CPU上下文。
协程和线程差异：
线程切换非常耗性能
但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。
协程的问题-协程程序员自己调度
让需要执行的协程更多的获得CPU时间才是问题的关键。
计算密集型和IO密集型 计算密集型–&amp;gt;例如for循环里嵌套10层for循环–&amp;gt;占大量的cpu资源–&amp;gt;解决方案–&amp;gt;使用多进程不能用多线程（多线程中有个全局锁GIL）
IO密集型-&amp;gt;需要网络功能，大量的事件等待网络数据的到来–&amp;gt;多线程、协成
尽量不要再协程里面做IO密集型操作</description>
    </item>
    
    <item>
      <title>广度优先遍历二叉树</title>
      <link>https://sunnnner.github.io/p/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 01 Feb 2019 10:44:14 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import queue class TreeNode: def init(self,val=None,left=None,right=None): self.val = val self.left = left self.right = right def settag(self,tag=None): self.tag = tag def visit(treenode): print(str(treenode.val),end=&amp;#39; &amp;#39;) def levelOrder(root): deque = queue.Queue() if(root is not None): deque.put(root) while(not deque.empty()): treenode = deque.</description>
    </item>
    
    <item>
      <title>深度优先遍历二叉树</title>
      <link>https://sunnnner.github.io/p/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 01 Jan 2019 10:41:11 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class TreeNode(object): #定义二叉树类 def init(self,val,left=None,right=None): self.val = val self.left = left self.right = right class BinaryTree(object): def __init__(self,root=None): self.root = root def preScan(self,retList, node): #先序遍历：先跟、再左、后右 if node !</description>
    </item>
    
    <item>
      <title>Python字典按值排序</title>
      <link>https://sunnnner.github.io/p/python%E5%AD%97%E5%85%B8%E6%8C%89%E5%80%BC%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 02 Dec 2018 10:39:55 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E5%AD%97%E5%85%B8%E6%8C%89%E5%80%BC%E6%8E%92%E5%BA%8F/</guid>
      <description> 1 2 3 4 5 6 7 8 9 10 # 方法1 f = zip(x.values(),x.keys()) sorted(f) # 方法2 sorted(x.items(), key = lambda x:x[1], reverse = True) # 字典key value互换 # 使用zip压缩器 # 使用字典推导式 {v: k for k ,v in x.items()} </description>
    </item>
    
    <item>
      <title>Python上楼梯问题</title>
      <link>https://sunnnner.github.io/p/python%E4%B8%8A%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 01 Dec 2018 10:39:04 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E4%B8%8A%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98/</guid>
      <description> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def demo(n): a = 1排序 b = 2 c = 3 for i in range(n-3): c,b,a = a+b+c, c, b return c 其实就是斐波那契数列 def demo(n): if n == 1: return 1 if n == 2: return 2 a,b = 1, 2 result = 0 for i in range(3, n+1): result = a + b a = b b = result return result print(demo(10)) </description>
    </item>
    
    <item>
      <title>Python快速排序</title>
      <link>https://sunnnner.github.io/p/python%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Thu, 01 Nov 2018 10:38:06 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def demo(A,p,r): x = A[r] i = p-1 for j in range(p,r): if A[j] &amp;lt;= x: i = i+1 A[i],A[j] = A[j],A[i] A[i+1], A[r] = A[r],A[i+1] return i + 1 def demo2(A,p,r): if p&amp;lt; r: q = demo(A,p,r) demo(A,p,q-1) demo(A,q+1,r) A = [23,54,6,5,7,8] # 0,4代表列表的下标 demo2(A,0,4) print(A) </description>
    </item>
    
    <item>
      <title>Python链表</title>
      <link>https://sunnnner.github.io/p/python%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 02 Oct 2018 10:37:28 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E9%93%BE%E8%A1%A8/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 1--&amp;gt;2--&amp;gt;3--&amp;gt;4--&amp;gt;5--&amp;gt;null 5--&amp;gt;4-&amp;gt;3--&amp;gt;2--&amp;gt;1--&amp;gt;null class Demo(object): def __init__(self,x): self.val = x self.next = None class Demo1(object): def reverseList(self,head): dummy = head tmp = dummy while head and head.next != None: dummy = head.next head.next = dummy.next dummy.next = tmp tmp = dummy return dummy head = Demo(1) head.</description>
    </item>
    
    <item>
      <title>Python二分查找</title>
      <link>https://sunnnner.github.io/p/python%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Mon, 01 Oct 2018 10:36:53 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 时间复杂度为o（logN） def demo(array, t): for i in range(len(array): if array[i] == t: return True return False def demo1(array, t): left = 0 right = len(array) - 1 while left &amp;lt;= right: mid = int((left+right)/2) if array[mid] &amp;lt; t: left = mid+1 elif array[mid] &amp;gt; t: right = mid -1 else: return True return False array = list(range(100000)) import time t1 = time.</description>
    </item>
    
    <item>
      <title>Python冒泡算法</title>
      <link>https://sunnnner.github.io/p/python%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 08 Sep 2018 10:36:08 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95/</guid>
      <description> 1 2 3 4 5 6 7 冒泡 def damo(sun): for i in range(len(sun)-1): for j in range(len(sun)-i-1): if sun[j]&amp;gt; sun[j+1]: sun[j], sun[j+1] = sun[j+1], sun[j] return sun </description>
    </item>
    
    <item>
      <title>Python装饰器</title>
      <link>https://sunnnner.github.io/p/python%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
      <pubDate>Fri, 07 Sep 2018 10:35:21 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
      <description> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 装饰器 def demo(name): print(&amp;#39;demo--name&amp;#39;, name) def demo1(demo_name): print(&amp;#39;demo1--demoname&amp;#39;, demo_name.__name__) def demo2(): print(&amp;#39;demo--name&amp;#39;, name) demo_name() return demo2 return demo1 @demo(&amp;#39;zhuangshiqi&amp;#39;) def test(): print(&amp;#39;test&amp;#39;) test() </description>
    </item>
    
    <item>
      <title>Python工厂模式</title>
      <link>https://sunnnner.github.io/p/python%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 06 Sep 2018 10:34:03 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>介绍一下工厂模式 1 2 3 4 5 工厂模式是一个在软件开发中用来创建对象的设计模式。 工厂模式包涵一个超类。这个超类提供一个抽象化的接口来创建一个特定类型的对象，而不是决定哪个对象可以被创建。 当程序运行输入一个“类型”的时候，需要创建于此相应的对象。这就用到了工厂模式。在如此情形中，实现代码基于工厂模式，可以达到可扩展，可维护的代码。当增加一个新的类型，不在需要修改已存在的类，只增加能够产生新类型的子类。 简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。 封装函数，动态创建商品类 说说有哪些mvc模式的框架 1 2 3 Struts、Spring、ZF/.NET 耦合性低/重用性高/生命周期成本低/部署快/可维护性高/有利软件工程化管理 `` </description>
    </item>
    
    <item>
      <title>Python单例</title>
      <link>https://sunnnner.github.io/p/python%E5%8D%95%E4%BE%8B/</link>
      <pubDate>Wed, 05 Sep 2018 10:32:39 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E5%8D%95%E4%BE%8B/</guid>
      <description>举个常见的单例模式例子，我们日常使用的电脑上都有一个回收站，在整个操作系统中，回收站只能有一个实例，整个系统都使用这个唯一的实例，而且回收站自行提供自己的实例。因此回收站是单例模式的应用。
单例模式，是一种常用的软件设计模式。在它的核心结构中，只包含一个被称为单例的特殊类。
通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。
1 2 3 4 5 6 7 8 9 10 11 12 13 class A(object): # 定义类属性记录实例化对象 __instance = None # 创建实例对象的方法 def __new__(cls): # 如果没有创建实例对象就创建 if cls.__instance == None: cls.__instance = object.__new__(cls) return cls.__instance else: #如果存在就直接返回 return cls.__instance 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # 创建单例时，只执行1次__init__方法 class Singleton(object): # 定义雷属性记录实例化对象 __instance = None #创建市里的方法 def __new__(cls): if cls.</description>
    </item>
    
    <item>
      <title>Python多态</title>
      <link>https://sunnnner.github.io/p/python%E5%A4%9A%E6%80%81/</link>
      <pubDate>Tue, 04 Sep 2018 10:32:01 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E5%A4%9A%E6%80%81/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 对象的多种形态 比如说动物，动物分为很多种但是动物都会吃东西，但是动物吃的东西又不一样 # 有三种动物：狗、猫、猪， #	父类：动物、 #	子类：狗、猫、猪 可以添加子类自己的方法，自己扩展 #	动物的属性：动物的名字 #	动物的方法是eat（就是打印自己的名字） # 有一个饲养员：饲养员 #	饲养员的方法：feed_animal(需要饲养的动物) #	函数的实现是（其实就是调用动物的eat方法） class Animal(object): name=&amp;#34;动物&amp;#34; def eat(self): print(&amp;#34;%s会吃东西&amp;#34;%(self.name)) class Dog(Animal): def eat(self): print(&amp;#34;小狗吃骨头&amp;#34;) class Cat(Animal): def eat(self): print(&amp;#34;小猫爱吃鱼&amp;#34;) class Pig(Animal): def eat(self): print(&amp;#34;小猪不知道吃什么&amp;#34;) class Breeder(object): def feed_animal(self,animal): animal.</description>
    </item>
    
    <item>
      <title>Django定义USER四中方式</title>
      <link>https://sunnnner.github.io/p/django%E5%AE%9A%E4%B9%89user%E5%9B%9B%E4%B8%AD%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 03 Sep 2018 10:30:05 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/django%E5%AE%9A%E4%B9%89user%E5%9B%9B%E4%B8%AD%E6%96%B9%E5%BC%8F/</guid>
      <description>设计user models
django本身的auth_user 只包含了基本的信息包括用户名，密码，邮箱以及注册时间和最新的登录时间，但是这些字段很难满足我们的要求，有时我们想记录用户更多的信息，例如手机号等信息，这时就需要在auth_user 的基础上增加字段，django自定义User网上有四种方法。
是官网上推荐的方法，就是增加一个表auth_profile，其中以auth_user 表中的id作为Forgein Key将两个表过关联起来，这样可以在auth_profile 中增加多个用户的信息。
另外一种是修改django的源码，这种方法简单暴力直接，但是这种方法可移植性差，不利于多项目部署。
继承django auth/models 中的User继续增加字段，这种方法需要修改setting中的AUTH_USER_MODEL=‘app.User’ app为你自定义的app，INSTALLED_APP中要包含Contenttypes和auth两个app，class meta中 db_table 要指定为auth_user, 如果要在admin中管理用户的话，需要将app_label 进行指定。而且要在admin中重新定义UserAdmin 将新添加的字段写在list_display和add_fields中。详见django.contrib.auth.admin中。
重写User，也就是继承AbstractUser和Permissions两个类，其实django的User Model也是继承自这两个类，因此你可以做类似User的定义方法定义User。
记录是否执行了迁移文件靠的是django_migrations这表</description>
    </item>
    
    <item>
      <title>Celery任务队列</title>
      <link>https://sunnnner.github.io/p/celery%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/</link>
      <pubDate>Sun, 02 Sep 2018 10:29:21 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/celery%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/</guid>
      <description>celery 简介 任务队列 1 2 3 4 1.任务队列是一种在线程或机器间分发的任务的机制 2.消息队列的输入是工作的一个单元，称为任务，独立的职程（Worker）进程持续监视队列中是否有需要处理的新任务。 3.Celery 用消息通信，通常使用中间人（Broker）在客户端和职程间斡旋。这个过程从客户端向队列添加消息开始，之后中间人把消息派送给职程 4.Celery 系统可包含多个职程和中间人，以此获得高可用性和横向扩展能力。 </description>
    </item>
    
    <item>
      <title>缺少的知识</title>
      <link>https://sunnnner.github.io/p/%E7%BC%BA%E5%B0%91%E7%9A%84%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Sat, 01 Sep 2018 10:28:49 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E7%BC%BA%E5%B0%91%E7%9A%84%E7%9F%A5%E8%AF%86/</guid>
      <description> ISCSI相关操作 熟悉MVC，熟悉OOP，熟悉Python之外的其他OOP语言，Java者优先 rust go vue </description>
    </item>
    
    <item>
      <title>支付宝生成密匙步骤</title>
      <link>https://sunnnner.github.io/p/%E6%94%AF%E4%BB%98%E5%AE%9D%E7%94%9F%E6%88%90%E5%AF%86%E5%8C%99%E6%AD%A5%E9%AA%A4/</link>
      <pubDate>Tue, 05 Jun 2018 10:26:17 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E6%94%AF%E4%BB%98%E5%AE%9D%E7%94%9F%E6%88%90%E5%AF%86%E5%8C%99%E6%AD%A5%E9%AA%A4/</guid>
      <description>生成秘钥文件 1 2 3 4 openssl OpenSSL&amp;gt; genrsa -out app_private_key.pem 2048 # 私钥 OpenSSL&amp;gt; rsa -in app_private_key.pem -pubout -out app_public_key.pem # 导出公钥 OpenSSL&amp;gt; exit 设置支付宝沙箱公匙， 支付宝逐渐转换为RSA2密匙， 可以使用官方的工具生成
支付宝沙箱地址
生成RSA2教程
测试用秘钥 密码: rcip
设置本地公匙&amp;amp;私匙格式
1 2 3 4 5 6 7 8 9 10 11 12 app_private_key_string.pem -----BEGIN RSA PRIVATE KEY----- 私钥内容 -----END RSA PRIVATE KEY----- alipay_public_key_string.pem -----BEGIN PUBLIC KEY----- 公钥内容 -----END PUBLIC KEY----- </description>
    </item>
    
    <item>
      <title>修改hexo默认端口启动</title>
      <link>https://sunnnner.github.io/p/%E4%BF%AE%E6%94%B9hexo%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%90%AF%E5%8A%A8/</link>
      <pubDate>Mon, 04 Jun 2018 10:25:30 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E4%BF%AE%E6%94%B9hexo%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%90%AF%E5%8A%A8/</guid>
      <description>默认使用4000端口，用hexo s -p 80，可以暂时修改启动端口。
但是每次启动都要写”-p 80”才行，过于繁琐。
修改方法： 找到node_modules\hexo-server\index.js文件，可以修改默认的port值！</description>
    </item>
    
    <item>
      <title>Python基础</title>
      <link>https://sunnnner.github.io/p/python%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 03 Jun 2018 10:22:36 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/python%E5%9F%BA%E7%A1%80/</guid>
      <description>让python2支持中文 1 2 #coding=utf-8 #-*-coding:utf-8-*- 在页面头部写入 变量及数据类型 变量就是用来存东西的 程序就是用来处理数据的，而变量就是用来存储数据的 变量起名要有意义 数据类型 1 2 3 4 5 6 7 nnumber数字包括int long float complex(复数) bollernfalse true String list列表（数组） tuple元组 dictionary字典（对象） 可以用type()来查看变量数据类型 关键字 交换模式下使用import keyword- keyword.kwlist查看当前系统python的关键字 python2中使用raw_iput进行获取用户键盘数据它会把任何数据当作字符串来对待 python3中使用input来捕获用户键盘数据但是在python2中input输入的内容必须是表达式 输出 print 格式化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 %c代表字符 %s 通过str（）字符串转换来格式化 %i 有符号十进制整数 %d 有符号十进制整数 %u 无符号十进制整数 %o 八进制整数 %x 十六进制整数（小写字母） %X 十六进制整数（大写字母） %e 索引符号（小写e） %E 索引符号（大写E） %f 浮点实数 %g %f与%e 的简写 %G %F%E的简写 \n 换行输出 python算术运算符 +-*/ //（取整除） %求余 ** 幂 赋值运算 1 2 3 4 5 6 7 += -= *= /= %= **= 幂赋值运算符 //= 取整除赋值运算符 ==- while循环== 1 2 3 4 5 6 7 8 complex（）创建一个复数 eval（）运算python中有效表达式并返回一个对象 tuple（）将序列s转换为一个元组 list（）转换为列表 unichr()转换为Unicode字符 ord（）转换为它的整数值 hex() 将一个整数转换为一个十六进制的字符串 oct()将一个整数转换为一个八进制字符串 </description>
    </item>
    
    <item>
      <title>Ajax语法</title>
      <link>https://sunnnner.github.io/p/ajax%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Sat, 02 Jun 2018 10:21:32 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/ajax%E8%AF%AD%E6%B3%95/</guid>
      <description>Ajax语法 现在写ajax写的我很难受下面就是我在搜索的时候遇到的标签的意思 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $(&amp;#39;.show_prize&amp;#39;)获取为show_pirze的标签 .children（‘em’）获取子元素为em的标签 。text（）获取他的文本 .val() 获取他的值 parseInt 强制类型转换成整形 .toFixed(sun) 保留小数点后sun位 。click（）侦听点击事件 .blur()当输入域失去焦点 (blur .trim()去除两边空白 .each() 方法规定为每个匹配元素规定运行的函数 find() 方法获得当前元素集合中每个元素的后代，通过选择器、jQuery 对象或元素来筛选。 .find(&amp;#39;:checked&amp;#39;)获取type标签的属性必须用“：”来选择 $(&amp;#34;b&amp;#34;).parents()查找每个 b 元素的所有父元素 change事件改变 。prop() 方法设置或返回被选元素的属性和值。 .attr()attr() 方法设置或返回被选元素的属性值。 remove()移除对应的元素 $.ajaxSettings.async = true//设置异步 $.ajaxSettings.async = false;//设置同步 全选和全不选 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 $(&amp;#39;.</description>
    </item>
    
    <item>
      <title>Django Redis配置</title>
      <link>https://sunnnner.github.io/p/django-redis%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Fri, 01 Jun 2018 10:20:47 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/django-redis%E9%85%8D%E7%BD%AE/</guid>
      <description>Django-setting配置Redis储存session 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # redis配置 CACHES= { &amp;#39;default&amp;#39;:{ &amp;#34;BACKEND&amp;#34;: &amp;#39;django_redis.cache.RedisCache&amp;#39;, &amp;#34;LOCATION&amp;#34;: &amp;#34;redis://127.0.0.1:6379/2&amp;#34;, &amp;#34;OPTIONS&amp;#34;: { &amp;#34;CLIENT_CLASS&amp;#34;: &amp;#34;django_redis.client.DefaultClient&amp;#34;, &amp;#34;PASSWORD&amp;#34;: &amp;#34;&amp;#34;, } } } # 储存session设置 SESSION_ENGING = &amp;#34;django.contrib.session.backends.cache&amp;#34; SESSION_CACHE_ALIAS = &amp;#34;default&amp;#34; </description>
    </item>
    
    <item>
      <title>Django用户模块</title>
      <link>https://sunnnner.github.io/p/django%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Fri, 01 Jun 2018 10:15:16 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/django%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9D%97/</guid>
      <description>第一步创建Django项目 django-admin startproject blog 创建第一个应用user python manage.py startapp user 设置setting文件 1 2 ALLOWED_HOSTS=[“*”]//更改为所有都可以访问上线模式 INSTALLEN_APPS—》加入第一个user应用 创建templates文件夹 并设置TEMPLATES里面文件夹的路径os.path.join 设置DATABASES的储存为mysql 1 2 3 4 5 6 7 8 9 10 11 字段 DATABASES = { &amp;#39;default&amp;#39;: { &amp;#39;ENGINE&amp;#39;: &amp;#39;django.db.backends.mysql&amp;#39;, &amp;#39;NAME&amp;#39;: &amp;#39;bookstore&amp;#39;, &amp;#39;USER&amp;#39;:&amp;#39;root&amp;#39;, &amp;#39;PASSWORD&amp;#39;:&amp;#39;123&amp;#39;, &amp;#39;HOST&amp;#39;:&amp;#39;localhost&amp;#39;, &amp;#39;PORT&amp;#39;:3306, } } 修改语言与时区 1 2 3 LANGUAGE_CODE = &amp;#39;zh-Hans&amp;#39; TIME_ZONE = &amp;#39;Asia/Shanghai&amp;#39; 设置静态文件收集static文件夹并在setting设置 1 2 3 4 STATIC_URL = &amp;#39;/static/&amp;#39; STATICFILES_DIRS = [ os.path.join(BASE_DIR, &amp;#39;static&amp;#39;) ] 设置主页url与视图函数 1 2 3 url(r&amp;#39;^$&amp;#39;,index,name=&amp;#39;index&amp;#39;) def index(request): return render(request, &amp;#39;index.</description>
    </item>
    
    <item>
      <title>Redis配置</title>
      <link>https://sunnnner.github.io/p/redis%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Thu, 31 May 2018 18:53:17 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/redis%E9%85%8D%E7%BD%AE/</guid>
      <description> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 1) 绑定IP地址,看业务开放 bind 0.0.0.0 2)Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程，设置为no daemonize no 3)保护模式 protected-mode no # 检查启动状态命令 ps -ef|grep redis |grep 6379 mac以配置文件启动 sudo redis-server /usr/local/etc/redis.conf Ubuntu以配置文件启动 sudo redis-server /etc/redis/redis.conf </description>
    </item>
    
    <item>
      <title>怎么加快页面的访问速度</title>
      <link>https://sunnnner.github.io/p/%E6%80%8E%E4%B9%88%E5%8A%A0%E5%BF%AB%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/</link>
      <pubDate>Thu, 31 May 2018 18:47:29 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E6%80%8E%E4%B9%88%E5%8A%A0%E5%BF%AB%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/</guid>
      <description>··· 我理解是压缩代码然后减少请求，多使用ajax 图片存第三方资源库
全静态，读写分离，加带宽 再开cdn</description>
    </item>
    
    <item>
      <title>页面开发</title>
      <link>https://sunnnner.github.io/p/%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91/</link>
      <pubDate>Thu, 31 May 2018 18:47:29 +0800</pubDate>
      
      <guid>https://sunnnner.github.io/p/%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91/</guid>
      <description>首先新建app—&amp;gt;books并添加settings里面 因为我们需要在后台admin上传数据所以我们要创建富文本管理器并在setting设置他的选项 富文本管理器是一个插件我们这次使用的是tinymce并且我们需要将它加入到apps里面因为他是一个应用，但是这个应用是需要下载的 1 2 3 4 5 TINTMCE_DEFAULT_CONFIG = { &amp;#39;theme&amp;#39;: &amp;#34;modern&amp;#34;, &amp;#39;wight&amp;#39;: 600, &amp;#39;height&amp;#39;: 400, } 我们需要设置制定一个媒体文件夹来存放我们的图片MEDIA_ROOT = os.path.join(BASE_DIR, &#39;static&#39;)
添加应用的urls``
1 2 url(r&amp;#39;^books/&amp;#39;, include(&amp;#39;books.urls&amp;#39;,namespace=&amp;#39;books&amp;#39;)), url(r&amp;#39;^tinymce/&amp;#39;, include(&amp;#39;tinymce.urls&amp;#39;,namespace=&amp;#39;tinymce&amp;#39;)), 我们开始写books里面的字段首先查看页面我们需要什么字段 首先我们创建tinymac富文本需要的字段，这里的字段映射全局 在books目录下创建任意的.py文件这里我的是emums.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 此处1，2，3，4代表书本的id PYTHON = 1 JAVASCRIPT = 2 ALGORITHMS = 3 MACHINELEARNING = 4 OPERATINSGYSTEM = 5 DATABASE = 6 # BOOKS_TYPE作为一个字典传输到models BOOKS_TYPE = { PYTHON: &amp;#39;python&amp;#39;, JAVASCRIPT: &amp;#39;javascript&amp;#39;, ALGORITHMS: &amp;#39;数据库结构与算法&amp;#39;, MACHINELEARNING: &amp;#39;机器学习&amp;#39;, OPERATINSGYSTEM: &amp;#39;操作系统&amp;#39;, DATABASE: &amp;#39;数据库&amp;#39;, } # 代表商品的上线或者下线状态 OFFLINE = 0 ONLINE = 1 STATUS_CHOICE = { OFFLINE: &amp;#39;下线&amp;#39;, ONLINE: &amp;#39;上线&amp;#39;, } 我们开始写models.</description>
    </item>
    
  </channel>
</rss>
