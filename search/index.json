[{"content":"2-1 套接字。面向连接的套接字和无连接套接字之间的区别是什么？\n   面向连接的套接字 无连接的套接字     在通信之前必须建立连接 在通信之前不需要建立连接   序列化的，可靠的不重复的数据交付 无法保证顺序性，可靠性或重复性，减少以一定的开销   没有记录边界 保存了记录边界   每条信息可以拆分成多个片段，并且每一个消息片段都能确保到达目的地，然后将他么按顺序组合在一起。 消息是以整体发送的。   传输控制协议(TCP) 用户数据协议(UDP)    2-2 客户端/服务器架构。用自己的话描述这个术语的意思，并给出几个例子。 1、服务器就是一系列硬件或软件，为一个或多个客户端（服务的用户）提供所需的“服务”。其存在的目的就是等待客户端的请求，并响应他们（提供服务），然后等待更多的请求。\n2-3 套接字。 TCP 和 UDP 之中，哪种类型的服务器接受连接，并将它们转换到独立的 套接字进行客户端通信？ tcp\n2-4 客户端。更新 TCP（tsTclnt.py）和 UDP（tsUclnt.py）客户端，以使得服务器名称 无须硬编码到应用程序中。此外，应该允许用户指定主机名和端口号，且如果二者 中任何一个或者全部参数丢失，那么应该使用默认值。\n1 2 3 4 5 6 7 8 9  import sys, argparse if __name__ == \u0026#34;__main__\u0026#34;: parser = argparse.ArgumentParser(description=\u0026#34;pls write host port\u0026#34;) parser.add_argument(\u0026#34;--host\u0026#34;, type=str, default=\u0026#39;localhost\u0026#39;) parser.add_argument(\u0026#34;--port\u0026#34;, type=int, default=8000) args = parser.parse_args() host = args.host port = args.port print(args.host, args.port)   2-6 Daytime 服务。使用 socket.getservbyname()来确定使用 UDP 协议的“daytime”服 务的端口号。检查 getservbyname()的文档以获得其准确的使用语法（即 socket. getservbyname._ doc_）。那么，现在编写一个应用程序，使该应用程序能够通过网 络发送一条虚拟消息，然后等待服务器回复。一旦你收到服务器的回复，就将其显 示到屏幕上。\n2-7 半双工聊天。创建一个简单的半双工聊天程序。指定半双工，我们的意思就是，当建 立一个连接且服务开始后，只有一个人能打字，而另一个参与者在得到输入消息提示 之前必须等待消息。并且，一旦发送者发送了一条消息，在他能够再次发送消息之前， 必须等待对方回复。其中，一位参与者将在服务器一侧，而另一位在客户端一侧。\n2-8 全双工聊天。更新上一个练习的解决方案，修改它以使你的聊天服务现在成为全双 工模式，意味着通信两端都可以发送并接收消息，并且二者相互独立。\n2-9 多用户全双工聊天。进一步修改你的解决方案，以使你的聊天服务支持多用户。\n2-10 多用户、多房间、全双工聊天。现在让你的聊天服务支持多用户和多房间功能。\n2-11 Web 客户端。编写一个 TCP 客户端，使其连接到你最喜欢的网站（删除“http://”和 任何后续信息；只使用主机名）的 80 端口。一旦建立一个连接，就发送 HTTP 命令 字符串 GET / \\n，并将服务器返回的所有数据写入一个文件中（GET 命令会检索一个 本文档由Linux公社 www.linuxidc.com 收集整理 72 第 1 部分 通用应用主题 Web 页面， /file 表明要获取的文件， \\n 将命令发送到服务器）。检查检索到的文件的内 容。内容是什么？你如何检查能确保所接收到的数据是正确的？（注意：你可能必须 在命令字符串后面插入一个或两个换行符，通常一个就能正常工作）\n2-12 睡眠服务器。创建一个睡眠服务器。客户端将请求一段时间之后进入睡眠状态。 服务器将代表客户端发送命令，然后向客户端返回一条表明成功的消息。客户端应 该睡眠或空闲所请求的时间长度。这是一个远程过程调用的简单实现，此过程中一 个客户端的请求会通过网络调用另一台计算机上的命令。\n2-13 名称服务器。设计并实现一个名称服务器。该服务器负责维护一个包含主机名-端 口号对的数据库，也许还有对应服务器所提供的服务的字符串描述。针对一个或多 个现有的服务器，注册它们的服务到你的名称服务器中（注意，在这种情况下，这 些服务器是名称服务器的客户端）。 每个启动的客户端都不知道它们所寻找的服务器地址。同样地，对于名称服务器的 客户端来说，这些客户端应该发送一个请求到名称服务器，以指示它们正在寻找什 么类型的服务。作为回复，名称服务器会向该客户端返回一个主机名-端口号对， 然后该客户端就可以连接到适当的服务器来处理它的请求。 选做题： 1）为名称服务器添加缓存流行请求的功能。 2）为你的名称服务器添加日志记录功能，跟踪哪些服务器注册了名称服务器，以 及客户端正在请求哪些服务。 3） 你的名称服务器应该定期通过相应的端口号 ping 已经注册的主机，以确保它们 的服务确实处于开启状态。反复的失败将会导致名称服务器将其从服务列表中划去。 你可以为那些注册了名称服务器的服务器实现真正的服务，或者仅仅使用虚拟服务 器（仅仅应答一个请求）。\n2-14 错误检查和优雅的关闭。本章所有的客户端/服务器示例代码都缺乏错误检查功 能。我们并没有处理以下几种场景，例如，用户按Ctrl+C快捷键退出服务器或Ctrl+D 快捷键终止客户端输入，也没有检查其他对 raw_input()的不适当输入或处理网络错 误。因为这个缺陷，经常我们终止一个应用程序时并没有关闭套接字，很可能会导 致丢失数据。本练习中，在示例中选择一对客户端/服务器程序，并添加足够的错 误检查，这样每个应用程序就能正确地关闭，即关闭网络连接。\n2-15 异步性和 SocketServer/socketserver。使用 TCP 服务器的示例，并使用其中一个 mix-in 类来支持一个异步服务器。为了测试你的服务器，同时创建并运行多个客户 端，并交叉显示你的服务器满足二者中请求的输出。\n2-16 *扩展 SocketServer 类。在 SocketServer TCP 服务器代码中，我们不得不从原始 的基础 TCP 客户端中修改客户端，因为 SocketServer 类没有维护多个请求之间 的连接。 a）继承 TCPServer 和 StreamRequestHandler 类并重新设计服务器，使其能够为每个客户 端维持并使用单个连接（而不是每个请求一个连接）。 b）将前面练习的解决方案集成到（ a）部分中的方案中，这样就可以并行为多个客户端 提供服务。\n2-17 *异步系统。研究至少 5 个基于 Python 的不同异步系统，可以从 Twisted、 Greenlets、 Tornado、 Diesel、 Concurrence、 Eventlet、 Gevent 等中选择。描述它们是什么，对 它们进行分类，并找到它们之间的相似点和差异性，然后创建一些演示代码示例\n","date":"2022-03-10T15:46:40+08:00","permalink":"https://sunnnner.github.io/p/pysocket/","title":"Pysocket"},{"content":" python3 中迭代器方法next()已经改变为__next__()  ","date":"2022-03-08T11:06:40+08:00","permalink":"https://sunnnner.github.io/p/djangoupgrade/","title":"Djangoupgrade"},{"content":"  小记在mac上使用vscode导入redis包失效问题\n  解决办法\n  1 2 3 4 5 6 7 8 9 10 11 12 13  vim .bash_profile # 环境变量导入当前工作目录 export GOPATH=/Users/xxx/Desktop/go-project cd /Users/xxx/Desktop/go-project go mod init example.com/m/v2 # 自动下载所需的包 go mod tidy # 项目源代码放置处 mkdir src cd src # 可以开始编写了   ","date":"2021-08-26T10:48:36+08:00","permalink":"https://sunnnner.github.io/p/go%E5%AF%BC%E5%85%A5%E5%A4%96%E9%83%A8%E5%8C%85%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/","title":"Go导入外部包失效问题"},{"content":" is_staff bool 指定此用户是否可以访问管理站点 控制用户操作admin的权限由 django.contrib.auth.backends.ModelBackend 进行控制，它也进行控制用户的登录认证行为 ModelBackend源码解析  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107  class ModelBackend: \u0026#34;\u0026#34;\u0026#34; Authenticates against settings.AUTH_USER_MODEL. \u0026#34;\u0026#34;\u0026#34; # 控制用户登录认证 通过重写此方法进行自定义登录认证 def authenticate(self, request, username=None, password=None, **kwargs): if username is None: username = kwargs.get(UserModel.USERNAME_FIELD) try: user = UserModel._default_manager.get_by_natural_key(username) except UserModel.DoesNotExist: # Run the default password hasher once to reduce the timing # difference between an existing and a nonexistent user (#20760). UserModel().set_password(password) else: if user.check_password(password) and self.user_can_authenticate(user): return user # 查看用户是否为可用状态 def user_can_authenticate(self, user): \u0026#34;\u0026#34;\u0026#34; Reject users with is_active=False. Custom user models that don\u0026#39;t have that attribute are allowed. \u0026#34;\u0026#34;\u0026#34; is_active = getattr(user, \u0026#39;is_active\u0026#39;, None) return is_active or is_active is None # 获取用户的permission列表 def _get_user_permissions(self, user_obj): return user_obj.user_permissions.all() # 获取用户的组权限列表 def _get_group_permissions(self, user_obj): user_groups_field = get_user_model()._meta.get_field(\u0026#39;groups\u0026#39;) user_groups_query = \u0026#39;group__%s\u0026#39; % user_groups_field.related_query_name() return Permission.objects.filter(**{user_groups_query: user_obj}) # 获取权限列表 def _get_permissions(self, user_obj, obj, from_name): \u0026#34;\u0026#34;\u0026#34; Return the permissions of `user_obj` from `from_name`. `from_name` can be either \u0026#34;group\u0026#34; or \u0026#34;user\u0026#34; to return permissions from `_get_group_permissions` or `_get_user_permissions` respectively. \u0026#34;\u0026#34;\u0026#34; if not user_obj.is_active or user_obj.is_anonymous or obj is not None: return set() perm_cache_name = \u0026#39;_%s_perm_cache\u0026#39; % from_name if not hasattr(user_obj, perm_cache_name): if user_obj.is_superuser: perms = Permission.objects.all() else: perms = getattr(self, \u0026#39;_get_%s_permissions\u0026#39; % from_name)(user_obj) perms = perms.values_list(\u0026#39;content_type__app_label\u0026#39;, \u0026#39;codename\u0026#39;).order_by() setattr(user_obj, perm_cache_name, {\u0026#34;%s.%s\u0026#34; % (ct, name) for ct, name in perms}) return getattr(user_obj, perm_cache_name) # 获取用户权限列表 def get_user_permissions(self, user_obj, obj=None): \u0026#34;\u0026#34;\u0026#34; Return a set of permission strings the user `user_obj` has from their `user_permissions`. \u0026#34;\u0026#34;\u0026#34; return self._get_permissions(user_obj, obj, \u0026#39;user\u0026#39;) # 获取组列表 def get_group_permissions(self, user_obj, obj=None): \u0026#34;\u0026#34;\u0026#34; Return a set of permission strings the user `user_obj` has from the groups they belong. \u0026#34;\u0026#34;\u0026#34; return self._get_permissions(user_obj, obj, \u0026#39;group\u0026#39;) # 获取用户所有的权限列表 def get_all_permissions(self, user_obj, obj=None): if not user_obj.is_active or user_obj.is_anonymous or obj is not None: return set() if not hasattr(user_obj, \u0026#39;_perm_cache\u0026#39;): user_obj._perm_cache = { *self.get_user_permissions(user_obj), *self.get_group_permissions(user_obj), } return user_obj._perm_cache # 判断是否具有权限 def has_perm(self, user_obj, perm, obj=None): return user_obj.is_active and perm in self.get_all_permissions(user_obj, obj) # 返回某个model访问权限(True or False) def has_module_perms(self, user_obj, app_label): \u0026#34;\u0026#34;\u0026#34; Return True if user_obj has any permissions in the given app_label. \u0026#34;\u0026#34;\u0026#34; return user_obj.is_active and any( perm[:perm.index(\u0026#39;.\u0026#39;)] == app_label for perm in self.get_all_permissions(user_obj) ) # 得到用户实例 (通过重写此方法或得自定义用户实例) def get_user(self, user_id): try: user = UserModel._default_manager.get(pk=user_id) except UserModel.DoesNotExist: return None return user if self.user_can_authenticate(user) else None    重写示例  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class xxxBackend(ModelBackend): def authenticate(self, request, username=None, password=None, **kwargs): try: user = UserModel.objects.get(Q(username=username) | Q(phone=username)) if user.check_password(password): return user return None except UserModel.DoesNotExist: return None except MultipleObjectsReturned: return None def get_user(self, user_id): try: return UserModel.objects.get(pk=user_id) except UserModel.DoesNotExist: return None   ","date":"2021-08-24T09:26:52+08:00","permalink":"https://sunnnner.github.io/p/django-admin-permissions%E6%8E%A7%E5%88%B6/","title":"Django Admin Permissions控制"},{"content":"高级语言源程序内部的几个概念  token、关键字、标识符、操作符、分隔符和字面量  token   token 是构成源程序的基本不可再分割的单元，编译器编译程序的第一步就是将源程序分割为一个个独立的token，这个过程就是词法分析\n  go语言的token可以分为关键字、标识符、操作符、分隔符和字面常量等\n  ","date":"2021-08-17T10:10:49+08:00","permalink":"https://sunnnner.github.io/p/go%E8%AF%8D%E6%B3%95%E5%8D%95%E5%85%83/","title":"Go词法单元"},{"content":" annotate 聚合操作 有 Max Sum Count一些参数使用 =相当于sql中的as 如果想要查询的时候更换变量名称使用extra(select={\u0026quot;change_file\u0026quot;: \u0026quot;model_file\u0026quot;}) 相当于 sql 中的as sql中order by分组在orm使用values进行表达 示例  1 2 3  # 按照各个省事进行聚合数量 DemoModel.objects.filter(test=xxx).extra(select={\u0026#39;position\u0026#39;: city}).\\ values(\u0026#34;position\u0026#34;, \u0026#34;location\u0026#34;).annotate(count=Count(city))   ","date":"2021-08-12T16:19:36+08:00","permalink":"https://sunnnner.github.io/p/django-orm%E8%81%9A%E5%90%88%E5%88%86%E7%BB%84%E7%9F%A5%E8%AF%86/","title":"Django Orm聚合分组知识"},{"content":"ubuntu20.04 LTS编译 python3.7.1 安装编译前依赖包  sudo apt-get install -y build-essential libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev zlib1g-dev gcc make   编译前配置   sudo ./configure --enable-optimizations --prefix=/usr/local/bin/python3.7\n  \u0026ndash;prefix指定安装位置\n  编译安装   make\n  sudo make install\n  安装virtualenv虚拟环境来管理python版本  sudo apt install python3-pip pip install virtualenv pip install virtualenvwrapper mkdir .virtualenvs  vim .zhsrc 1 2 3 4  export WORKON_HOME=$HOME/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3 export VIRTUALENVWRAPPER_VIRTUALENV=~/.local/bin/virtualenv source ~/.local/bin/virtualenvwrapper.sh    source .zshrc  创建python3.7虚拟环境  mkvirtualenv -p mkvirtualenv -p /usr/local/bin/python3.7/bin/python3.7 py3.7  ","date":"2021-08-06T19:29:05+08:00","permalink":"https://sunnnner.github.io/p/ubuntu20.04-lts%E7%BC%96%E8%AF%91python3.7/","title":"Ubuntu20.04 LTS编译python3.7"},{"content":"派生 包括： 指针类型(Pointer) 数组类型  结构化类型(struct) Channel类型 函数类型 切片类型 接口类型(interface) Map类型  浮点型 float32与float64 complex64与complex128 64位的实数与虚数  其他数字类型 byte 类似uint8 rune 类似int32 uint 32或者64位 int 与uint一样大 uintptr 无符号整型，用于存放一个指针 ","date":"2020-02-02T15:52:00+08:00","permalink":"https://sunnnner.github.io/p/go%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"Go语言数据类型"},{"content":"Go关键字    关键字 意义     break 退出   default 默认函数   func 定义函数和方法   interface 用于定义接口   select 用于选择不同类型的通讯   case 用户条件选择   defer 延迟执行内容（收尾工作）有点类似C++的析构，但是它是再函数结尾的时候去执行（也就是栈即将被释放的时候）   go 用于并发   map 用于声明map类型数据   struct 用于定义抽象数据类型   range 用于读取slice、map、channel数据   chan 用于channel通讯   if 选择结构-如果   else 选择结构-否则   type 用于声明自定义类型   return 用于从函数返回   var Go语言基础里面的变量和常量申明 (var age int)   const 变量和常量的声明   package 包管理   import 导入   switch 选择结构   fallthrough 流程控制1.加了fallthrough后，会直接运行【紧跟的后一个】case或default语句，不论条件是否满足都会执行)2.加了fallthrough语句后，【紧跟的后一个】case条件不能定义常量和变量3.执行完fallthrough后直接跳到下一个条件语句，本条件执行语句后面的语句不执行   continue 跳过本次循环   for 循环   goto 跳转语句    36个预定义标识符    内建常量 内建类型 内建函数     true int make   false int8 len   iota int16 cap   nil int32 new   - int64 append   - uint copy   - uint8 close   - uint16 delete   - uint32 complex   - uint64 real   - uintprt imag   - float32 panic   - float64 recover   - complex64 -   - complex128 -   - bool -   - byte -   - rune -   - string -   - error -    ","date":"2020-02-01T15:45:32+08:00","permalink":"https://sunnnner.github.io/p/go%E5%AD%A6%E4%B9%A0/","title":"Go学习"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12  if cat xxx.yml | grep \u0026#34;content\u0026#34;\u0026gt;/dev/null then return 1 else return 0 fi   ","date":"2020-01-01T15:45:01+08:00","permalink":"https://sunnnner.github.io/p/shell-%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Shell 判断文件中是否存在字符串"},{"content":" 秒数是相对于1970.1.1号的秒数 日期的模块有time、datetime  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import datetime t = datetime.datetime(2009, 10, 21, 0, 0, 10, 10) # 分别是年份、月份、日、小时、分钟、秒、微妙(10-6秒) print (t-datetime.datetime(1970,1,1)).total_seconds() # 总共多少秒 import datetime, time t = datetime.datetime(2011, 10, 21, 0, 0) time.mktime(t.timetuple()) 1319148000.0 string转datetime str = \u0026#39;2012-11-19\u0026#39; date_time = datetime.datetime.strptime(str,\u0026#39;%Y-%m-%d\u0026#39;) datetime.datetime(2012,11,19,0,0) datetime转string date_time.strftime(\u0026#39;%Y-%m-%d\u0026#39;) \u0026#39;2012-11-19\u0026#39;   datetime转时间戳 time_time = time.mktime(date_time.timetuple())\n时间戳转string  time.strftime('%Y-%m-%d',time.localtime(time_time)) \u0026lsquo;2012-11-19\u0026rsquo;  date转datetime 1 2 3 4 5 6 7 8 9  date = datetime.date.today() date datetime.date(2012,11,19) datetime.datetime.strptime(str(date),\u0026#39;%Y-%m-%d\u0026#39;) #将date转换为str，在由str转换为datetime datetime.datetime(2012,11,19,0,0)   ","date":"2019-12-10T15:43:08+08:00","permalink":"https://sunnnner.github.io/p/python%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2/","title":"Python日期转换"},{"content":"logging.basicConfig函数  logging模块是Python内置标准模块，主要用于输出运行日志，可以设置输出日志的等级、日志保存路径，日志文件回滚等  ##相比Print优点：\n 可以通过设置不同的日志等级，在release版本中只输出重要信息，而不必显示大量的调试信息； print将所有信息都输出到标准输出中，严重影响开发者从标准输出中查看其它数据；logging则可以由开发者决定将信息输出到什么地方，以及怎么输出； 在python中，logging由logger，handler，filter，formater四个部分组成： logger是提供我们记录日志的方法；handler是让我们选择日志的输出地方，如：控制台，文件，邮件发送等，一个logger添加多个handler；filter是给用户提供更加细粒度的控制日志的输出内容；formater用户格式化输出日志的信息。  python中配置logging有三种方式 第一种：基础配置， 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  logging.basicConfig( filename=\u0026#34;config.log\u0026#34;, filemode=\u0026#34;w\u0026#34;, format=\u0026#34;%(asctime)s-%(name)s-%(levelname)s-%(message)s\u0026#34;, level=logging.INFO) 第二种：使用配置文件的方式配置logging,使用`fileConfig函数来读取配置文件 fileConfig( filename, defaults=None, disable_existing_loggers=Ture )` 第三种：使用一个字典方式来写配置信息，然后使用dictConfig dictConfig( dict, defaults=None, disable_existing_loggers=Ture )   日志Level等级  日志一共分成5个等级，从低到高分别是：DEBUG ,INFO ,WARNING ,ERROR, CRITICAL。 DEBUG：详细的信息,通常只出现在诊断问题上 INFO：确认一切按预期运行 WARNING：一个迹象表明,一些意想不到的事情发生了,或表明一些问题在不久的将来(例如。磁盘空间低”)。这个软件还能按预期工作。 ERROR：更严重的问题,软件没能执行一些功能 CRITICAL：一个严重的错误,这表明程序本身可能无法继续运行 这5个等级，也分别对应5种打日志的方法： debug 、info 、warning 、error、critical。默认的是WARNING，当在WARNING或之上时才被跟踪。  二、日志输出：可以输出在控制台和文件，我选择的是输出在文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  StreamHandler：logging.StreamHandler；日志输出到流，可以是sys.stderr，sys.stdout或者文件 FileHandler：logging.FileHandler；日志输出到文件 BaseRotatingHandler：logging.handlers.BaseRotatingHandler；基本的日志回滚方式 RotatingHandler：logging.handlers.RotatingHandler；日志回滚方式，支持日志文件最大数量和日志文件回滚 日志回滚的意思为：比如日志文件是chat.log，当chat.log达到指定的大小之后，RotatingFileHandler自动把文件改名为chat.log.1。不过，如果chat.log.1已经存在，会先把chat.log.1重命名为chat.log.2。最后重新创建 chat.log，继续输出日志信息。【这样保证了chat.log里面是最新的日志】 TimeRotatingHandler：logging.handlers.TimeRotatingHandler；日志回滚方式，在一定时间区域内回滚日志文件 SocketHandler：logging.handlers.SocketHandler；远程输出日志到TCP/IP sockets DatagramHandler：logging.handlers.DatagramHandler；远程输出日志到UDP sockets SMTPHandler：logging.handlers.SMTPHandler；远程输出日志到邮件地址 SysLogHandler：logging.handlers.SysLogHandler；日志输出到syslog NTEventLogHandler：logging.handlers.NTEventLogHandler；远程输出日志到Windows NT/2000/XP的事件日志 MemoryHandler：logging.handlers.MemoryHandler；日志输出到内存中的指定buffer HTTPHandler：logging.handlers.HTTPHandler；通过”GET”或者”POST”远程输出到HTTP服务器   三、日志格式说明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  logging.basicConfig函数中，可以指定日志的输出格式format，这个参数可以输出很多有用的信息 logging.basicConfig函数各参数: filename: 指定日志文件名 filemode: 和file函数意义相同，指定日志文件的打开模式，\u0026#39;w\u0026#39;或\u0026#39;a\u0026#39; format: 指定输出的格式和内容，format可以输出很多有用信息，如上例所示: %(levelno)s: 打印日志级别的数值 %(levelname)s: 打印日志级别名称 %(pathname)s: 打印当前执行程序的路径，其实就是sys.argv[0] %(filename)s: 打印当前执行程序名 %(funcName)s: 打印日志的当前函数 %(lineno)d: 打印日志的当前行号 %(asctime)s: 打印日志的时间 %(thread)d: 打印线程ID %(threadName)s: 打印线程名称 %(process)d: 打印进程ID %(message)s: 打印日志信息 datefmt: 指定时间格式，同time.strftime() level: 设置日志级别，默认为logging.WARNING stream: 指定将日志的输出流，可以指定输出到sys.stderr,sys.stdout或者文件，默认输出到sys.stderr，当stream和filename同时指定时，stream被忽略 logging打印信息函数： logging.debug(\u0026#39;This is debug message\u0026#39;) logging.info(\u0026#39;This is info message\u0026#39;) logging.warning(\u0026#39;This is warning message\u0026#39;)   初始化日志对象 1 2 3 4 5 6 7 8 9 10 11 12 13  logging.basicConfig( # 日志级别 level = logging.INFO, # 日志格式 # 时间、代码所在文件名、代码行号、日志级别名字、日志信息 format = \u0026#39;%(asctime)s%(filename)s[line:%(lineno)d] %(levelname)s%(message)s\u0026#39;, # 打印日志的时间 datefmt = \u0026#39;%a, %d%b %Y %H:%M:%S\u0026#39;, # 日志文件存放的目录（目录必须存在）及日志文件名 filename = \u0026#39;d:/report.log\u0026#39;, # 打开日志文件的方式 filemode = \u0026#39;w\u0026#39; )   ","date":"2019-12-05T15:40:17+08:00","permalink":"https://sunnnner.github.io/p/log-basicconfig%E5%87%BD%E6%95%B0/","title":"Log BasicConfig函数"},{"content":" python divmod()把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。  1 2 3 4  \u0026gt;\u0026gt;\u0026gt; divmod(3600, 60) (60, 0) \u0026gt;\u0026gt;\u0026gt; divmod(3500, 60) (58, 20)   ","date":"2019-12-01T15:39:29+08:00","permalink":"https://sunnnner.github.io/p/divmod%E5%87%BD%E6%95%B0/","title":"Divmod函数"},{"content":"curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube_1.5.2.deb \\ \u0026amp;\u0026amp; sudo dpkg -i minikube_1.5.2.deb\n系统管理程序设置验证系统是否启用虚拟化 egrep -q \u0026lsquo;vmx|svm\u0026rsquo; /proc/cpuinfo \u0026amp;\u0026amp; echo yes || echo no 如果启用则需要关闭虚拟化\nminikube servion查看版本信息\nminikube start启动\n查看集群信息kubectl cluster-info\n","date":"2019-11-11T15:38:29+08:00","permalink":"https://sunnnner.github.io/p/%E4%BD%BF%E7%94%A8minikube%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4/","title":"使用minikube创建集群"},{"content":"安装postgres sudo apt install postgresql postgresql-contrib\n安装完成后，PostgreSQL服务将自动启动。 要验证安装，我们将使用psql实用程序连接到PostgreSQL数据库服务器并打印服务器版本：sudo -u postgres psql -c \u0026ldquo;SELECT version();\u0026rdquo;\n安装完毕后，系统会创建一个数据库超级用户 postgres，密码为空。\n切换到postgres用户sudo -i -u postgres\n执行psql进入postgres shell 执行\\password postgres修改默认密码\n修改/etc/postgresql/9.6/main下 postgresql.conf里面listen address为*\n修改pg_hba.conf all 地址为0.0.0.0/0\n重启sudo /etc/init.d/postgresql restart\n","date":"2019-11-04T15:37:26+08:00","permalink":"https://sunnnner.github.io/p/install-postgresql/","title":"Install Postgresql"},{"content":"博主使用的cloudflare的cdn之前查了很久不清楚怎么使用github-page的https， 因github与Let’s Encrypt 合作提供自带cdn所以我们来配置一下， 首先关闭自定义域名的cdn服务其实就是关了他的域名解析\n首先我们看域名还是active状态\n其次我们关闭cloudflare站点cdn\n查看站点状态\n添加对github-Page的解析记录\n如果github-Page你的Custom domain上已经填写了自定义域名，删除掉域名保存一下，随后再次输入一次保存你会看到你的https已经开启了\n","date":"2019-11-03T15:36:46+08:00","permalink":"https://sunnnner.github.io/p/github-page%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFhttps/","title":"Github Page自定义域名开启https"},{"content":"k8s获取所有运行的podskubectl get pods \u0026ndash;all-namespaces -o wide\n获取当前集群名称kubectl get pods -o wide\n当前etcd中的注册的宿主机的pod地址网段信息etcdctl ls /kube-centos/network/subnets\n而每个node上的Pod子网是根据我们在安装flannel时配置来划分的，在etcd中查看该配置etcdctl get /kube-centos/network/config\n","date":"2019-11-02T15:36:16+08:00","permalink":"https://sunnnner.github.io/p/k8s%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/","title":"K8s基础操作"},{"content":" 首先使用root权限账户登录系统 首先查看用户组中有没有docker组sudo cat /etc/group | grep docker  创建docker分组，并将相应的用户添加到这个分组里面\nsudo groupadd -g 999 docker\n-g 999为组ID 也可以不指定\nsudo usermod -aG dockerroot username\nsudo usermod -aG docker username\n检查一下是否有效 cat /etc/group\n用户退出登录或者重启docker-daemon使权限生效\nsudo systemctl restart docker\n运行docker info查看是否生效\n如果提示get权限不足，修改/var/run/docker.sock权限即可\nsudo chmod a+rw /var/run/docker.sock\n","date":"2019-11-01T15:35:30+08:00","permalink":"https://sunnnner.github.io/p/docker%E6%B7%BB%E5%8A%A0root%E6%9D%83%E9%99%90%E7%9C%81%E5%8E%BBsudo/","title":"Docker添加root权限省去sudo"},{"content":" duque函数有一个maxlen参数，当append的时候，如果超过，那么最前面的就会被挤出队列  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  from collections import duque def search(lines, pattern, lens=5): previous_lines = deque(maxlen=lens) for li in lines: if pattern in li: yield li, previous_lines previous_lines.append(li) if name == ‘main‘: with open(r’./xx.txt’) as f: for line, prevlines in search(f, ‘python’, 5): for pline in prevlines: print(pline, end=’’) print(line, end=’’) print(‘**’ * 20)   ","date":"2019-10-15T15:33:37+08:00","permalink":"https://sunnnner.github.io/p/python-collections-duque%E5%87%BD%E6%95%B0%E6%BC%94%E7%A4%BA/","title":"Python Collections Duque函数演示"},{"content":"##描述\ngetattr() 函数用于返回一个对象属性值。\n语法 getattr 语法：\ngetattr(object, name, [default])\n参数 object – 对象。 name – 字符串，对象属性。 default – 默认返回值，如果不提供该参数，在没有对应属性时，将触发 AttributeError。\n返回值 返回对象属性值。  ","date":"2019-10-14T15:31:31+08:00","permalink":"https://sunnnner.github.io/p/getattr%E5%87%BD%E6%95%B0/","title":"Getattr函数"},{"content":"描述 hasattr() 函数用于判断对象是否包含对应的属性。\n语法 hasattr 语法：\nhasattr(object, name)\n参数 object – 对象。\nname – 字符串，属性名。\n返回值 如果对象有该属性返回 True，否则返回 False。  ","date":"2019-10-13T15:30:12+08:00","permalink":"https://sunnnner.github.io/p/hasattr%E5%87%BD%E6%95%B0/","title":"Hasattr函数"},{"content":"全局代理，写入配置 git config --global http.proxy 'socks5://127.0.0.1:1080' git config --global https.proxy 'socks5://127.0.0.1:1080'  清除配置 git config --global --unset http.proxy git config --global --unset https.proxy  临时代理 ALL_PROXY=socks5://127.0.0.1:1080 git clone xxx ","date":"2019-10-12T15:29:07+08:00","permalink":"https://sunnnner.github.io/p/git%E5%8A%A0%E9%80%9F/","title":"Git加速"},{"content":"类型和方法数据压缩分为两种类型。\n有损：在这种类型的压缩中，压缩时会降低数据质量（在这种情况下为图像和视频）。这被广泛用于压缩多媒体。\n无损：在这种类型的压缩中，数据质量（在这种情况下为图像）不会丢失。它广泛用于压缩无法承受数据丢失的敏感数据。\n安装与配置\n安装python图像处理库 Pillow\n`pip install Pillow``\n我们将建立一个简单的项目来演示图像上传以及上传之前和之后的文件大小。您也可以参考Django-docs或在此处下载完整的源代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  models.py from pil import Image from io import BytesIO from django.core.files.uploadedfile import InMemoryUploadedFile class File(models.Model): user = models.ForeignKey(KwsUser, verbose_name=\u0026#39;所属用户\u0026#39;, help_text=\u0026#39;所属用户\u0026#39;) file = models.FileField(upload_to=get_file_path, help_text=\u0026#39;上传的文件\u0026#39;) big_file = models.FileField(upload_to=get_pro_file_path, help_text=\u0026#39;上传的原图\u0026#39;, null=True, blank=True) upload_time = models.DateTimeField(auto_now_add=True, verbose_name=\u0026#39;上传时间\u0026#39;, null=True, blank=True) name = models.CharField(max_length=100, verbose_name=\u0026#39;文件名\u0026#39;, help_text=\u0026#39;文件名\u0026#39;) type = models.CharField(max_length=20, choices=FILETYPE, verbose_name=\u0026#39;文件类型\u0026#39;) uid = models.AutoField(primary_key=True) # 前端数据。。。。 minio_url = models.TextField(verbose_name=\u0026#39;文件链接\u0026#39;, blank=True) big_file_minio_url = models.TextField(verbose_name=\u0026#39;大图文件链接\u0026#39;, blank=True) def save（self，* args，** kwargs）： if not self.uid self.file = self.compressImage（ self.file super（File，self）.save（* args，** kwargs） def compressImage（self，file）： imageTemproary = Image.open（file） outputIoStream = BytesIO（） imageTemproaryResized = imageTemproary.resize（（1020,573）） imageTemproary.save（outputIoStream，format =\u0026#39;JPEG\u0026#39;，quality = 60） outputIoStream.seek（0） UploadedImage = InMemoryUploadedFile（outputIoStream，\u0026#39;ImageField\u0026#39;，“％s.jpg” ％file.name.split（\u0026#39;.\u0026#39;）[0]，\u0026#39;image / jpeg\u0026#39;，sys.getsizeof（outputIoStream），None） return uploadImage   在上面的models.py文件中，我们声明名称的实用程序方法compressImage并将其uploadedImage作为参数传递。save创建Upload对象时在模块中调用此方法。\n我们使用python图像处理库Pillow（PIL）来处理图像处理。我们打开上载的图像并将其存储在一个临时对象中，imageTemproary并初始化BytesIO流以处理将更改写入图像的过程。我们使用此resize()方法将上传的图像调整为特定大小（在这种情况下小于原始大小），并使用seek() method将输出流指针流重置为初始位置。我们可以进一步使用Django的InMemoryUploadedFile，以覆盖现有的未压缩的图像。 您可以继续自定义方法，以根据需要更改图像类型，尺寸和质量级别。\n","date":"2019-10-11T15:28:02+08:00","permalink":"https://sunnnner.github.io/p/django%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/","title":"Django文件压缩"},{"content":"Django staticfile 的配置 起初以为是我dockerfile写错了的问题，的确不是dockerfile的问题是我没有理解static_url与static_root的含义\n👍 如果不是前后端分离项目在每个APP下都应该有static与templates文件夹存在不然django收集静态文件收集不到\nSTATIC_URL为Django返回给前端的路径即项目内部的static文件夹\nSTATIC_ROOT为静态文件收集的路径即 python3 manage.py collectstatic 的文件夹\nSTATIC_ROOT = os.path.join(BASE_DIR, \u0026lsquo;static\u0026rsquo;) 意思是把文件收集到项目下static文件夹下的static文件夹中\n所以方便起见我把 STATIC_ROOT = os.path.join(BASE_DIR, \u0026lsquo;\u0026rsquo;)设置为了收集在项目下static文件夹下\n大坑不少小坑不断，学无止境啊\n","date":"2019-10-10T15:27:14+08:00","permalink":"https://sunnnner.github.io/p/%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE/","title":"静态文件的含义以及配置"},{"content":"os .path.dirname(path) 获取路径名\nos.path.basename(path) 获取文件名\nos.path.join(path1[,path2[,….]]) 将路径与文件名拼接成一个完整的路径\nos.path.split(path) 分割路径与文件名，返回元组(f_path, f_name), 如果完全使用目录，它也会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在\nos.path.splitext(path) 分割文件名与扩展名\nos.path.getsize(file) 或得文件大小，单位是字节\nos.path.gettatime(file) 或得文件最近的访问时间，返回的是浮点型秒数\nos.path.getctime(file) 或得文件的创建时间，返回的是浮点型秒数\nos.path.getmtime(file) 或得文件的修费时间，返回的是浮点型秒数\nos.path.exists(path) 判断路径是否存在\nos.path.isabs(path) 判断是否为绝对路径\nos.path.isdir(path) 判断是否存在且是一个目录\nos.path.isfile(path)\nos.path.islink(path) 判断是否存在且是一个符号链接\nos.path.ismount(path) 判断是否存在且是一个挂载点\nos.path.samefile(path1, path2) 判断两个路径是否指向同一个文件\n","date":"2019-10-10T14:20:46+08:00","permalink":"https://sunnnner.github.io/p/os%E6%A8%A1%E5%9D%97/","title":"Os模块"},{"content":"","date":"2019-10-08T14:57:24+08:00","permalink":"https://sunnnner.github.io/p/k8s-install/","title":"K8s Install"},{"content":"docker build 打包docker 项目\ndocker-compose up 启动整体项目(docker-compose.yml文件)\ndocker-compose down 强制停止docker运行的所有项目\n1、删除所有容器 docker rm docker ps -a -q\n2、删除所有镜像d ocker rmi docker images -q\n3、按条件删除镜像 没有打标签docker rmi docker images -q | awk '/^\u0026lt;none\u0026gt;/ { print $3 }'\n镜像名包含关键字docker rmi \u0026ndash;force docker images | grep doss-api | awk '{print $3}' //其中doss-api为关键字\n　docker-compose.yml\nservice 项目\nimage docker镜像名字，若本地没有会尝试在docker服务器拉取\nrestart 是否stop后重启\ncommand 启动路径\nvolumes 将docker容器文件夹与本地文件夹映射挂载 [本地:docker文件夹]\nenvironment 运行携带的参数\nports运行端口\nlinks 关联项目，关联之后内部访问\n","date":"2019-10-08T14:19:00+08:00","permalink":"https://sunnnner.github.io/p/docker%E6%93%8D%E4%BD%9C/","title":"Docker操作"},{"content":" 使用Django-minio-storage进行开发minio的静态文件存储功能，本来寻思用minio直接进行开发，既然django有这个包我们就拿来用一下\n  项目说明django-minio-storage  开发期间遇到的问题   千万不要忘了把minio-storage添加到app\n Add minio_storage to INSTALLED_APPS in your project settings. The last step is setting DEFAULT_FILE_STORAGE to \u0026quot;minio_storage.storage.MinioMediaStorage\u0026quot;, and STATICFILES_STORAGE to \u0026quot;minio_storage.storage.MinioStaticStorage\u0026quot;.    接下来的配置看官网配置就行了\n因为我用docker写的所以minio_storage_endpoint可以使用docker项目名称:端口号或者外网域名（static.media.com）或者外网IP:端口号\n浏览器复用minio静态服务器的media携带端口号怎么办？\n解决办法 nginx 负载均衡：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  upstream docker { server docker:9000; } server { listen 80; server_name static.media.com location / { proxy_set_header Host $host; proxy_pass http://docker; client_max_body_size 10m; } }   ","date":"2019-10-06T14:17:12+08:00","permalink":"https://sunnnner.github.io/p/django-minio%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B/","title":"Django Minio开发过程"},{"content":"环境  python3.6 三方库—pyCryptodome  介绍 之前的AES加密中，Py2或者3.4都是采用的pyCrypto这个模块但是它已经停止维护，现在多了一个分支pyCryptodome这个模块 如果有别的模块不能安装可以去这个网站下载安装点我\n进去之后都会有安装教程\n编写代码支付宝接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159  # -*- coding: utf-8 -*- # pip install pycryptodome(这个一定要有) #pip install winrandom from datetime import datetime from Crypto.PublicKey import RSA from Crypto.Signature import PKCS1_v1_5 from Crypto.Hash import SHA256 from base64 import b64encode, b64decode from urllib.parse import quote_plus from urllib.parse import urlparse, parse_qs from urllib.request import urlopen from base64 import decodebytes, encodebytes import json class AliPay(object): \u0026#34;\u0026#34;\u0026#34; 支付宝支付接口 \u0026#34;\u0026#34;\u0026#34; def __init__(self, appid, app_notify_url, app_private_key_path, alipay_public_key_path, return_url, debug=False): self.appid = appid self.app_notify_url = app_notify_url self.app_private_key_path = app_private_key_path self.app_private_key = None self.return_url = return_url with open(self.app_private_key_path) as fp: self.app_private_key = RSA.importKey(fp.read()) self.alipay_public_key_path = alipay_public_key_path with open(self.alipay_public_key_path) as fp: self.alipay_public_key = RSA.importKey(fp.read()) if debug is True: self.__gateway = \u0026#34;https://openapi.alipaydev.com/gateway.do\u0026#34; else: self.__gateway = \u0026#34;https://openapi.alipay.com/gateway.do\u0026#34; def direct_pay(self, subject, out_trade_no, total_amount, return_url=None, **kwargs): biz_content = { \u0026#34;subject\u0026#34;: subject, \u0026#34;out_trade_no\u0026#34;: out_trade_no, \u0026#34;total_amount\u0026#34;: total_amount, \u0026#34;product_code\u0026#34;: \u0026#34;FAST_INSTANT_TRADE_PAY\u0026#34;, # \u0026#34;qr_pay_mode\u0026#34;:4 } biz_content.update(kwargs) data = self.build_body(\u0026#34;alipay.trade.page.pay\u0026#34;, biz_content, self.return_url) return self.sign_data(data) def build_body(self, method, biz_content, return_url=None): data = { \u0026#34;app_id\u0026#34;: self.appid, \u0026#34;method\u0026#34;: method, \u0026#34;charset\u0026#34;: \u0026#34;utf-8\u0026#34;, \u0026#34;sign_type\u0026#34;: \u0026#34;RSA2\u0026#34;, \u0026#34;timestamp\u0026#34;: datetime.now().strftime(\u0026#34;%Y-%m-%d%H:%M:%S\u0026#34;), \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;biz_content\u0026#34;: biz_content } if return_url is not None: data[\u0026#34;notify_url\u0026#34;] = self.app_notify_url data[\u0026#34;return_url\u0026#34;] = self.return_url return data def sign_data(self, data): data.pop(\u0026#34;sign\u0026#34;, None) # 排序后的字符串 unsigned_items = self.ordered_data(data) #拼接字符串 unsigned_string = \u0026#34;\u0026amp;\u0026#34;.join(\u0026#34;{0}={1}\u0026#34;.format(k, v) for k, v in unsigned_items) #签名 sign = self.sign(unsigned_string.encode(\u0026#34;utf-8\u0026#34;)) #排序 # ordered_items = self.ordered_data(data) quoted_string = \u0026#34;\u0026amp;\u0026#34;.join(\u0026#34;{0}={1}\u0026#34;.format(k, quote_plus(v)) for k, v in unsigned_items) # 获得最终的订单信息字符串 signed_string = quoted_string + \u0026#34;\u0026amp;sign=\u0026#34; + quote_plus(sign) return signed_string def ordered_data(self, data): complex_keys = [] for key, value in data.items(): if isinstance(value, dict): complex_keys.append(key) # 将字典类型的数据dump出来 for key in complex_keys: data[key] = json.dumps(data[key], separators=(\u0026#39;,\u0026#39;, \u0026#39;:\u0026#39;)) return sorted([(k, v) for k, v in data.items()]) def sign(self, unsigned_string): # 开始计算签名 key = self.app_private_key signer = PKCS1_v1_5.new(key) signature = signer.sign(SHA256.new(unsigned_string)) # base64 编码，转换为unicode表示并移除回车 sign = encodebytes(signature).decode(\u0026#34;utf8\u0026#34;).replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;) return sign def _verify(self, raw_content, signature): # 开始计算签名 key = self.alipay_public_key signer = PKCS1_v1_5.new(key) digest = SHA256.new() digest.update(raw_content.encode(\u0026#34;utf8\u0026#34;)) if signer.verify(digest, decodebytes(signature.encode(\u0026#34;utf8\u0026#34;))): return True return False def verify(self, data, signature): if \u0026#34;sign_type\u0026#34; in data: sign_type = data.pop(\u0026#34;sign_type\u0026#34;) # 排序后的字符串 unsigned_items = self.ordered_data(data) message = \u0026#34;\u0026amp;\u0026#34;.join(u\u0026#34;{}={}\u0026#34;.format(k, v) for k, v in unsigned_items) return self._verify(message, signature) if __name__ == \u0026#34;__main__\u0026#34;: return_url = \u0026#39;http://47.94.224.53:8000/?charset=utf-8\u0026amp;out_trade_no=20180614122222\u0026amp;method=alipay.trade.page.pay.return\u0026amp;total_amount=100.01\u0026amp;sign=m1u20Z%2FYTU0uipXfDYktEINrkaAmv5dh1RHYyeb6wDZzBB%2FHLt9x87W91sqsN8%2BO6%2BuxwZLEAOC5olHJDBplYHLhR5s60UXFyvvagmfNAdQYOIV7Rk3yYWkz2P7bejB7n9tOQ9Kj8%2FxMf9me5YZts1gZlLcedetHDSuDzHDTPB9Lhc1qhnF7655hYf1P9qA%2B6l%2BVFIwihmPxDsb9n7vuw34dtHFHTUuK%2FGn3sqjKwAtN5igfOJibyTYeVMjASTMSDir0HC9xVWMgyzE3BJidNnWhSvoMUah%2FDVToJZCPcydpgmd0zZ7iZMelxE4cQ7KJRidgDa4%2FAsUU0ZJrY3%2FRnw%3D%3D\u0026amp;trade_no=2018061421001004760200615074\u0026amp;auth_app_id=2016091300503105\u0026amp;version=1.0\u0026amp;app_id=2016091300503105\u0026amp;sign_type=RSA2\u0026amp;seller_id=2088102175472298\u0026amp;timestamp=2018-06-14+18%3A12%3A38\u0026#39; from newpro.settings import private_key_path, ali_public_path alipay = AliPay( appid=\u0026#34;2016091700530413\u0026#34;, #异步的通知接口，当在浏览器扫描创建订单后，这个时候关闭页面，此时可以在客户端或者支护宝账号里面看到这个为支付完成的信息 app_notify_url=\u0026#34;http://118.190.202.67:8001/alipay/return/\u0026#34;, app_private_key_path=private_key_path, alipay_public_key_path=ali_public_path, # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥, debug=True, # 默认False, #同步接口，支付成功后会跳转的接口 return_url=\u0026#34;http://47.94.224.53:8000/alipay/return/\u0026#34; ) o = urlparse(return_url) query = parse_qs(o.query) processed_query = {} ali_sign = query.pop(\u0026#34;sign\u0026#34;)[0] for key, value in query.items(): processed_query[key] = value[0] print(\u0026#34;processed_query===\u0026#34;, processed_query) print(alipay.verify(processed_query, ali_sign)) url = alipay.direct_pay( subject=\u0026#34;测试订单\u0026#34;, out_trade_no=\u0026#34;20180615109866gsss\u0026#34;, total_amount=100.01 ) #沙箱环境 re_url = \u0026#34;https://openapi.alipaydev.com/gateway.do?{data}\u0026#34;.format(data=url) print(re_url)     python加解密点我\n  更好的方法\n  ","date":"2019-10-05T14:14:41+08:00","permalink":"https://sunnnner.github.io/p/python%E5%AE%9E%E7%8E%B0aes%E5%8A%A0%E5%AF%86/","title":"Python实现AES加密"},{"content":"方法一： 直接执行命令： `mysql\u0026gt; select count(1) from table into outfile '/tmp/test.xls';` Query OK, 31 rows affected (0.00 sec) 在目录/tmp/下会产生文件test.xls 遇到的问题： mysql\u0026gt; select count(1) from table into outfile '/data/test.xls'; 报错： ERROR 1 (HY000): Can’t create/write to file ‘/data/test.xls’ (Errcode: 13) 可能原因：mysql没有向/data/下写的权限  方法二： 查询都自动写入文件： mysql\u0026gt; pager cat \u0026gt; /tmp/test.txt ; PAGER set to 'cat \u0026gt; /tmp/test.txt' 之后的所有查询结果都自动写入/tmp/test.txt’，并前后覆盖 mysql\u0026gt; select * from table ; 30 rows in set (0.59 sec) 在框口不再显示查询结果  方法三： 跳出mysql命令行 `# mysql -h 127.0.0.1 -u root -p XXXX -P 3306 -e “select * from table” \u0026gt; /tmp/test/txt``  ","date":"2019-10-03T14:13:04+08:00","permalink":"https://sunnnner.github.io/p/mysql%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6/","title":"Mysql查询结果输出到文件"},{"content":"JWT——Json web token 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准，可实现无状态、分布式的Web应用授权。  1.1 传统方式 XSS的原理分析与解剖\n前后端分离通过Restful API进行数据交互时，如何验证用户的登录信息及权限。在原来的项目中，使用的是最传统也是最简单的方式，前端登录，后端根据用户信息生成一个token，并保存这个 token 和对应的用户id到数据库或Session中，接着把 token 传给用户，存入浏览器 cookie，之后浏览器请求带上这个cookie，后端根据这个cookie值来查询用户，验证是否过期。 但这样做问题就很多，如果我们的页面出现了 XSS 漏洞，由于 cookie 可以被 JavaScript 读取，XSS 漏洞会导致用户 token 泄露，而作为后端识别用户的标识，cookie 的泄露意味着用户信息不再安全。尽管我们通过转义输出内容，使用 CDN 等可以尽量避免 XSS 注入，但谁也不能保证在大型的项目中不会出现这个问题。 在设置 cookie 的时候，其实你还可以设置 httpOnly 以及 secure(保护)项。设置 httpOnly 后 cookie 将不能被 JS 读取，浏览器会自动的把它加在请求的 header 当中，设置 secure 的话，cookie 就只允许通过 HTTPS 传输。secure 选项可以过滤掉一些使用 HTTP 协议的 XSS 注入，但并不能完全阻止。 httpOnly 选项使得 JS 不能读取到 cookie，那么 XSS 注入的问题也基本不用担心了。但设置 httpOnly 就带来了另一个问题，就是很容易的被 XSRF，即跨站请求伪造。当你浏览器开着这个页面的时候，另一个页面可以很容易的跨站请求这个页面的内容。因为 cookie 默认被发了出去。 另外，如果将验证信息保存在数据库中，后端每次都需要根据token查出用户id，这就增加了数据库的查询和存储开销。若把验证信息保存在session中，有加大了服务器端的存储压力。那我们可不可以不要服务器去查询呢？如果我们生成token遵循一定的规律，比如我们使用对称加密算法来加密用户id形成token，那么服务端以后其实只要解密该token就可以知道用户的id是什么了。不过呢，我只是举个例子而已，要是真这么做，只要你的对称加密算法泄露了，其他人可以通过这种加密方式进行伪造token，那么所有用户信息都不再安全了。恩，那用非对称加密算法来做呢，其实现在有个规范就是这样做的，就是我们接下来要介绍的 JWT。  Json Web Token（JWT） JWT 是一个开放标准(RFC 7519)，它定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。JWT 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名。它具备两个特点： 简洁(Compact) 可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快 自包含(Self-contained) 负载中包含了所有用户所需要的信息，避免了多次查询数据库  JWT 组成 Header 头部 头部包含了两部分，token 类型和采用的加密算法  1 2 3 4  { \u0026#34;alg\u0026#34;: \u0026#34;HS256\u0026#34;, \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34; }   它会使用 Base64 编码组成 JWT 结构的第一部分,如果你使用Node.js，可以用Node.js的包base64url来得到这个字符串。 Base64是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程。  Payload 负载 这部分就是我们存放信息的地方了，你可以把用户 ID 等信息放在这里，JWT 规范里面对这部分有进行了比较详细的介绍，常用的由 iss（签发者），exp（过期时间），sub（面向的用户），aud（接收方），iat（签发时间）。  1 2 3 4 5 6 7  { \u0026#34;iss\u0026#34;: \u0026#34;lion1ou JWT\u0026#34;, \u0026#34;iat\u0026#34;: 1441593502, \u0026#34;exp\u0026#34;: 1441594722, \u0026#34;aud\u0026#34;: \u0026#34;www.example.com\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;lion1ou@163.com\u0026#34; }   同样的，它会使用 Base64 编码组成 JWT 结构的第二部分  Signature 签名 前面两部分都是使用 Base64 进行编码的，即前端可以解开知道里面的信息。Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥，然后使用 header 中指定的签名算法（HS256）进行签名。签名的作用是保证 JWT 没有被篡改过。 三个部分通过.连接在一起就是我们的 JWT 了，它可能长这个样子，长度貌似和你的加密算法和私钥有关系 ```text eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjU3ZmVmMTY0ZTU0YWY2NGZmYzUzZGJkNSIsInhzcmYiOiI0ZWE1YzUwOGE2NTY2ZTc2MjQwNTQzZjhmZWIwNmZkNDU3Nzc3YmUzOTU0OWM0MDE2NDM2YWZkYTY1ZDIzMzBlIiwiaWF0IjoxNDc2NDI3OTMzfQ.PA3QjeyZSUh7H0GfE0vJaKW4LjKJuC3dVLQiY4hii8s ``` 其实到这一步可能就有人会想了，HTTP 请求总会带上 token，这样这个 token 传来传去占用不必要的带宽啊。如果你这么想了，那你可以去了解下 HTTP2，HTTP2 对头部进行了压缩，相信也解决了这个问题。  签名的目的 最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。  信息暴露 在这里大家一定会问一个问题：Base64是一种编码，是可逆的，那么我的信息不就被暴露了吗？ 是的。所以，在JWT中，不应该在负载里面加入任何敏感的数据。在上面的例子中，我们传输的是用户的User ID。这个值实际上不是什么敏感内容，一般情况下被知道也是安全的。但是像密码这样的内容就不能被放在JWT中了。如果将用户的密码放在了JWT中，那么怀有恶意的第三方通过Base64解码就能很快地知道你的密码了。 因此JWT适合用于向Web应用传递一些非敏感信息。JWT还经常用于设计用户认证和授权系统，甚至实现Web应用的单点登录。  JWT 使用 1.首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。 2.后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT。形成的JWT就是一个形同lll.zzz.xxx的字符串。 3.后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。 4.前端在每次请求时将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题) 5.后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。 6.验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。  和Session方式存储id的差异 Session方式存储用户id的最大弊病在于Session是存储在服务器端的，所以需要占用大量服务器内存，对于较大型应用而言可能还要保存许多的状态。一般而言，大型应用还需要借助一些KV数据库和一系列缓存机制来实现Session的存储。 而JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。除了用户id之外，还可以存储其他的和用户相关的信息，例如该用户是否是管理员、用户所在的分组等。虽说JWT方式让服务器有一些计算压力（例如加密、编码和解码），但是这些压力相比磁盘存储而言可能就不算什么了。具体是否采用，需要在不同场景下用数据说话。  单点登录 Session方式来存储用户id，一开始用户的Session只会存储在一台服务器上。对于有多个子域名的站点，每个子域名至少会对应一台不同的服务器，例如：www.taobao.com，nv.taobao.com，nz.taobao.com，login.taobao.com。所以如果要实现在login.taobao.com登录后，在其他的子域名下依然可以取到Session，这要求我们在多台服务器上同步Session。使用JWT的方式则没有这个问题的存在，因为用户的状态已经被传送到了客户端。  总结优点 也就是说相比于传统基于cookie的session，基于token的jwt有以下优点： Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输. 无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息. 更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可. 去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可. 更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。 CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。 性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多. 不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理. 基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）. ","date":"2019-10-02T14:08:17+08:00","permalink":"https://sunnnner.github.io/p/jwt/","title":"JWT"},{"content":"为什么使用token验证  在web领域基于token的身份验证随处可变，在大多说使用web API的互联网公司中，tokens是多用户下处理认证的最佳方式  一下几点特性会让你在程序中使用基于Token 的身份验证  无状态、可扩展 支持移动设备 跨程序调用 安全 那些使用基于Token的身份验证的大佬们 大部分你见到过的API和WEB应用都是用tokens，列如facebook, twitter, google+, github等  Token的起源   在介绍基于token的身份验证的原理与优势之前，不妨先看看之前的认证都是怎么做的\n 基于服务器的验证 我们都是知道HTTP协议是无状态的，这种无状态意味着程序需要验证每一次请求，从而辨别客户端的身份。 在这之前，程序都是通过在服务端存储的登录信息来辨别请求的。这种方式一般都是通过存储Session来完成。 随着Web，应用程序，已经移动端的兴起，这种验证的方式逐渐暴露出了问题。尤其是在可扩展性方面。    基于服务器的验证方式暴露的一些问题 1、session：每次认证用户发起请求时， 服务器需要去创建一个记录来存储信息， 当越来越多的用户发请求时， 内存的开销也会不断增加 2、可获振兴：在服务端的内存中使用session存储的登录信息，办所而来的是可扩展性问题 3、CORS（跨域资源共享）： 当我们需要让数据跨多台移动设备上使用时， 跨域资源共享回事一个让人头疼的问题， 在使用ajax抓取另一个域的资源，就可以会出现禁止请求的情况 4、CSRF（跨站请求伪造）： 用户在访问银行网站时， 他们很容易受到跨站请求伪造的攻击， 并且能够被利用其访问其他网站 在这些问题中，可扩展性是最突出，因此我们有必要去寻求一种更有行之有效的方法  基于TOKEN的验证原理 基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。 这种概念解决了在服务端存储信息时的许多问题 NoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。 基于Token的身份验证的过程如下: 1.用户通过用户名和密码发送请求。 2.程序验证。 3.程序返回一个签名的token 给客户端。 4.客户端储存token,并且每次用于每次发送请求。 5.服务端验证token并返回数据。 每一次请求都需要token。token应该在HTTP的头部发送从而保证了Http请求无状态。我们同样通过设置服务器属性Access-Control-Allow-Origin:* ，让服务器能接受到来自所有域的请求。需要主要的是，在ACAO头部标明(designating)*时，不得带有像HTTP认证，客户端SSL证书和cookies的证书。  代码实例流程： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  //用户第一次登录 username pwd client_type //接口判断 if(token\u0026amp;uid){ 查询token表 $token=where uid =uid if($token==token){ 登录成功！！ 返回token 和 uid }else{ 登录失败！！ } } if(usename powd client_type){ 检验用户名和密码 if（正确）{ 得到uid 并 生成token（md5( uid.pwd.time() 自己定义规则 )） if(uid不存在){ into token 表 id uid token }else{ where uid=$uid 修改token } 返回token 和 uid }else{ 返回错误信息； } }   客户端c进行文件存储uid 和token 下次再次登录时使用uid和token 实现了用户登录的互踢 当我们在程序中认证了信息并取得token之后，我们便能通过这个Token做许多的事情。 我们甚至能基于创建一个基于权限的token传给第三方应用程序，这些第三方程序能够获取到我们的数据（当然只有在我们允许的特定的token）  Tokens的优势   无状态、可扩展\n 在客户端存储的Tokens是无状态的，并且能够被扩展。基于这种无状态和不存储Session信息，负载负载均衡器能够将用户信息从一个服务传到其他服务器上。 如果我们将已验证的用户的信息保存在Session中，则每次请求都需要用户向已验证的服务器发送验证信息(称为Session亲和性)。用户量大时，可能会造成一些拥堵。但是不要着急。使用tokens之后这些问题都迎刃而解，因为tokens自己hold住了用户的验证信息。    安全性 请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。 token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocataion可以使一个特定的token或是一组有相同认证的token无效。  可扩展性（） Tokens能够创建与其它程序共享权限的程序。例如，能将一个随便的社交帐号和自己的大号(Fackbook或是Twitter)联系起来。当通过服务登录Twitter(我们将这个过程Buffer)时，我们可以将这些Buffer附到Twitter的数据流上(we are allowing Buffer to post to our Twitter stream)。 使用tokens时，可以提供可选的权限给第三方应用程序。当用户想让另一个应用程序访问它们的数据，我们可以通过建立自己的API，得出特殊权限的tokens。  多平台跨域 我们提前先来谈论一下CORS(跨域资源共享)，对应用程序和服务进行扩展的时候，需要介入各种各种的设备和应用程序。 Having our API just serve data, we can also make the design choice to serve assets from a CDN. This eliminates the issues that CORS brings up after we set a quick header configuration for our application. 只要用户有一个通过了验证的token，数据和资源就能够在任何域上被请求到。  Access-Control-Allow-Origin: * 基于标准 创建token的时候，你可以设定一些选项。我们在后续的文章中会进行更加详尽的描述，但是标准的用法会在JSON Web Tokens体现。 最近的程序和文档是供给JSON Web Tokens的。它支持众多的语言。这意味在未来的使用中你可以真正的转换你的认证机制。  总结 这篇文章仅仅是介绍了为什么选择基于Token的身份验证，并且怎样使用它。  ","date":"2019-10-01T14:03:37+08:00","permalink":"https://sunnnner.github.io/p/token%E9%AA%8C%E8%AF%81%E8%AF%A6%E8%A7%A3/","title":"TOKEN验证详解"},{"content":" 网络应用程序，分为前端和后端两个部分， 当前的发展趋势， 就是前段设备层出不穷 因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信， 这导致API架构的流行， \u0026gt; 甚至出现APIfirst的设计思想。\n 协议 API与用户的通信协议， 总是使用HTTPs协议  域名   应尽量将API部署在专用域名之下\n https:// api.example.com    如果确定API很简单，不会有进一步扩展， 可以考虑放在主域名下\n https: // example.com    版本(Versioning)   应将API的版本号放入URL\n https://api.example.com/v1/    另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。\n  路径(Endpoint) 路径又称”终点”（endpoint），表示API的具体网址。 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。 · https://api.example.com/v1/zoos · https://api.example.com/v1/animals · https://api.example.com/v1/employees  HTTP动词 对于资源的具体操作类型，由HTTP动词表示。 常用的HTTP动词有下面五个（括号里是对应的SQL命令）。 GET(SELECT) : 从服务器取出资源(一项或者多项) POST(CREATE) : 在服务器新建一个资源 PUT(UPDATE) : 在服务器更新资源（客户端提供改变后的完整资源） PATCH(update): 在服务器更新资源（客户端提供改变的属性） DELETE(DELETE): 从服务器删除资源 还有两个不常用的HTTP\u0008动词 HEAD: 获取资源的元数据 OPTIONS: 获 取信息， 关于资源的哪些属性是客户端可以改变的 下面是一些例子 GET/ courses ：列出所有课程 POST/ courses : 添加一门课程 GET/ courses/ID: 获取某个课程的信息 PUT/ courses/ID: 更新某个指定课程信息（提供该课程的全部信息） PATCH/ courses/ID: 更新某个指定课程信息（提供该课程的部分信息） DELETE/courses/ID: 删除一门课程 GET/ courses/ ID/ class: 列出某个指定课程的所有班级 DELETE/courses/ class/ID: 删除某个指定课程的指定班级  过滤信息（Fitering） 如果记录数量很多，服务器不可能都将他们返回给用户，API应该提供参数， 过滤返回结果，下面是一些常见的参数 ?limit=10: 指定返回记录的数量 ?offset=10: 指定返回记录的开始位置 ?page=2\u0026amp;per_page=100: 指定第几页，以及每页的记录数 ?sortby=name\u0026amp;order=asc: 指定返回结果按照那个属性排序， 以及排序顺序 ?animal_type_id=1: 指定筛选条件 参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复， 比如：GET/zoo/ID/animals与GET/animals?zoo_id=ID的含义是相同的  状态吗（status codes） 服务器向 用户返回的状态吗和提示信息， 常见的有以下一些 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent） 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务） 204 NO CONTENT - [DELETE]：用户删除数据成功。 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。  状态码的完全列表参见 这里\n错误处理(ERROR handling) 如果状态码是4XX，就应该向用户返回出错信息，一般来说，返回的信息中将error作为键名，出错信息\u0008作为键值即可 {error:\u0026quot;Invalid API key\u0026quot;}  返回结果 针对不同操作， 服务器向用户返回的结果应该符合以下规范 GET /collection：返回资源对象的列表（数组） GET /collection/resource：返回单个资源对象 POST /collection：返回新生成的资源对象 PUT /collection/resource：返回完整的资源对象 PATCH /collection/resource：返回完整的资源对象 DELETE /collection/resource：返回一个空文档  Hypermedia API RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。 ```text {\u0026quot;link\u0026quot;: { \u0026quot;rel\u0026quot;: \u0026quot;collection https://www.example.com/zoos\u0026quot;, \u0026quot;href\u0026quot;: \u0026quot;https://api.example.com/zoos\u0026quot;, \u0026quot;title\u0026quot;: \u0026quot;List of zoos\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;application/vnd.yourformat+json\u0026quot; }} ``` 上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。 Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问 api.github.com 会得到一个所有可用API的网址列表。 { \u0026quot;current_user_url\u0026quot;: \u0026quot;https://api.github.com/user\u0026quot;, \u0026quot;authorizations_url\u0026quot;: \u0026quot;https://api.github.com/authorizations\u0026quot;, // ... } 从上面可以看到，如果想获取当前用户的信息，应该去访问 api.github.com/user ，然后就得到了下面结果。 { \u0026quot;message\u0026quot;: \u0026quot;Requires authentication\u0026quot;, \u0026quot;documentation_url\u0026quot;: \u0026quot;https://developer.github.com/v3\u0026quot; } 上面代码表示，服务器给出了提示信息，以及文档的网址。  其他 (1) API的身份认证应该使用OAuth 2.0框架。 (2) 服务器返回的数据格式，应该尽量使用JSON，避免使用XML。  ","date":"2019-09-12T11:43:08+08:00","permalink":"https://sunnnner.github.io/p/restful_api%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/","title":"RESTful_API设计指南"},{"content":"我们使用自动化测试工具selenium pip install selenium\nPhantomJS 基于webkit的无界面浏览器\nubuntu使用apt-get install phantomjs MAC使用bew cask install phantomjs\nChromedriver\n与selenium配合因为phantomjs已经不支持selenium 如果使用Chrome进行测试，需要使用xvfb， Xvirtual framebuffer (xvfb)虚拟帧缓冲器， 简单来说它可以直接处理window的图形化功能，并且不会输出到屏幕上，这就摆脱了对可视窗口的依赖  MAC安装brew cask install chromedriver mac安装xvfb(可选) pip install xvfbwrapper\n","date":"2019-09-11T11:42:10+08:00","permalink":"https://sunnnner.github.io/p/%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%88%AC%E5%8F%96/","title":"动态网页爬取"},{"content":"sql修改字段长度的语法 alter table 表名 modify 字段名 字段类型;\n标准sql所有都适用 alter table 数据库.表名 modify 字段名 字段类型;\n修改字段名名称 alter table 数据库名 表名 column col1 to col2;\n添加字段 alter table 数据库名.表名 add 字段名 类型;\n","date":"2019-09-10T11:41:14+08:00","permalink":"https://sunnnner.github.io/p/sql%E4%BF%AE%E6%94%B9%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6/","title":"Sql修改字段长度"},{"content":"跨域 浏览器从一个域名的网页去请求另一个域名的资源时,浏览器处于安全的考虑,不允许不同源的请求 同源策略：协议相同， 域名相同， 端口相同 处理办法： 通过JSONP跨域 JSON是一种数据交换格式 JSONP是一种非官方的跨域数据交互协议 JSONP是包含在函数调用中的json sjonp是包含在函数调用中的json script标签不收同源策略的影响，手动创建一个script标签，传递URL， 同时传入一个回调函数的名字 服务器得到名字后， 返回数据时会用这个函数名来包裹数据， 客户端获取到数据之后， 立即吧script标签删掉 cors：跨域资源共享 使用自定义的HTTP头部允许浏览器和服务器相互通信 如果是简单请求,直接设置允许访问的域名： 允许你的域名来获取我的数据 response[‘Access-Control-Allow-Origin‘] = “*” 如果是复杂请求,首先会发送options请求做预检,然后再发送真正的PUT/POST….请求 因此如果复杂请求是PUT等请求,则服务端需要设置允许某请求 如果复杂请求设置了请求头，则服务端需要设置允许某请求头 简单请求： 一次请求 非简单请求： 两次请求，在发送数据之前会先发一次请求用于做“预检”， 只有“预检”通过后才再发送一次请求用于数据传输。 只要同时满足以下两大条件，就属于简单请求。 (1) 请求方法是以下三种方法之一：HEAD GET POST (2)HTTP的头信息不超出以下几种字段：  1 2 3 4 5  Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、 text/plain   JSONP和CORS：\n1.JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求 2.jsonp需要client和server端的相互配合 3.cors在client端无需设置，server端需要针对不同的请求，来做head头的处理 ","date":"2019-09-09T11:39:55+08:00","permalink":"https://sunnnner.github.io/p/%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","title":"什么是跨域及解决办法"},{"content":"为什么要使用Django_rest_framework 能自动生成restful规范的API\n代码简介 并且开发速度快  Django_rest_framework框架有什么组件 序列化组件：serializers 对queryset序列化及对请求数据格式校验\n路由组件：routers 进行路由开发 视图组件： ModelViewSet 帮助开发者提供了一些类。 并在类中提供了多个方法 认证组件： 写一个类并注册到选线类（authentication_classes）， 再类的authticate方法中编写认证逻辑 权限组件：写一个类并注册到权限类（permission_classes）, 在类中的has_permission方法中编写认证逻辑 频率限制： 写一个类并注册到频率类（throttle_classes）, 在类中的allow_request/wait方法中编写认证逻辑 解析器 选择对数据解析的类， 在解析类中注册(parser_classes) 渲染器 定义数据如何渲染到页面上， 在渲染器类中注册(render_classes) 分页 对获取到的数据进行分页处理 pagination_class 版本 版本控制用来在不同的客户端使用不同的行为 在URL中设置version参数， 用户请求时候传入参数， 在request.version中获取版本, 根据版本不同，做不同处理  django rest framework框架的认证流程 用户请求走进来进入APIView， 初始化了默认的认证方式\n进入APIView.dispatch()方法， initial方法调用了request.user 如果我们配置了认证类， 走我们自己认证类中的authentication方法  django rest framework如何实现的用户访问频率控制 使用ip/用户账户作为建， 每次访问时间作为值， 构造一个字典数据， 存起来， 每次访问对时间列表进行判断\n把没有访问的超时的删掉。 在计算列表剩余的元素就能做到频率限制了 匿名账户， 使用IP控制， 但是无法完全控制， 因为用户可以更换代理IP 登陆用户使用账号控制，但是如果有很多账号，也无法限制  如何实现用户登陆认证 cookice session\ntoken 登陆成功后生成的加密字符串 JWT： json wed token 缩写， 他讲用户信息加密到token中 服务器不保存任何用户信息， 服务器通过使用保存的密匙来验证token的正确性  rest_framework序列化组件的作用,以及一些外键关系的钩子方法\n作用：帮助我们序列化数据 ```python 1.choices get_字段名_display 2.ForeignKey source=orm 操作 3.ManyToManyFiled SerializerMethodField() def get_字段名(): return 自定义 ```  PV 和 UV\npv :页面访问量打开一次算一次刷新也算 uv ： 独立访问数， 一台电脑算一个访客  ","date":"2019-09-08T11:37:47+08:00","permalink":"https://sunnnner.github.io/p/django_rest_framework/","title":"Django_rest_framework"},{"content":"RPC\n远程过程中调用(RPC) 是一种协议， 程序可使用这种协议向网络中的另一台计算机上的程序请求服务 RPC采用客户机/ 服务器模式， 请求程序就是一个客户机， 而服务提供程序就是一个服务器 first 客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息 second 在服务端， 进程保持睡眠状态知道调用信息到达为止， 当一个调用到达， 服务器或得晋城参数， 结果， 发送答复信息， 然后等待下一个调用信息 next 客户端调用进程接受答复信息， 或得进程结果， 然后调用执行继续进行  为什么要使用API\n系统之间为了调用数据 数据的传输格式：json, xml  ","date":"2019-09-07T11:36:55+08:00","permalink":"https://sunnnner.github.io/p/%E4%BB%80%E4%B9%88%E6%98%AFrpc/","title":"什么是RPC"},{"content":"restful 只是一种软件架构风格或者说是一种设计风格，它只是给我们提供了一个设计的原则和约束的条件，主要用于客户端与服务端的交互\n我们可以根据自己的需求做的更加简洁， 更有层次\n它里面提供了一些规范，比如restful提倡面向资源编程， 在URL接口中尽量使用名词， 不要使用动词\n在restful推荐使用HTTPS协议，更加安全\n尽量在URL中体现版本号\nrestful的method \u0026lt;GET/ POST/ PUT/ DELETE/ PATCH\u0026gt;\n响应应该设置状态码\n有返回值，并且为json格式\n返回结果中要提供帮助链接， 即API最好做好Hypermedia\n","date":"2019-09-06T11:36:12+08:00","permalink":"https://sunnnner.github.io/p/restful%E8%A7%84%E8%8C%83/","title":"Restful规范"},{"content":"FBV  fbv就是在url中一个路径对应一个函数\n 1 2 3 4  urlpatterns = [ url(r\u0026#39;^admin/\u0026#39;, admin.site.urls), url(r\u0026#39;^index/\u0026#39;, views.index) ]   视图函数中 1 2  def index(request): return render(request, \u0026#39;index.html\u0026#39;)   CBV  cbv就是在url中一个路径对应一个类\n 1 2 3 4  urlpatterns = [ url(r\u0026#39;^admin/\u0026#39;, admin.site.urls), url(r\u0026#39;^index/\u0026#39;, views.IndexView.as_views()) # 执行类后面的as_view()方法 ]   视图函数中 1 2 3 4 5 6 7 8 9  from django.views import View class IndexView(View): # 以get形式访问会执行get函数，一般情况下获取数据 def get(self, *args, **keargs): return HttpResponse(\u0026#39;6666\u0026#39;) # 以post形式访问的话会执行post函数，一般情况下发送数据 def post(self, *args, **kwargs): return HttpResponse(\u0026#39;post ok\u0026#39;)   注意: cbv定义类的时候必须要继承view 在写URL的时候必须要加as_view 类里面使用form表单提交的话只有get和post方法 restful规范：’get’获取数据, ‘post’创建新数据, ‘put’更新, ‘patch’局部更新, ‘delete’删除, ‘head’, ‘options’, ‘trace’  CBV重新定义dispatch函数 所有的方法本质上都是通过dispatch这个函数反射执行，如果想要在执行get或post方法前执行其他步骤，可以重写dispatch ","date":"2019-09-05T11:34:25+08:00","permalink":"https://sunnnner.github.io/p/django%E4%B8%AD%E7%9A%84fbv%E5%92%8Ccbv/","title":"Django中的FBV和CBV"},{"content":" 最近查找大容量存储工具，想到了免费版的Google云盘，询问了一下有一个无限空间的云盘，话不多说开始搞，在淘宝买了个账号开始配在自己的服务器上，但是发现并不是这么好配，查找了很多资料，到最后朋友给我说rclone可以挂在Google云盘，查了一下果然可以，把教程贴出来为以后查看方便  首先安装rclone wget https://www.moerats.com/usr/shell/rclone_debian.sh \u0026amp;\u0026amp; bash rclone_debian.sh  初始化配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98  rclone config n) New remote s) Set configuration password q) Quit config n/s/q\u0026gt; n name\u0026gt; Rats #随便填，后面要用到 Type of storage to configure. Choose a number from below, or type in your own value 1 / Amazon Drive \\ \u0026#34;amazon cloud drive\u0026#34; 2 / Amazon S3 (also Dreamhost, Ceph, Minio) \\ \u0026#34;s3\u0026#34; 3 / Backblaze B2 \\ \u0026#34;b2\u0026#34; 4 / Box \\ \u0026#34;box\u0026#34; 5 / Cache a remote \\ \u0026#34;cache\u0026#34; 6 / Dropbox \\ \u0026#34;dropbox\u0026#34; 7 / Encrypt/Decrypt a remote \\ \u0026#34;crypt\u0026#34; 8 / FTP Connection \\ \u0026#34;ftp\u0026#34; 9 / Google Cloud Storage (this is not Google Drive) \\ \u0026#34;google cloud storage\u0026#34; 10 / Google Drive \\ \u0026#34;drive\u0026#34; 11 / Hubic \\ \u0026#34;hubic\u0026#34; 12 / Local Disk \\ \u0026#34;local\u0026#34; 13 / Microsoft Azure Blob Storage \\ \u0026#34;azureblob\u0026#34; 14 / Microsoft OneDrive \\ \u0026#34;onedrive\u0026#34; 15 / Openstack Swift (Rackspace Cloud Files, Memset Memstore, OVH) \\ \u0026#34;swift\u0026#34; 16 / Pcloud \\ \u0026#34;pcloud\u0026#34; 17 / QingCloud Object Storage \\ \u0026#34;qingstor\u0026#34; 18 / SSH/SFTP Connection \\ \u0026#34;sftp\u0026#34; 19 / Webdav \\ \u0026#34;webdav\u0026#34; 20 / Yandex Disk \\ \u0026#34;yandex\u0026#34; 21 / http Connection \\ \u0026#34;http\u0026#34; Storage\u0026gt; 10 #选择10，Google Drive Google Application Client Id - leave blank normally. client_id\u0026gt; #留空 Google Application Client Secret - leave blank normally. client_secret\u0026gt; #留空 Service Account Credentials JSON file path - needed only if you want use SA instead of interactive login. service_account_file\u0026gt; Remote config Use auto config? * Say Y if not sure * Say N if you are working on a remote or headless machine or Y didn\u0026#39;t work y) Yes n) No y/n\u0026gt; n #选择n If your browser doesn\u0026#39;t open automatically go to the following link: https://accounts.google.com/o/oauth2/auth.... #复制到浏览器打开，获取验证码 Log in and authorize rclone for access Enter verification code\u0026gt; #填入上面获取到的验证码 Configure this as a team drive? y) Yes n) No y/n\u0026gt; y #选择y Fetching team drive list... No team drives found in your account-------------------- [Rats] client_id = client_secret = service_account_file = token = {\u0026#34;access_token\u0026#34;:\u0026#34;ya29.GltFBd7UJN2qrxdG8FnG_rMuB18ogb8QlujdL7glvXtfV\u0026#34;} team_drive = -------------------- y) Yes this is OK e) Edit this remote d) Delete this remote y/e/d\u0026gt; y #选择y Current remotes: Name Type ==== ==== Rats drive e) Edit existing remote n) New remote d) Delete remote r) Rename remote c) Copy remote s) Set configuration password q) Quit config e/n/d/r/c/s/q\u0026gt; q #选择q退出   挂载硬盘（这里坑比较多）   首先我们要在vps上创建一个文件夹(作为Google云盘的载体盘)\nmkdir /root/GoogleDrive\n  首先我们先创建云盘文件夹\nrclone mkdir test\n  其次我们使用rclone开始挂载云盘\nrclone mount gdrive:test /root/GoogleDrive \u0026amp;\n   gdrive是谷歌云盘标识\n  卸载文件夹 fusermount -qzu GoogleDrive   GoogleDrive 为你本地VPS载体文件夹\n  上传文件 rclone copy /root/test gdrive:test   /root/test为本地文件 后面的为谷歌云盘标识及文件夹名字\n  文件下载 rclone copy gdrive:test /root/test   下载到本地vps文件夹下\n   列表\nrclone ls gdrive:test\nrclone lsl gdrive:test\n   显示上传时间 rclone lsd gdrive:test\n ","date":"2019-09-04T11:30:51+08:00","permalink":"https://sunnnner.github.io/p/rclone%E6%8C%82%E8%BD%BDgoogledrive/","title":"Rclone挂载googleDrive"},{"content":"   语法 描述     s.capitalize() 返回字符串s的副本，并将首字符变为大写   s.center(width, char) 返回s中间部分的一个子字符串，长度为width，并使用空格或可选的char(长度为1的字符串)进行填充   s.count(t, star, end) 返回字符串s中（或在s的start:end分片中）子字符串t出现的次数   s.encode(encoding,err) 返回一个bytes对象，该对象使用默认的编码格式或指定编码格式来表示该字符串，并根据可选的err参数处理错误   s.expandtabs(size) 返回s的一个副本，其中的制表符使用8个或指定数量的空格替换   s.find(t, start, end) 返回t在s中（或在s的start:end分片中）的最左位置，如果没有找到，就返回-1，使用str:find()则可以发现相应的最右位置   s.format() 返回按指定参数进行格式化后的字符串副本，   s.index(t, start, end) 返回s最左边t的位置(位置或在start:end的切片中)   s.isalnum() 是否都为字母数字是返回true   s.isalpha() 是否都为字母   s.isdecimal() 是为都为unicode的基数为10的数字   s.isdigit() 是否全为数字   s.isidentifier() \u0008 是否为有效的标识符   s.islower() 是否全为小写   s.isnumeric() 是否为数字或小数   s.isprintable() 是否为可打印的包括字符，不包括换行   s.isspace() 是否为空白字符   s.istitle() 是否首字母大写   s.isupper() 是否\u0008全为大写   s.join(seq) 返回seq中每个项链接起来后的结果   s.ljust(width, char) 返回长度为width的字符串使用空格或可选的char进行填充   s.lower() 将s中的字符变为小写   s.maketrans() 与str.translatr()类似   s.partition() 返回包含3个字符串的远足   s.replace(t, u, n) 替换   s.split(t, n) 以t进行切割   s.splitlines(f) 返回在行终结符处进行分割产生的行列表，并剥离\u0008行终结符   s.satrtwith() 以…开头   s.strip(char) 去除字符串空格   s.swapcase() 将大写变为小写小写转大写   s.title() 首字母变大写   s.translate()    s.upper() 返回s分大写化版本   s.zfill(w)     ","date":"2019-09-03T11:25:09+08:00","permalink":"https://sunnnner.github.io/p/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/","title":"Python字符串操作"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  1.在下载最新python（3.6）：wget https://www.python.org/ftp/python/3.6.1/python-3.6.1-macosx10.6.pkg 2.安装python-3.6.1-macosx10.6.pkg 3.删除mac自带的python2.7： sudo rm -R /System/Library/Frameworks/Python.framework/Versions/2.7 4.把刚安装好的python移到原本系统python位置： sudo mv /Library/Frameworks/Python.framework/Versions/3.6 /System/Library/Frameworks/Python.framework/Versions 5.修改文件所属的Group，设置Group为wheel： sudo chown -R root:wheel /System/Library/Frameworks/Python.framework/Versions/3.6``` 6.更新Current的Link sudo rm /System/Library/Frameworks/Python.framework/Versions/Current sudo ln -s /System/Library/Frameworks/Python.framework/Versions/3.6 /System/Library/Frameworks/Python.framework/Versions/Current 7.删掉原来的执行文件 sudo rm /usr/bin/pydoc sudo rm /usr/bin/python sudo rm /usr/bin/pythonw sudo rm /usr/bin/python-config sudo rm /usr/bin/easy_install sudo rm /usr/bin/pyvenv 8.建立新的链接 sudo ln -s /System/Library/Frameworks/Python.framework/Versions/3.6/bin/pydoc3.6 /usr/bin/pydoc sudo ln -s /System/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6 /usr/bin/python sudo ln -s /System/Library/Frameworks/Python.framework/Versions/3.6/bin/pythonw3.6 /usr/bin/pythonw sudo ln -s /System/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6m-config /usr/bin/python-config sudo ln -s /System/Library/Frameworks/Python.framework/Versions/3.6/bin/pip3.6 /usr/bin/pip sudo ln -s /System/Library/Frameworks/Python.framework/Versions/3.6/bin/easy_install-3.6 /usr/bin/easy_install sudo ln -s /System/Library/Frameworks/Python.framework/Versions/3.6/bin/pyvenv-3.6 /usr/bin/pyvenv 9.添加环境变量 创建.bash_profile：`touch .bash_profile` vim命令打开.bash_profile：`vim .bash_profile` 添加环境变量： Setting PATH for Python 3.6 The orginal version is saved in .bash_profile.pysave PATH=\u0026#34;/System/Library/Frameworks/Python.framework/Versions/3.6/bin:${PATH}\u0026#34; export PATH `alias python=\u0026#34;python3.6\u0026#34; source .bash_profile` 11.测试是否成功： 输入python命令，查看版本python   ","date":"2019-09-02T11:24:14+08:00","permalink":"https://sunnnner.github.io/p/%E4%BF%AE%E6%94%B9macos%E8%87%AA%E5%B8%A6python%E7%89%88%E6%9C%AC%E5%B0%BD%E9%87%8F%E4%B8%8D%E8%A6%81%E4%BF%AE%E6%94%B9/","title":"修改macos自带Python版本（尽量不要修改）"},{"content":"虚拟环境安装 当然首先你先去官网下载Python3.6 注意不是3.7 它现在还不兼容 下载好了之后安装这是Mac的路径包 随后配置下面的语句 pip3 install virtualenv 当然这里你要建立一个文件夹来存放你的虚拟环境 我这里是workspace mkdir workspace  虚拟环境管理包\npip3 install virtualenvwrapper  虚拟环境文件夹 export WORKON_HOME=\u0026rsquo;~/workspace'\n虚拟环境Python需要Python版本进行安装 VIRTUALENVWRAPPER_PYTHON=\u0026quot;/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6\u0026quot;\n使用哪个Python环境的虚拟环境安装包 source /Library/Frameworks/Python.framework/Versions/3.6/bin/virtualenvwrapper.sh\nPython环境配置\n因为TensorFlow库的学习我安装虚拟环境可是我并不怎么会安装虚拟环境 就擅自删除了Mac自带的Python版本使用网上的安装默认的版本Python3.6 可是这是错误的决定安装了默认版本的3。6之后pip各种报错 到最后我总结了一句话 在.zshrc（如果你安装了oh_my_zsh）就加入这一条shell语句 这条语句代表了你的默认Python变量的地址  Python环境变量 export PATH=\u0026quot;/Library/Frameworks/Python.framework/Versions/3.6/bin:${PATH}\u0026quot;\n","date":"2019-09-01T11:22:47+08:00","permalink":"https://sunnnner.github.io/p/python%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%BB%A5%E5%8F%8A%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/","title":"Python版本控制以及虚拟环境的安装"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #! /bin/bash # file test operators # 检查文件是否存在 -e 表示empty 默认文件是不为空 echo -e \u0026#34;Enter the name of file: ~\u0026#34; read filename # 注意括号内空格 -e 就是exist的意思,表示文件是否存在 if [ -e $filename ] then echo \u0026#39;File found\u0026#39; else echo \u0026#39;file is not exist or not found\u0026#39; fi # 检查是否是常规文件或者目录 -f表示file 判断是否是常规的文件 if [ -f $filename ] then echo \u0026#34;$filenamefound\u0026#34; else echo \u0026#34;$filenameis not exist or not fount\u0026#34; fi # 检查文件是否是空 if [ -s $filename ] then echo \u0026#34;$filenameis not empty\u0026#34; else echo \u0026#34;$filenameis empty\u0026#34; fi   ","date":"2019-08-20T11:22:13+08:00","permalink":"https://sunnnner.github.io/p/shell-%E6%96%87%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%93%8D%E4%BD%9C/","title":"Shell 文件测试操作"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  ! /bin/bash this is an example of a if -then if-then比较整数 score=91 if ((\u0026#34;$score\u0026#34;\u0026gt;90)) then echo \u0026#34;well done\u0026#34; fi if-then 比较字符串 word=abc if [$word=\u0026#34;abc\u0026#34;] then echo \u0026#34;condition is true\u0026#34; fi if-then-else word=abc if [ $word=\u0026#39;abccccc\u0026#39; ] then echo \u0026#39;f\u0026#39; else echo \u0026#39;false\u0026#39; fi if-then-elif-then-else num=6 if (($num\u0026gt;7)) then echo \u0026#39;6 is bigger\u0026#39; elif (($num\u0026lt;7)) then echo \u0026#39;7 is bigger\u0026#39; else echo \u0026#39;nonoooo\u0026#39; fi 整数比较符 -eq\t: (equal to)相等 例如： if [ \u0026#34;$a\u0026#34; -eq \u0026#34;$b\u0026#34; ] -ne\t: (not equal to)相等 例如： if [ \u0026#34;$a\u0026#34; -ne \u0026#34;$b\u0026#34; ] -gt\t: (greater than)大于 例如： if [ \u0026#34;$a\u0026#34; -gt \u0026#34;$b\u0026#34; ] -ge\t: (greater than or equal to)大于或等于 例如： if [ \u0026#34;$a\u0026#34; -ge \u0026#34;$b\u0026#34; ] -lt\t: (less than)小于 例如： if [ \u0026#34;$a\u0026#34; -lt \u0026#34;$b\u0026#34; ] -le\t: (less than or equal to)小于或等于 例如： if [ \u0026#34;$a\u0026#34; -le \u0026#34;$b\u0026#34; ] \u0026lt;\t: 小于 例如： if (( \u0026#34;$a\u0026#34; \u0026lt; \u0026#34;$b\u0026#34; )) \u0026lt;=\t: 小于等于 例如： if (( \u0026#34;$a\u0026#34; \u0026lt;= \u0026#34;$b\u0026#34; )) \u0026gt;\t: 大于 例如： if (( \u0026#34;$a\u0026#34; \u0026gt; \u0026#34;$b\u0026#34; )) \u0026gt;=\t: 大于等于 例如： if (( \u0026#34;$a\u0026#34; \u0026gt;= \u0026#34;$b\u0026#34; )) 字符串比较 =\t: 等于 例如： if [ \u0026#34;$a\u0026#34; = \u0026#34;$b\u0026#34; ] ==\t: 等于 例如： if [ \u0026#34;$a\u0026#34; == \u0026#34;$b\u0026#34; ] !=\t: 不等于 例如： if [ \u0026#34;$a\u0026#34; != \u0026#34;$b\u0026#34; ] \u0026lt;\t: 小于（ASCII字母顺序） 例如： if [[ \u0026#34;$a\u0026#34; \u0026lt; \u0026#34;$b\u0026#34; ]] \u0026gt;\t: 大于（ASCII字母顺序） 例如： if [[ \u0026#34;$a\u0026#34; \u0026gt; \u0026#34;$b\u0026#34; ]] -z\t: 字符不为空 需要注意，什么时候用单个中括号和两个中括号，还有什么时候使用两个小括号，注意括号内空格。   ","date":"2019-08-19T11:21:38+08:00","permalink":"https://sunnnner.github.io/p/shell-if-then%E8%AF%AD%E5%8F%A5/","title":"Shell if Then语句"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  # how to pass arguments to shell script  # 利用echo打印你传入的参数 # 上面可以看到$0表示 我们运行sh文件的语句 ./demo.sh，这个不是一个我们提供的真实的参数。 # echo $0 $1 $2 $3  # 换成args 数组方式去存储参数列表 args=(\u0026#34;$@\u0026#34;) # echo ${args[0]} ${args[1]} ${args[2]} ${args[3]} # 更简单的方法 $@可以表示传入的参数列表，直接打印出来 # echo $@ # 如何计算参数的个数 # $#可以存储参数的个数值 echo $#   ","date":"2019-08-18T11:21:09+08:00","permalink":"https://sunnnner.github.io/p/shell-%E5%A6%82%E4%BD%95%E4%BC%A0%E5%8F%82/","title":"Shell 如何传参"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #! /bin/bash # learn about how to read from user input echo \u0026#34;Places input your name\u0026#34; read name echo \u0026#34;your had input name is $name\u0026#34; # -p 是promote ，提示的意思就是可以让用户在提示语相同 # 一行输入内容 read -p \u0026#34;Please input a name\u0026#34; user_var echo \u0026#34;your had input name is: $user_var\u0026#34; # 模拟用户输入密码操作 read -p \u0026#34;place input you name\u0026#34; users_var # -s一般在输入密码的时候启用可以输入过程看不到操作 read -sp \u0026#34;place input you password\u0026#34; pas_var echo \u0026#34;you had input name is $users_var\u0026#34; echo \u0026#34;you had input password is $pas_var\u0026#34;   ","date":"2019-08-17T11:20:41+08:00","permalink":"https://sunnnner.github.io/p/shell-%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/","title":"Shell 获取用户输入"},{"content":"1 2 3 4 5 6 7 8 9 10 11  #! /bin/bash # input your comments here echo \u0026#39;Hello world\u0026#39; # you also can input a comment here echo $BASH # 引用系统变量使用“$” echo $PATH echo the system variable path is $PATH name=Anthony echo my name is $name   引用系统变量使用‘$’\n定义变量时等号两边不要有空格\n#号是备注信息\n","date":"2019-08-16T11:19:55+08:00","permalink":"https://sunnnner.github.io/p/shell-2/","title":"Shell 2"},{"content":"什么是shell\n最早期运行在unix上的shell是Bourne shell（sh），其实shell我们都知道是一个内核，里面集成了很多命令，shell负责和底层硬件打交道。前面我们介绍的这些命令，可以说是shell命令。shell程序的入口一般是在终端输入一些相关命令，然后不需要编译，直接去解释和运行命令的结果，给出相关反馈到终端上面。所以，一句话来理解，shell是一个很多命令的集合，一个内核  什么是bash\nbash 是一个为GNU计划编写的Unix shell。它的名字是一系列缩写：Bourne-Again SHell — 这是关于Bourne shell（sh）的一个双关语（Bourne again / born again）.Bash (GNU Bourne-Again Shell) 是许多Linux发行版的默认Shell。事实上，还有许多传统UNIX上用的Shell，例如tcsh、csh、ash、bsh、ksh等等，Shell Script大致都类同，当您学会一种Shell以后，其它的Shell会很快就上手，大多数的时候，一个Shell Script通常可以在很多种Shell上使用。所以，这就是我们为什么要使用bash脚本的原因。我们接下来的shell脚本都是基于bash。  什么是shell脚本\n前面我们写过了一个shell脚本，shell脚本就是通过一些相关shell命令的组合来达到完成一个任务的文件，文件一般是以,sh结尾。  写一个shell脚本，在终端打印hello shell\n1 2 3 4 5 6 7 8  touch hello.sh code hello.sh #! /bin/bash echo \u0026#39;Hello world\u0026#39; 提高权限 -rwxr-xr-x chmod +x hellp.sh   ","date":"2019-08-15T11:18:47+08:00","permalink":"https://sunnnner.github.io/p/shell-1/","title":"Shell 1"},{"content":"CSS常用框架\n1、Scooter CSS 2、Leaf CSS 3、Fox CSS 4、Miligram CSS 5、Layers CSS 6、Baseguide CSS 7、Mimic CSS 8、Cascade CSS 9、Emastic CSS 10、Neutron CSS  HTML框架\nframe iframe  JS框架\n1.Zepto.js 2.SUI Mobile 3.Node.Js 4.angular.Js 5.JQuery Mobile 6.requirejs 7.Vue.js 8.backbone.js 9.React 10.Ionic  前端UI框架\n1.Pure 2.bootstrap 3.EasyUI 4.Ant Design  可视化组件\n1.Echarts 2.tableau(收费)  ","date":"2019-03-01T11:16:46+08:00","permalink":"https://sunnnner.github.io/p/%E6%A1%86%E6%9E%B6/","title":"框架"},{"content":"redis 数据库优化 1 2 3 4 5 6 7 8 9 10 11  尽量使用短的key 不要忘了见key识意 避免使用keys * 这条命令是阻塞就是操作这条命令的时候就不能操作其他的命令 保存数据之前先压缩一次 设置key的有效期，使其自动销毁 选择回收策略，Redis的实例空间被装满之后，会尝试回收一部分数据。 尽可能的使用哈希存储 一次性添加多条数据的时候可以使用管道进行存储 Redis的系统优化 修改Linux中TCP的最大容纳的数量 修改Linux中内核的分配策略 关闭 THP （连续的物理内存巨大的页面）   redis 的性能优化总结 根据业务需要选择合适的数据类型，并为不同的应用场景设置响应的紧凑的存储参数\n当业务场景不需要数据持久化时， 关闭所有的持久化方式可以或得最佳的性能以及最大的内存使用量\n如果需要使用持久化根据是否可以容忍重启丢失部分数据在快照方式与语句追加方式之间选择其一，不\n要使用虚拟内存以及diskstore方式\n不要让你的Redis所在机器物理内存使用超过实际内存总量的3/5\nmysql 数据库优化 sql 语句优化\n索引优化\n避免查询时的全盘扫描\n增加缓存\n读写分离\n分区\n分布式数据库（垂直分割）\n水平切分\nMongoDB 数据库优化 mongodb可以通过profile来监控数据，进行优化。\n索引优化\n数据库设计优化\n1、完全分离（范式化设计） 2、完全内嵌（反范式化设计） 3、部分内嵌（折中方案） ","date":"2019-02-05T11:15:10+08:00","permalink":"https://sunnnner.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/","title":"数据库优化"},{"content":"优化SQL语句\n通过添加索引进行优化\n优化Order by\n有两种方式如下：\n（1）索引优化：对by后的列添加索引，从而大达到优化的目的。\n（2）where+order by 的组合优化：通过where进行限制后在进行order by\n优化limit\n优化子查询\n2.优化数据库结构\n1、优化insert语句\n 禁用索引，禁用唯一性检查，使用一条insert插入多条语句。  2、优化update语句\n 使用一个update语句同时做多个更新。  3、优化delete语句\n 删除一条记录的时间与索引的数量成正比。删除一个表的所有行，使用truncate table Tbname 而不要使用delete from table  Django如何优化\n1利用标准数据库优化技术：索引, Django建立实体的时候，支持给字段添加索引，具体参考Django.db.models.Field.db_index。\n2了解Django的QuerySets：QuerySets是有缓存的，一旦取出来，它就会在内存里呆上一段时间，尽量重用它\n3数据库的工作就交给数据库本身计算，别用Python处理：使用 filter and exclude 过滤不需要的记录，这两个是最常用语句，相当是SQL的where。使用annotate对数据库做聚合运算。不要用python语言对以上类型数据过滤筛选，同样的结果，python处理复杂度要高，而且效率不高， 白白浪费内存。使用原生的SQL语句：\n4如果需要就一次性取出你所需要的数据：\n单一动作（如：同一个页面）需要多次连接数据库时，最好一次性取出所有需要的数据，减少连接数据库次数。此类需求推荐使用QuerySet.select_related() 和 prefetch_related()。使用QuerySet.count()代替len(queryset),虽然这两个处理得出的结果是一样的，但前者性能优秀很多。同理判断记录存在时，QuerySet.exists()比if queryset实在强得太多了。\n5 懂减少数据库的连接数：\n使用 QuerySet.update() 和 delete()，这两个函数是能批处理多条记录的，适当使用它们事半功倍；如果可以，别一条条数据去update delete处理。\n使用 Redis 进行缓存\n使用异步 Worker 进行写库操作\n高并发问题\n：1，悲观锁；2，乐观锁\n使用场景：\n并发量高的时候使用悲观锁，\n缺点：加锁消耗资源\n并发量低的时候使用乐观锁，\n缺点：乐观锁循环耗费时间。 秒杀问题,一件商品多人抢购如何处理\n获取第一位的数据其他人均不满足\n说一下事务四大特性和隔离级别\nACID\n原子性（Atomicity） 要么全部完成，要么都不成功\n一致性(Consistency) 几个并行执行的事务，其执行结果必须与按照某一舒徐串执行的结果相一致\n隔离性(Isolation) 事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须市透明的\n持久性(Durability) 对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障；\n隔离级别\n脏读 在一个事务处理过程里读取了另一个未提交的事务中的数据\n不可重复读 在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，\n虚读 是事务非独立执行时发生的一种现象 现在来看看MySQL数据库为我们提供的四种隔离级别：\n　① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。\n　② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。\n　③ Read committed (读已提交)：可避免脏读的发生。\n　④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。\nredis的数据类型和使用场景\n字符串(str)， 哈希(hash) 列表(list) 集合(set) 有序集合(zset)\n一万件商品如何按价格排序取前十个\n使用快速排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  def partition(A, p, r): x = A[r] i = p - 1 for j in range(p, r): if A[j] \u0026lt;= x: i = i + 1 A[i], A[j] = A[j], A[i] A[i + 1], A[r] = A[r], A[i + 1] return i + 1 def quickSort(A, p, r): if p \u0026lt; r: q = partition(A, p, r) quickSort(A, p, q - 1) quickSort(A, q + 1, r) A = […] quickSort(A, 0, 9999) print(A[:-9])   redis考数据类型和使用场景,比如list啥时候用,\nredis 七个使用场景https://www.cnblogs.com/NiceCui/p/7794659.html\n还有MySQL有哪些数据库引擎,有什么区别\nISAM：ISAM是一个定义明确且历经时间考验的数据表格管理方法，它在设计之时就考虑到数据库被查询的次数要远大于更新的次数\nMyISAM：MyISAM是MySQL的ISAM扩展格式和缺省的数据库引擎。\nInnoDB：InnoDB数据库引擎都是造就MySQL灵活性的技术的直接产品，这项技术就是MYSQL+API\nMEMORY: MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。\nInnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。\nMyISAM：插入数据快，空间和内存使用比较低。\nMEMORY：所有的数据都在内存中，数据的处理速度快，但是安全性不高\nhttps://blog.csdn.net/t146lla128xx0x/article/details/78737290\n1 2 3 4 5 6 7  [“1”,”2”,”10”],列表里是字符型数值,如何按数字大小给列表排序 list1 = [] a = [“1”,”2”,”10”] for i in a: b = int(i) list1.append(b) print(sorted(list1, reverse=True))   Python2和3的区别\nprint不再是语句，而是函数\n在Python 3中，没有旧式类，只有新式类\n原来1/2（两个整数相除）结果是0，现在是0.5了\n新的字符串格式化方法format取代%\nxrange重命名为range\n!=取代 \u0026lt; \u0026gt;\nlong重命名为int\nexcept Exception, e变成except (Exception) as e\nexec变成函数\n爬虫好像问scrapy和scrapy_redis有什么区别\n还有scrapy爬虫的执行流程,当场手写\n看完我说的你在百度django和爬虫的面试题\nRESTfromework问得也挺多\napiview和viewset有啥关系\n问rest是啥\n","date":"2019-02-04T10:52:21+08:00","permalink":"https://sunnnner.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96/","title":"数据库如何优化"},{"content":"cookie数据存放在客户的浏览器上，session数据放在服务器上。\ncookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗\n考虑到安全应当使用session。\n考虑到减轻服务器性能方面，应当使用COOKIE。\n将登陆信息等重要信息存放为SESSION\n其他信息如果需要保留，可以放在COOKIE中\nsession 和 token并不矛盾，作为身份认证 token安全性比session好\ntoken就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；cookie就是写在客户端的一个txt文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名；session和cookie差不多，只是session是写在服务器端的文件，也需要在客户端写入cookie文件，但是文件里是你的浏览器编号.Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。\n","date":"2019-02-03T10:51:26+08:00","permalink":"https://sunnnner.github.io/p/session-cookie%E5%92%8C%E4%BD%BF%E7%94%A8tocken%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","title":"Session+cookie和使用tocken有什么区别"},{"content":"  进程是系统进行资源分配和调度的一个独立单位，进程是资源分配的单位，线程是cpu调度的单位。\n  线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,\n  只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.\n  线程包含再进程中\n  协程，又程微线程，纤程，英文名：coroutine\n  而协程的操作则是程序员指定的，在python中通过yield，人为的实现并发处理。\n  协程存在的意义：\n  协程，则只使用一个线程，分解一个线程成为多个“微线程”，在一个线程中规定某个代码块的执行顺序。\n  协程的应用场景：当程序中存在大量不需要CPU的操作时（IO）。\n  首先我们得知道协程是啥？协程其实比线程更小的执行单元。 为啥说他是一个执行单元，因为他自带CPU上下文。\n  协程和线程差异：\n  线程切换非常耗性能\n  但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。\n  协程的问题-协程程序员自己调度\n  让需要执行的协程更多的获得CPU时间才是问题的关键。\n  计算密集型和IO密集型   计算密集型–\u0026gt;例如for循环里嵌套10层for循环–\u0026gt;占大量的cpu资源–\u0026gt;解决方案–\u0026gt;使用多进程不能用多线程（多线程中有个全局锁GIL）\n  IO密集型-\u0026gt;需要网络功能，大量的事件等待网络数据的到来–\u0026gt;多线程、协成\n  尽量不要再协程里面做IO密集型操作\n  ","date":"2019-02-02T10:46:49+08:00","permalink":"https://sunnnner.github.io/p/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B/","title":"线程进程协程"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  import queue class TreeNode: def init(self,val=None,left=None,right=None): self.val = val self.left = left self.right = right def settag(self,tag=None): self.tag = tag def visit(treenode): print(str(treenode.val),end=\u0026#39; \u0026#39;) def levelOrder(root): deque = queue.Queue() if(root is not None): deque.put(root) while(not deque.empty()): treenode = deque.get() visit(treenode) if(treenode.left is not None): deque.put(treenode.left) if(treenode.right is not None): deque.put(treenode.right) # 说一下他们的时间复杂度和空间复杂度 #　一般来说，时间复杂度高的算法比复杂度低的算法慢 ＃　时间复杂度的最优,最差,和平均值 ｀｀｀   ","date":"2019-02-01T10:44:14+08:00","permalink":"https://sunnnner.github.io/p/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"广度优先遍历二叉树"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  class TreeNode(object): #定义二叉树类 def init(self,val,left=None,right=None): self.val = val self.left = left self.right = right class BinaryTree(object): def __init__(self,root=None): self.root = root def preScan(self,retList, node): #先序遍历：先跟、再左、后右 if node != None: retList.append(node.val) self.preScan(retList, node.left) self.preScan(retList, node.right) return retList def midScan(self, retList, node): #中序遍历：先左、再跟、后右 if node != None: self.midScan(retList, node.left) retList.append(node.val) self.midScan(retList, node.right) return retList def postScan(self, retList, node): #后序遍历：先左、再右、后跟 if node != None: self.postScan(retList, node.left) self.postScan(retList, node.right) retList.append(node.val) return retList if __name__ == \u0026#34;__main__\u0026#34;: root = TreeNode(50) root.left = TreeNode(20,left=TreeNode(15),right=TreeNode(30,right=TreeNode(12))) root.right = TreeNode(60,right=TreeNode(70)) bTree = BinaryTree(root) retList = bTree.preScan([],bTree.root) print(retList) retList2 = bTree.midScan([],bTree.root) print(retList2) retList3 = bTree.postScan([],bTree.root) print(retList3)   ","date":"2019-01-01T10:41:11+08:00","permalink":"https://sunnnner.github.io/p/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"深度优先遍历二叉树"},{"content":"1 2 3 4 5 6 7 8 9 10  # 方法1 f = zip(x.values(),x.keys()) sorted(f) # 方法2 sorted(x.items(), key = lambda x:x[1], reverse = True) # 字典key value互换 # 使用zip压缩器 # 使用字典推导式 {v: k for k ,v in x.items()}   ","date":"2018-12-02T10:39:55+08:00","permalink":"https://sunnnner.github.io/p/python%E5%AD%97%E5%85%B8%E6%8C%89%E5%80%BC%E6%8E%92%E5%BA%8F/","title":"Python字典按值排序"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  def demo(n): a = 1排序 b = 2 c = 3 for i in range(n-3): c,b,a = a+b+c, c, b return c 其实就是斐波那契数列 def demo(n): if n == 1: return 1 if n == 2: return 2 a,b = 1, 2 result = 0 for i in range(3, n+1): result = a + b a = b b = result return result print(demo(10))   ","date":"2018-12-01T10:39:04+08:00","permalink":"https://sunnnner.github.io/p/python%E4%B8%8A%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98/","title":"Python上楼梯问题"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  def demo(A,p,r): x = A[r] i = p-1 for j in range(p,r): if A[j] \u0026lt;= x: i = i+1 A[i],A[j] = A[j],A[i] A[i+1], A[r] = A[r],A[i+1] return i + 1 def demo2(A,p,r): if p\u0026lt; r: q = demo(A,p,r) demo(A,p,q-1) demo(A,q+1,r) A = [23,54,6,5,7,8] # 0,4代表列表的下标 demo2(A,0,4) print(A)   ","date":"2018-11-01T10:38:06+08:00","permalink":"https://sunnnner.github.io/p/python%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","title":"Python快速排序"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  1--\u0026gt;2--\u0026gt;3--\u0026gt;4--\u0026gt;5--\u0026gt;null 5--\u0026gt;4-\u0026gt;3--\u0026gt;2--\u0026gt;1--\u0026gt;null class Demo(object): def __init__(self,x): self.val = x self.next = None class Demo1(object): def reverseList(self,head): dummy = head tmp = dummy while head and head.next != None: dummy = head.next head.next = dummy.next dummy.next = tmp tmp = dummy return dummy head = Demo(1) head.next = Demo(2) head.next.next = Demo(3) head.next.next.next = Demo(4) head.next.next.next.next = Demo(5) demo1 = Demo1() reverse_head = demo1.reverseList(head) tmp = reverse_head while tmp: print(tmp.val) tmp = tmp.next   ","date":"2018-10-02T10:37:28+08:00","permalink":"https://sunnnner.github.io/p/python%E9%93%BE%E8%A1%A8/","title":"Python链表"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  时间复杂度为o（logN） def demo(array, t): for i in range(len(array): if array[i] == t: return True return False def demo1(array, t): left = 0 right = len(array) - 1 while left \u0026lt;= right: mid = int((left+right)/2) if array[mid] \u0026lt; t: left = mid+1 elif array[mid] \u0026gt; t: right = mid -1 else: return True return False array = list(range(100000)) import time t1 = time.time() demo(array,100001) t2 = time.time() print(\u0026#39;线性查找\u0026#39;, t2-t1) t3 = time.time() demo1(array, 100001) t4 = time.time() print(\u0026#39;二分查找\u0026#39;, t4-t3)   ","date":"2018-10-01T10:36:53+08:00","permalink":"https://sunnnner.github.io/p/python%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","title":"Python二分查找"},{"content":"1 2 3 4 5 6 7  冒泡 def damo(sun): for i in range(len(sun)-1): for j in range(len(sun)-i-1): if sun[j]\u0026gt; sun[j+1]: sun[j], sun[j+1] = sun[j+1], sun[j] return sun   ","date":"2018-09-08T10:36:08+08:00","permalink":"https://sunnnner.github.io/p/python%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95/","title":"Python冒泡算法"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14  装饰器 def demo(name): print(\u0026#39;demo--name\u0026#39;, name) def demo1(demo_name): print(\u0026#39;demo1--demoname\u0026#39;, demo_name.__name__) def demo2(): print(\u0026#39;demo--name\u0026#39;, name) demo_name() return demo2 return demo1 @demo(\u0026#39;zhuangshiqi\u0026#39;) def test(): print(\u0026#39;test\u0026#39;) test()   ","date":"2018-09-07T10:35:21+08:00","permalink":"https://sunnnner.github.io/p/python%E8%A3%85%E9%A5%B0%E5%99%A8/","title":"Python装饰器"},{"content":"介绍一下工厂模式 1 2 3 4 5  工厂模式是一个在软件开发中用来创建对象的设计模式。 工厂模式包涵一个超类。这个超类提供一个抽象化的接口来创建一个特定类型的对象，而不是决定哪个对象可以被创建。 当程序运行输入一个“类型”的时候，需要创建于此相应的对象。这就用到了工厂模式。在如此情形中，实现代码基于工厂模式，可以达到可扩展，可维护的代码。当增加一个新的类型，不在需要修改已存在的类，只增加能够产生新类型的子类。 简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。 封装函数，动态创建商品类   说说有哪些mvc模式的框架 1 2 3  Struts、Spring、ZF/.NET 耦合性低/重用性高/生命周期成本低/部署快/可维护性高/有利软件工程化管理 ``   ","date":"2018-09-06T10:34:03+08:00","permalink":"https://sunnnner.github.io/p/python%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","title":"Python工厂模式"},{"content":"  举个常见的单例模式例子，我们日常使用的电脑上都有一个回收站，在整个操作系统中，回收站只能有一个实例，整个系统都使用这个唯一的实例，而且回收站自行提供自己的实例。因此回收站是单例模式的应用。\n  单例模式，是一种常用的软件设计模式。在它的核心结构中，只包含一个被称为单例的特殊类。\n  通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。\n  1 2 3 4 5 6 7 8 9 10 11 12 13  class A(object): # 定义类属性记录实例化对象 __instance = None # 创建实例对象的方法 def __new__(cls): # 如果没有创建实例对象就创建 if cls.__instance == None: cls.__instance = object.__new__(cls) return cls.__instance else: #如果存在就直接返回 return cls.__instance    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  # 创建单例时，只执行1次__init__方法 class Singleton(object): # 定义雷属性记录实例化对象 __instance = None #创建市里的方法 def __new__(cls): if cls.__instance = None: cls.__instance = object.__new__(cls) return cls.__instance else: return cls.__instance def __init__(self, name): self.name = name 怎么保证打印的名字是一个呢？ class Singleton(object): __instance = None # 标志语，false没有赋值 ture 已经赋值 __init__flag = False 重写new方法,创建对象记录下来 下次创建对象的时候不去创建新的对象，而是返回已经创建的对象 def __new__(cls): if cls.__instance = None: cls.__instance = object.__new__(cls) print(\u0026#39;创建新对象的地址\u0026#39;,id(cls.__instance) return cls.__instance return cls.__instance else: return cls.instance def __init__(self, name): if Singleton.__init__flag = False: self.name = name Singleton.__init__flag = True   ","date":"2018-09-05T10:32:39+08:00","permalink":"https://sunnnner.github.io/p/python%E5%8D%95%E4%BE%8B/","title":"Python单例"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  对象的多种形态 比如说动物，动物分为很多种但是动物都会吃东西，但是动物吃的东西又不一样 # 有三种动物：狗、猫、猪， #\t父类：动物、 #\t子类：狗、猫、猪 可以添加子类自己的方法，自己扩展 #\t动物的属性：动物的名字 #\t动物的方法是eat（就是打印自己的名字） # 有一个饲养员：饲养员 #\t饲养员的方法：feed_animal(需要饲养的动物) #\t函数的实现是（其实就是调用动物的eat方法） class Animal(object): name=\u0026#34;动物\u0026#34; def eat(self): print(\u0026#34;%s会吃东西\u0026#34;%(self.name)) class Dog(Animal): def eat(self): print(\u0026#34;小狗吃骨头\u0026#34;) class Cat(Animal): def eat(self): print(\u0026#34;小猫爱吃鱼\u0026#34;) class Pig(Animal): def eat(self): print(\u0026#34;小猪不知道吃什么\u0026#34;) class Breeder(object): def feed_animal(self,animal): animal.eat() breeder=Breeder() dog=Dog() breeder.feed_animal(dog) cat=Cat() breeder.feed_animal(cat) pig=Pig() breeder.feed_animal(pig)   ","date":"2018-09-04T10:32:01+08:00","permalink":"https://sunnnner.github.io/p/python%E5%A4%9A%E6%80%81/","title":"Python多态"},{"content":"  设计user models\n  django本身的auth_user 只包含了基本的信息包括用户名，密码，邮箱以及注册时间和最新的登录时间，但是这些字段很难满足我们的要求，有时我们想记录用户更多的信息，例如手机号等信息，这时就需要在auth_user 的基础上增加字段，django自定义User网上有四种方法。\n  是官网上推荐的方法，就是增加一个表auth_profile，其中以auth_user 表中的id作为Forgein Key将两个表过关联起来，这样可以在auth_profile 中增加多个用户的信息。\n  另外一种是修改django的源码，这种方法简单暴力直接，但是这种方法可移植性差，不利于多项目部署。\n  继承django auth/models 中的User继续增加字段，这种方法需要修改setting中的AUTH_USER_MODEL=‘app.User’ app为你自定义的app，INSTALLED_APP中要包含Contenttypes和auth两个app，class meta中 db_table 要指定为auth_user, 如果要在admin中管理用户的话，需要将app_label 进行指定。而且要在admin中重新定义UserAdmin 将新添加的字段写在list_display和add_fields中。详见django.contrib.auth.admin中。\n  重写User，也就是继承AbstractUser和Permissions两个类，其实django的User Model也是继承自这两个类，因此你可以做类似User的定义方法定义User。\n  记录是否执行了迁移文件靠的是django_migrations这表\n  ","date":"2018-09-03T10:30:05+08:00","permalink":"https://sunnnner.github.io/p/django%E5%AE%9A%E4%B9%89user%E5%9B%9B%E4%B8%AD%E6%96%B9%E5%BC%8F/","title":"Django定义USER四中方式"},{"content":"celery 简介 任务队列 1 2 3 4  1.任务队列是一种在线程或机器间分发的任务的机制 2.消息队列的输入是工作的一个单元，称为任务，独立的职程（Worker）进程持续监视队列中是否有需要处理的新任务。 3.Celery 用消息通信，通常使用中间人（Broker）在客户端和职程间斡旋。这个过程从客户端向队列添加消息开始，之后中间人把消息派送给职程 4.Celery 系统可包含多个职程和中间人，以此获得高可用性和横向扩展能力。   ","date":"2018-09-02T10:29:21+08:00","permalink":"https://sunnnner.github.io/p/celery%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/","title":"Celery任务队列"},{"content":" ISCSI相关操作 熟悉MVC，熟悉OOP，熟悉Python之外的其他OOP语言，Java者优先 rust go vue  ","date":"2018-09-01T10:28:49+08:00","permalink":"https://sunnnner.github.io/p/%E7%BC%BA%E5%B0%91%E7%9A%84%E7%9F%A5%E8%AF%86/","title":"缺少的知识"},{"content":"生成秘钥文件 1 2 3 4  openssl OpenSSL\u0026gt; genrsa -out app_private_key.pem 2048 # 私钥 OpenSSL\u0026gt; rsa -in app_private_key.pem -pubout -out app_public_key.pem # 导出公钥 OpenSSL\u0026gt; exit     设置支付宝沙箱公匙， 支付宝逐渐转换为RSA2密匙， 可以使用官方的工具生成\n  支付宝沙箱地址\n  生成RSA2教程\n  测试用秘钥 密码: rcip\n  设置本地公匙\u0026amp;私匙格式\n  1 2 3 4 5 6 7 8 9 10 11 12  app_private_key_string.pem -----BEGIN RSA PRIVATE KEY----- 私钥内容 -----END RSA PRIVATE KEY----- alipay_public_key_string.pem -----BEGIN PUBLIC KEY----- 公钥内容 -----END PUBLIC KEY-----   ","date":"2018-06-05T10:26:17+08:00","permalink":"https://sunnnner.github.io/p/%E6%94%AF%E4%BB%98%E5%AE%9D%E7%94%9F%E6%88%90%E5%AF%86%E5%8C%99%E6%AD%A5%E9%AA%A4/","title":"支付宝生成密匙步骤"},{"content":"  默认使用4000端口，用hexo s -p 80，可以暂时修改启动端口。\n  但是每次启动都要写”-p 80”才行，过于繁琐。\n  修改方法： 找到node_modules\\hexo-server\\index.js文件，可以修改默认的port值！\n  ","date":"2018-06-04T10:25:30+08:00","permalink":"https://sunnnner.github.io/p/%E4%BF%AE%E6%94%B9hexo%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%90%AF%E5%8A%A8/","title":"修改hexo默认端口启动"},{"content":"让python2支持中文 1 2  #coding=utf-8 #-*-coding:utf-8-*-    在页面头部写入 变量及数据类型 变量就是用来存东西的 程序就是用来处理数据的，而变量就是用来存储数据的 变量起名要有意义  数据类型 1 2 3 4 5 6 7  nnumber数字包括int long float complex(复数) bollernfalse true String list列表（数组） tuple元组 dictionary字典（对象） 可以用type()来查看变量数据类型   关键字  交换模式下使用import keyword- keyword.kwlist查看当前系统python的关键字 python2中使用raw_iput进行获取用户键盘数据它会把任何数据当作字符串来对待 python3中使用input来捕获用户键盘数据但是在python2中input输入的内容必须是表达式 输出 print  格式化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  %c代表字符 %s 通过str（）字符串转换来格式化 %i 有符号十进制整数 %d 有符号十进制整数 %u 无符号十进制整数 %o 八进制整数 %x 十六进制整数（小写字母） %X 十六进制整数（大写字母） %e 索引符号（小写e） %E 索引符号（大写E） %f 浮点实数 %g %f与%e 的简写 %G %F%E的简写 \\n 换行输出 python算术运算符 +-*/ //（取整除） %求余 ** 幂   赋值运算 1 2 3 4 5 6 7  += -= *= /= %= **= 幂赋值运算符 //= 取整除赋值运算符   ==- while循环== 1 2 3 4 5 6 7 8  complex（）创建一个复数 eval（）运算python中有效表达式并返回一个对象 tuple（）将序列s转换为一个元组 list（）转换为列表 unichr()转换为Unicode字符 ord（）转换为它的整数值 hex() 将一个整数转换为一个十六进制的字符串 oct()将一个整数转换为一个八进制字符串   ","date":"2018-06-03T10:22:36+08:00","permalink":"https://sunnnner.github.io/p/python%E5%9F%BA%E7%A1%80/","title":"Python基础"},{"content":"Ajax语法  现在写ajax写的我很难受下面就是我在搜索的时候遇到的标签的意思  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  $(\u0026#39;.show_prize\u0026#39;)获取为show_pirze的标签 .children（‘em’）获取子元素为em的标签 。text（）获取他的文本 .val() 获取他的值 parseInt 强制类型转换成整形 .toFixed(sun) 保留小数点后sun位 。click（）侦听点击事件 .blur()当输入域失去焦点 (blur .trim()去除两边空白 .each() 方法规定为每个匹配元素规定运行的函数 find() 方法获得当前元素集合中每个元素的后代，通过选择器、jQuery 对象或元素来筛选。 .find(\u0026#39;:checked\u0026#39;)获取type标签的属性必须用“：”来选择 $(\u0026#34;b\u0026#34;).parents()查找每个 b 元素的所有父元素 change事件改变 。prop() 方法设置或返回被选元素的属性和值。 .attr()attr() 方法设置或返回被选元素的属性值。 remove()移除对应的元素 $.ajaxSettings.async = true//设置异步 $.ajaxSettings.async = false;//设置同步   全选和全不选 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  $(\u0026#39;.settlements\u0026#39;).find(\u0026#39;:checkbox\u0026#39;).change(function () { //获取全选checkbox的选中状态  is_checked = $(this).prop(\u0026#39;checked\u0026#39;) //便利所有商品对应的checkbox,设置checked属性和全选checkbox一致  $(\u0026#39;.cart_list_td\u0026#39;).find(\u0026#39;:checkbox\u0026#39;).each(function () { $(this).prop(\u0026#39;checked\u0026#39;, is_checked) }) // 更新商品信息  update_total_price() }); //商品对应的checkbox状态发生改变是，全选checkbox的改变  $(\u0026#39;.cart_list_td\u0026#39;).find(\u0026#39;:checkbox\u0026#39;).change(function () { //获取所有的商品对应的chackedbox的数目  all_len = $(\u0026#39;.cart_list_td\u0026#39;).find(\u0026#39;:checkbox\u0026#39;).length; //获取所有被选中的CheckBox的数目  checked_len = $(\u0026#39;.cart_list_td\u0026#39;).find(\u0026#39;:checked\u0026#39;).length; if (checked_len \u0026lt; all_len){ $(\u0026#39;.settlements\u0026#39;).find(\u0026#39;:checkbox\u0026#39;).prop(\u0026#39;checked\u0026#39;, false) } else { $(\u0026#39;.settlements\u0026#39;).find(\u0026#39;:checkbox\u0026#39;).prop(\u0026#39;checked\u0026#39;, true) } // 更新商品信息  update_total_price1() })   ","date":"2018-06-02T10:21:32+08:00","permalink":"https://sunnnner.github.io/p/ajax%E8%AF%AD%E6%B3%95/","title":"Ajax语法"},{"content":"Django-setting配置Redis储存session 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # redis配置 CACHES= { \u0026#39;default\u0026#39;:{ \u0026#34;BACKEND\u0026#34;: \u0026#39;django_redis.cache.RedisCache\u0026#39;, \u0026#34;LOCATION\u0026#34;: \u0026#34;redis://127.0.0.1:6379/2\u0026#34;, \u0026#34;OPTIONS\u0026#34;: { \u0026#34;CLIENT_CLASS\u0026#34;: \u0026#34;django_redis.client.DefaultClient\u0026#34;, \u0026#34;PASSWORD\u0026#34;: \u0026#34;\u0026#34;, } } } # 储存session设置 SESSION_ENGING = \u0026#34;django.contrib.session.backends.cache\u0026#34; SESSION_CACHE_ALIAS = \u0026#34;default\u0026#34;   ","date":"2018-06-01T10:20:47+08:00","permalink":"https://sunnnner.github.io/p/django-redis%E9%85%8D%E7%BD%AE/","title":"Django Redis配置"},{"content":"第一步创建Django项目  django-admin startproject blog  创建第一个应用user  python manage.py startapp user  设置setting文件 1 2  ALLOWED_HOSTS=[“*”]//更改为所有都可以访问上线模式 INSTALLEN_APPS—》加入第一个user应用    创建templates文件夹 并设置TEMPLATES里面文件夹的路径os.path.join 设置DATABASES的储存为mysql  1 2 3 4 5 6 7 8 9 10 11  字段 DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.mysql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;bookstore\u0026#39;, \u0026#39;USER\u0026#39;:\u0026#39;root\u0026#39;, \u0026#39;PASSWORD\u0026#39;:\u0026#39;123\u0026#39;, \u0026#39;HOST\u0026#39;:\u0026#39;localhost\u0026#39;, \u0026#39;PORT\u0026#39;:3306, } }   修改语言与时区 1 2 3  LANGUAGE_CODE = \u0026#39;zh-Hans\u0026#39; TIME_ZONE = \u0026#39;Asia/Shanghai\u0026#39;   设置静态文件收集static文件夹并在setting设置 1 2 3 4  STATIC_URL = \u0026#39;/static/\u0026#39; STATICFILES_DIRS = [ os.path.join(BASE_DIR, \u0026#39;static\u0026#39;) ]   设置主页url与视图函数 1 2 3  url(r\u0026#39;^$\u0026#39;,index,name=\u0026#39;index\u0026#39;) def index(request): return render(request, \u0026#39;index.html\u0026#39;)   编写用户模块 编写注册模块  首先编写抽象类，所谓抽象类就是所有类模板都能用上的类 在根目录创建db pythonFile文件夹  创建base_model抽象基类抽象基类继承models.Model 1 2 3 4 5 6 7 8 9 10  from django.db import models class BaseModel(models.Model): \u0026#39;\u0026#39;\u0026#39;模型抽象基类\u0026#39;\u0026#39;\u0026#39; is_delete = models.BooleanField(default=False, verbose_name=\u0026#39;是否删除\u0026#39;) create_time = models.DateTimeField(auto_now_add=True, verbose_name=\u0026#39;创建时间\u0026#39;) update_time = models.DateTimeField(auto_now=True, verbose_name=\u0026#39;更新时间\u0026#39;) class Meta: # 继承抽象类 abstract = True    根目录创建utils文件夹该文件夹的作用作为加密用户密码 创建get_hash文件夹  1 2 3 4 5 6 7  from hashlib import sha256 def get_hash(str): \u0026#39;\u0026#39;\u0026#39;取一个字符串的hash值\u0026#39;\u0026#39;\u0026#39; sh = sha256 sh.update(str.encode(\u0026#39;utf8\u0026#39;)) return sh.hexdigest()    打开app内的models模块开始编写用户模块 导入get_hash函数 导入抽象基类 创建用户字段使其继承与抽象基类 其中db_table的作用为制定创建数据库的名称  1 2 3 4 5 6 7 8 9 10 11 12  class Passport(BaseModel): username = models.CharField(max_length=20,verbose_name=\u0026#39;用户名称\u0026#39;,unique=True) password = models.CharField(max_length=40,verbose_name=\u0026#39;用户密码\u0026#39;) email = models.EmailField(verbose_name=\u0026#39;用户邮箱\u0026#39;) is_active = models.BooleanField(default=False, verbose_name=\u0026#39;激活状态\u0026#39;) # 创建用户表的管理器 object = PassportManager() class Meta(): # 指定数据库名称 db_table = \u0026#39;s_user_accoumt\u0026#39;    创建添加用户跟查找用户模块注意此字段必须在用户模块的上方因为此字段继承的model.Manager模块在用户模块之上  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class PassportManager(models.Manager): def add_user(self,username, password, email): \u0026#39;\u0026#39;\u0026#39;添加一个用户信息\u0026#39;\u0026#39;\u0026#39; # s使用crate方法添加一个用户 passport = self.create(username=username, password=get_hash(password), email=email) # 并且返回当前的数据 return passport def find_user(self,username, password): \u0026#39;\u0026#39;\u0026#39;根据用户的信息进行查找用户\u0026#39;\u0026#39;\u0026#39; try: passport = self.get(username=username, password=get_hash(password)) except self.model.DoesNotExist: # 账户不存在 print(\u0026#34;=======\u0026#34;) passport = None # 返回当前的信息 return passport    创建完成之后python3 manage.py makemigrations迁移同步 编写用户注册视图函数  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  url(r’^/register/$’, register, name=’register’), def register(request): if request.method == \u0026#39;GET\u0026#39;: return render(request,\u0026#39;register.html\u0026#39;) else: username = request.POST.get(\u0026#39;user_name\u0026#39;) password = request.POST.get(\u0026#39;pwd\u0026#39;) password1 = request.POST.get(\u0026#39;cpwd\u0026#39;) email = request.POST.get(\u0026#39;email\u0026#39;) # all方法进行数据校验，如果里面任意值为空，就不通过校验 if not all([username,password,password1,email]): return render(request, \u0026#39;register.html\u0026#39;, { \u0026#39;msg\u0026#39;:\u0026#39;不能输入有空的参数\u0026#39; }) # 邮箱正则验证 if not re.match(r\u0026#39;[a-z0-9][\\w\\.\\-]*@[a-z0-9\\-]+(\\.[a-z]{2,5}){1,2}$\u0026#39;, email): return render(request, \u0026#39;register.html\u0026#39;, {\u0026#39;msg\u0026#39;:\u0026#39;输入的邮箱不正确\u0026#39;}) # 通过向数据库添加用户信息 # 调用添加用户的方法 passport = Passport.object.add_user(username=username, password=password, email=email) return redirect(reverse(\u0026#39;user:register\u0026#39;), {\u0026#39;cmsg\u0026#39;:\u0026#39;注册成功\u0026#39;})   创建登录模块  url(r’^login/$’, login, name=’login’), 因为登录模块用到ajax 所以我们先写前端数据 首先ajax传输不用表单数据我们就删除from表单  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  \u0026lt;div class=\u0026#34;form_input\u0026#34;\u0026gt; {% csrf_token %} \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;username\u0026#34; value=\u0026#34;{{ username }}\u0026#34; class=\u0026#34;name_input\u0026#34; placeholder=\u0026#34;请输入用户名\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;user_error\u0026#34;\u0026gt;输入错误\u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; id=\u0026#34;pwd\u0026#34; class=\u0026#34;pass_input\u0026#34; placeholder=\u0026#34;请输入密码\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;pwd_error\u0026#34;\u0026gt;输入错误\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;more_input clearfix\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;remember\u0026#34; checked={{ checked }}\u0026gt; \u0026lt;label\u0026gt;记住用户名\u0026lt;/label\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;忘记密码\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnLogin\u0026#34; value=\u0026#34;登录\u0026#34; class=\u0026#34;input_submit\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; AJAX \u0026lt;script src=\u0026#34;{% static \u0026#39;js/jquery-1.12.4.min.js\u0026#39; %}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; $(function () { $(\u0026#39;#btnLogin\u0026#39;).click(function () { //获取用户名和密码  # 使用jquay获取用户的信息 var username = $(\u0026#39;#username\u0026#39;).val(); var password = $(\u0026#39;#pwd\u0026#39;).val(); # 设置csrf_token为标签设置其属性name=csrfmiddlewaretoken并将获取到的cdrf_token的值赋值给csrf var csrf = $(\u0026#39;input[name=\u0026#34;csrfmiddlewaretoken\u0026#34;]\u0026#39;).val(); # 返回当前记住用户的状态true/false var remember = $(\u0026#39;#remember\u0026#39;).prop(\u0026#39;checked\u0026#39;); //发起ajax请求  params = {\u0026#39;username\u0026#39;:username, \u0026#39;password\u0026#39;:password, \u0026#39;csrfmiddlewaretoken\u0026#39;:csrf, \u0026#39;remember\u0026#39;:remember}; //ajax将python字典转换为了json字符串型字典此时类型为json类型  $.post(\u0026#39;{% url \u0026#34;user:login\u0026#34; %}\u0026#39;, params, function(data){ //用户名密码错误{\u0026#39;res\u0026#39;:0}  //登录成功{\u0026#39;res\u0026#39;:1}  //状态码状态码为01，2  if (data.res == 0) { alert(\u0026#39;用户名或者密码错误\u0026#39;) } else if(data.res == 1) { //跳转页面 获取后端next_url  location.href = data.next_url } else if(data.res == 2) { alert(\u0026#39;请填写完整的用户名或者密码\u0026#39;) } }) }) }) \u0026lt;/script\u0026gt;   后端代码  用户登录校验  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  def login(request): if request.method == \u0026#39;GET\u0026#39;: # 记住用户名功能 checked表示单选框状态 if request.COOKIES.get(\u0026#34;username\u0026#34;): username = request.COOKIES.get(\u0026#34;username\u0026#34;) checked = True else: username = \u0026#39;\u0026#39; checked = \u0026#39;\u0026#39; context = { \u0026#39;username\u0026#39;: username, \u0026#39;checked\u0026#39; : checked, } return render(request, \u0026#39;login.html\u0026#39;, context) elif request.method == \u0026#39;POST\u0026#39;: # 此时post取的是前段ajax数据并不是表单数据因为表单已经删除 username = request.POST.get(\u0026#39;username\u0026#39;) password = request.POST.get(\u0026#39;password\u0026#39;) remember = request.POST.get(\u0026#39;remember\u0026#39;) # 数据校验 使用all()方法进行校验只有两个都不为空时才为true if not all([username, password]): # 数据为空 返回ajax里面的状态码json数据 return JsonResponse({\u0026#39;res\u0026#39;: 2}) # 调用查找方法判断用户是否存在 passport = Passport.object.find_user(username=username,password=password) if passport: # 两种方法都是重定向到主页 # next_url = request.session.get(\u0026#39;url_path\u0026#39;, reverse(\u0026#39;index\u0026#39;)) next_url = \u0026#39;/\u0026#39; print(\u0026#39;---------------\u0026#39;) # 登录成功 返回状态码并设置next_url数据传输到前段都是字典模式会自动转换成json字符串 jire = JsonResponse({\u0026#39;res\u0026#39;: 1, \u0026#39;next_url\u0026#39;: next_url}) # 如果单选框选中 if remember == \u0026#39;true\u0026#39;: # 记住用户名并设置cookie的保存时间 jire.set_cookie(\u0026#39;username\u0026#39;, username, max_age=1*24*3600) else: # 不要记住用户名并删除cookie jire.delete_cookie(\u0026#39;username\u0026#39;) # 记住用户名的状态 # 设置是否登录状态前段要用用session保存到服务器 request.session[\u0026#39;islogin\u0026#39;] = True request.session[\u0026#39;username\u0026#39;] = username # 当前用户的唯一标示 request.session[\u0026#39;passport_id\u0026#39;] = passport.id return jire else: return JsonResponse({\u0026#39;res\u0026#39;: 0})   退出 1 2 3 4 5 6 7  url(r’^logout/$’, logout, name=’logout’), def logout(request): \u0026#39;\u0026#39;\u0026#39;用户退出操作\u0026#39;\u0026#39;\u0026#39; # 清空用户session数据 request.session.flush() # 然后跳转首页 return redirect(reverse(\u0026#39;index\u0026#39;))   ","date":"2018-06-01T10:15:16+08:00","permalink":"https://sunnnner.github.io/p/django%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9D%97/","title":"Django用户模块"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  1) 绑定IP地址,看业务开放bind 0.0.0.02)Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程，设置为nodaemonize no3)保护模式protected-mode no # 检查启动状态命令ps -ef|grep redis |grep 6379mac以配置文件启动sudo redis-server /usr/local/etc/redis.confUbuntu以配置文件启动sudo redis-server /etc/redis/redis.conf  ","date":"2018-05-31T18:53:17+08:00","permalink":"https://sunnnner.github.io/p/redis%E9%85%8D%E7%BD%AE/","title":"Redis配置"},{"content":"··· 我理解是压缩代码然后减少请求，多使用ajax 图片存第三方资源库\n全静态，读写分离，加带宽 再开cdn\n","date":"2018-05-31T18:47:29+08:00","permalink":"https://sunnnner.github.io/p/%E6%80%8E%E4%B9%88%E5%8A%A0%E5%BF%AB%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/","title":"怎么加快页面的访问速度"},{"content":" 首先新建app—\u0026gt;books并添加settings里面 因为我们需要在后台admin上传数据所以我们要创建富文本管理器并在setting设置他的选项 富文本管理器是一个插件我们这次使用的是tinymce并且我们需要将它加入到apps里面因为他是一个应用，但是这个应用是需要下载的  1 2 3 4 5  TINTMCE_DEFAULT_CONFIG = { \u0026#39;theme\u0026#39;: \u0026#34;modern\u0026#34;, \u0026#39;wight\u0026#39;: 600, \u0026#39;height\u0026#39;: 400, }     我们需要设置制定一个媒体文件夹来存放我们的图片MEDIA_ROOT = os.path.join(BASE_DIR, 'static')\n  添加应用的urls``\n  1 2  url(r\u0026#39;^books/\u0026#39;, include(\u0026#39;books.urls\u0026#39;,namespace=\u0026#39;books\u0026#39;)), url(r\u0026#39;^tinymce/\u0026#39;, include(\u0026#39;tinymce.urls\u0026#39;,namespace=\u0026#39;tinymce\u0026#39;)),    我们开始写books里面的字段首先查看页面我们需要什么字段 首先我们创建tinymac富文本需要的字段，这里的字段映射全局 在books目录下创建任意的.py文件这里我的是emums.py  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  # 此处1，2，3，4代表书本的id PYTHON = 1 JAVASCRIPT = 2 ALGORITHMS = 3 MACHINELEARNING = 4 OPERATINSGYSTEM = 5 DATABASE = 6 # BOOKS_TYPE作为一个字典传输到models BOOKS_TYPE = { PYTHON: \u0026#39;python\u0026#39;, JAVASCRIPT: \u0026#39;javascript\u0026#39;, ALGORITHMS: \u0026#39;数据库结构与算法\u0026#39;, MACHINELEARNING: \u0026#39;机器学习\u0026#39;, OPERATINSGYSTEM: \u0026#39;操作系统\u0026#39;, DATABASE: \u0026#39;数据库\u0026#39;, } # 代表商品的上线或者下线状态 OFFLINE = 0 ONLINE = 1 STATUS_CHOICE = { OFFLINE: \u0026#39;下线\u0026#39;, ONLINE: \u0026#39;上线\u0026#39;, }    我们开始写models.py  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  from django.db import models from db.base_model import BaseModel from tinymce.models import HTMLField from books.enums import BOOKS_TYPE, STATUS_CHOICE,PYTHON,ONLINE # Create your models here. class BookManager(models.Manager): \u0026#39;\u0026#39;\u0026#39;商品模型管理器类\u0026#39;\u0026#39;\u0026#39; # type_id 表示前段传输商品id进行查找商品. limit表示返回几个之前的商品的数据, sort代表排序状态，初始值默认 def get_books_by_type(self, type_id, limit=None, sort=\u0026#39;default\u0026#39;): \u0026#39;\u0026#39;\u0026#39;根据商品类型id查询商品信息\u0026#39;\u0026#39;\u0026#39; # 如果是新商品就根据他的添加时间进行排序-代表从大到小进行排序 if sort == \u0026#39;new\u0026#39;: order_by = (\u0026#39;-create_time\u0026#39;,) # 根据销量最多进行排序 elif sort == \u0026#39;hot\u0026#39;: order_by = (\u0026#39;-sales\u0026#39;,) # 根据价格进行排序 elif sort == \u0026#39;price\u0026#39;: order_by = (\u0026#39;price\u0026#39;,) else: # pk国外代表一种主键的简写，别的名字也行这是整个表的主键，这里代表的意思就是默认按照主键primary_key从大到小默认进行排序 order_by = (\u0026#39;-pk\u0026#39;,) # 查询数据 filter是过滤数据，order_by是排序，(*order_by)是对上面的order_by进行解包成列表 # 对解包的数据进行过滤排序并返回一个新的列表books_li books_li = self.filter(type_id=type_id).order_by(*order_by) # 查询结果集的限制 if limit: books_li = books_li[:limit] return books_li def get_books_by_id(self, books_id): \u0026#39;\u0026#39;\u0026#39;根据商品id获取商品信息\u0026#39;\u0026#39;\u0026#39; try: books = self.get(id=books_id) except self.model.DoesNotExist: # 商品不存在 books = None return books class Books(BaseModel): \u0026#39;\u0026#39;\u0026#39;商品模型类\u0026#39;\u0026#39;\u0026#39; # 使用迭代器进行数据赋值 因为books_type是字典所以要取items books_type_choices = ((k, v) for k, v in BOOKS_TYPE.items()) status_choices = ((k, v) for k, v in STATUS_CHOICE.items()) # 定义书籍的id与书籍的状态 type_id = models.SmallIntegerField(default=PYTHON, choices=books_type_choices,verbose_name=\u0026#39;商品种类\u0026#39;) name = models.CharField(max_length=20, verbose_name=\u0026#39;商品名称\u0026#39;) desc = models.CharField(max_length=128, verbose_name=\u0026#39;商品简介\u0026#39;) # decimal_places代表小数后两位 price = models.DecimalField(max_digits=10, decimal_places=2, verbose_name=\u0026#39;商品价格\u0026#39;) unit = models.CharField(max_length=20, verbose_name=\u0026#39;商品单位\u0026#39;) stock = models.IntegerField(default=1, verbose_name=\u0026#39;商品库存\u0026#39;) sales = models.IntegerField(default=0, verbose_name=\u0026#39;商品销量\u0026#39;) detail = HTMLField(verbose_name=\u0026#39;商品详情\u0026#39;) # upload_to所以可以用uoload_to来指定文件存放的前缀路径 # 实际的路径就是 MEDIA_ROOT/books/filename image = models.ImageField(upload_to=\u0026#39;books\u0026#39;, verbose_name=\u0026#39;商品图片\u0026#39;) status = models.SmallIntegerField(default= ONLINE, choices=status_choices,verbose_name=\u0026#39;商品状态\u0026#39;) def __str__(self): return self.name # 创建事务管理器 object = BookManager() class Meta(): #制定数据库名称 db_table = \u0026#39;s_books\u0026#39;    将用户模块注册到admin  1 2 3 4 5  from django.contrib import admin from books.models import Books # Register your models here. admin.site.register(Books)    创建用户主页视图views信息  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  from django.shortcuts import render,redirect from books.models import Books from books.enums import * from django.core.urlresolvers import reverse from django.core.paginator import Paginator # Create your views here. def index(request): \u0026#39;\u0026#39;\u0026#39;显示首页\u0026#39;\u0026#39;\u0026#39; python_new = Books.object.get_books_by_type(PYTHON, 3, sort=\u0026#39;new\u0026#39;) python_hot = Books.object.get_books_by_type(PYTHON, 4, sort=\u0026#39;hot\u0026#39;) javascript_new = Books.object.get_books_by_type(JAVASCRIPT, 3, sort=\u0026#39;new\u0026#39;) javascript_hot = Books.object.get_books_by_type(JAVASCRIPT, 4, sort=\u0026#39;hot\u0026#39;) algorithms_new = Books.object.get_books_by_type(ALGORITHMS, 3, sort=\u0026#39;new\u0026#39;) algorithms_hot = Books.object.get_books_by_type(ALGORITHMS, 4, sort=\u0026#39;new\u0026#39;) machinelearning_new = Books.object.get_books_by_type(MACHINELEARNING, 3,sort=\u0026#39;new\u0026#39;) machinelearning_hot = Books.object.get_books_by_type(MACHINELEARNING, 4, sort=\u0026#39;hot\u0026#39;) operatingsystem_new = Books.object.get_books_by_type(OPERATINSGYSTEM, 3, sort=\u0026#39;new\u0026#39;) operatingsystem_hot = Books.object.get_books_by_type(OPERATINSGYSTEM, 4, sort=\u0026#39;hot\u0026#39;) database_new = Books.object.get_books_by_type(DATABASE, 3, sort=\u0026#39;new\u0026#39;) database_hot = Books.object.get_books_by_type(DATABASE, 4, sort=\u0026#39;hot\u0026#39;) # 定义模板上下文 content = { \u0026#39;python_new\u0026#39;: python_new, \u0026#39;python_hot\u0026#39;: python_hot, \u0026#39;javascript_new\u0026#39;: javascript_new, \u0026#39;javascript_hot\u0026#39;: javascript_hot, \u0026#39;algorithms_new\u0026#39;: algorithms_new, \u0026#39;algorithms_hot\u0026#39;: algorithms_hot, \u0026#39;machinelearning_new\u0026#39;: machinelearning_new, \u0026#39;machinelearning_hot\u0026#39;: machinelearning_hot, \u0026#39;operatingsystem_new\u0026#39;: operatingsystem_new, \u0026#39;operatingsystem_hot\u0026#39;: operatingsystem_hot, \u0026#39;database_new\u0026#39;: database_new, \u0026#39;database_hot\u0026#39;: database_hot, } return render(request, \u0026#39;index.html\u0026#39;, content)    创建商品详情页 首先创建urlurl(r'^(?P\u0026lt;books_id\u0026gt;\\d+)/$',deatil,name='deatil') 创建视图  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def deatil(request, books_id): \u0026#39;\u0026#39;\u0026#39;显示商品的详细信息\u0026#39;\u0026#39;\u0026#39; books = Books.object.get_books_by_id(books_id=books_id) if books is None: return redirect(reverse(\u0026#39;index\u0026#39;)) # 新品推荐 books_li = Books.object.get_books_by_type(type_id=books.type_id, limit=2, sort=\u0026#39;new\u0026#39;) # 定义返回数据 content = { \u0026#39;books\u0026#39;: books, \u0026#39;books_li\u0026#39;: books_li, } return render(request, \u0026#39;detail.html\u0026#39;, content)    设置前端显示模板语言  ","date":"2018-05-31T18:47:29+08:00","permalink":"https://sunnnner.github.io/p/%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91/","title":"页面开发"}]